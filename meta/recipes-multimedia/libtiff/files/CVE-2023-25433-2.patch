From 9c22495e5eeeae9e00a1596720c969656bb8d678 Mon Sep 17 00:00:00 2001
From: Su_Laus <sulau@freenet.de>
Date: Fri, 3 Feb 2023 15:31:31 +0100
Subject: [PATCH] tiffcrop correctly update buffersize after rotateImage()
 fix#520 rotateImage() set up a new buffer and calculates its size
 individually. Therefore, seg_buffs[] size needs to be updated accordingly.
 Before this fix, the seg_buffs buffer size was calculated with a different
 formula than within rotateImage().

Closes #520.

Upstream-Status: Backport [https://gitlab.com/libtiff/libtiff/-/commit/9c22495e5eeeae9e00a1596720c969656bb8d678]
CVE: CVE-2023-25433
Signed-off-by: Vijay Anusuri <vanusuri@mvista.com>
---
 tools/tiffcrop.c | 33 ++++++++++++++++++++++-----------
 1 file changed, 22 insertions(+), 11 deletions(-)

diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index a616bff..2d1a309 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -537,7 +537,7 @@ static int rotateContigSamples24bits(uint16, uint16, uint16, uint32,
 static int rotateContigSamples32bits(uint16, uint16, uint16, uint32, 
                                      uint32,   uint32, uint8 *, uint8 *);
 static int rotateImage(uint16, struct image_data *, uint32 *, uint32 *,
- 		       unsigned char **, int);
+ 		       unsigned char **, size_t *, int);
 static int mirrorImage(uint16, uint16, uint16, uint32, uint32,
 		       unsigned char *);
 static int invertImage(uint16, uint16, uint16, uint32, uint32,
@@ -6388,7 +6388,7 @@ static int  correct_orientation(struct image_data *image, unsigned char **work_b
        * but switch xres, yres there. */
       uint32_t width = image->width;
       uint32_t length = image->length;
-      if (rotateImage(rotation, image, &width, &length, work_buff_ptr, TRUE))
+      if (rotateImage(rotation, image, &width, &length, work_buff_ptr, NULL, TRUE))
       {
       TIFFError ("correct_orientation", "Unable to rotate image");
       return (-1);
@@ -7611,16 +7611,20 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
 
     if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
       {
-      if (rotateImage(crop->rotation, image, &crop->combined_width, 
-                      &crop->combined_length, &crop_buff, FALSE))
+        /* rotateImage() set up a new buffer and calculates its size
+         * individually. Therefore, seg_buffs size  needs to be updated
+         * accordingly. */
+         size_t rot_buf_size = 0;
+         if (rotateImage(crop->rotation, image, &crop->combined_width, 
+                         &crop->combined_length, &crop_buff, &rot_buf_size,
+                         FALSE))
         {
         TIFFError("processCropSelections", 
                   "Failed to rotate composite regions by %d degrees", crop->rotation);
         return (-1);
         }
       seg_buffs[0].buffer = crop_buff;
-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)
-                            * image->spp) * crop->combined_length; 
+      seg_buffs[0].size = rot_buf_size;
       }
     }
   else  /* Separated Images */
@@ -7717,8 +7721,13 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
 
       if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
         {
+        /* Furthermore, rotateImage() set up a new buffer and calculates
+         * its size individually. Therefore, seg_buffs size  needs to be
+         * updated accordingly. */
+        size_t rot_buf_size = 0;
 	if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, 
-			&crop->regionlist[i].length, &crop_buff, FALSE))
+			&crop->regionlist[i].length, &crop_buff,
+                        &rot_buf_size, FALSE))
           {
           TIFFError("processCropSelections", 
                     "Failed to rotate crop region by %d degrees", crop->rotation);
@@ -7729,8 +7738,7 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
         crop->combined_width = total_width;
         crop->combined_length = total_length;
         seg_buffs[i].buffer = crop_buff;
-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)
-                               * image->spp) * crop->regionlist[i].length; 
+        seg_buffs[i].size = rot_buf_size;
         }
       }
     }
@@ -7850,7 +7858,7 @@ createCroppedImage(struct image_data *image, struct crop_mask *crop,
   if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
     {
     if (rotateImage(crop->rotation, image, &crop->combined_width, 
-                    &crop->combined_length, crop_buff_ptr, TRUE))
+                    &crop->combined_length, crop_buff_ptr, NULL, TRUE))
       {
       TIFFError("createCroppedImage", 
                 "Failed to rotate image or cropped selection by %d degrees", crop->rotation);
@@ -8513,7 +8521,8 @@ rotateContigSamples32bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,
 /* Rotate an image by a multiple of 90 degrees clockwise */
 static int
 rotateImage(uint16 rotation, struct image_data *image, uint32 *img_width, 
-            uint32 *img_length, unsigned char **ibuff_ptr, int rot_image_params)
+            uint32 *img_length, unsigned char **ibuff_ptr, size_t *rot_buf_size,
+            int rot_image_params)
   {
   int      shift_width;
   uint32   bytes_per_pixel, bytes_per_sample;
@@ -8595,6 +8604,8 @@ rotateImage(uint16 rotation, struct image_data *image, uint32 *img_width,
     return (-1);
     }
   _TIFFmemset(rbuff, '\0', buffsize + NUM_BUFF_OVERSIZE_BYTES);
+  if (rot_buf_size != NULL)
+      *rot_buf_size = buffsize;
 
   ibuff = *ibuff_ptr;
   switch (rotation)
-- 
2.18.2

