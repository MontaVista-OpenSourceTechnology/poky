From 4e294e46038556d20531e1d0c5559d678a8fa4c5 Mon Sep 17 00:00:00 2001
From: Arthur Taylor <art@ified.ca>
Date: Mon, 19 Mar 2018 14:13:15 -0700
Subject: [PATCH] Introduce ogg_read_first_page () to avoid seeks on open.

Reduce some code duplication of reading the first page of an Ogg bitstream while
also removing the need to re-read the beginning of a file when opening. Fixes
the issue of being unable to read Ogg bitstreams (a container designed for
streaming) from a pipe.

Upstream-Status: Backport [import from RHEL8 libsndfile-1.0.28-16.el8_10.src.rpm
Upstream commit https://github.com/libsndfile/libsndfile/commit/4e294e46038556d20531e1d0c5559d678a8fa4c5]
CVE: CVE-2024-50612
Signed-off-by: Vijay Anusuri <vanusuri@mvista.com>
---
 src/ogg.c        | 10 ++++++++++
 src/ogg.h        |  6 ++++++
 src/ogg_vorbis.c |  9 +++------
 3 files changed, 19 insertions(+), 6 deletions(-)

diff --git a/src/ogg.c b/src/ogg.c
index 0856f77..5204a73 100644
--- a/src/ogg.c
+++ b/src/ogg.c
@@ -44,6 +44,16 @@ static int	ogg_close (SF_PRIVATE *psf) ;
 static int	ogg_stream_classify (SF_PRIVATE *psf, OGG_PRIVATE * odata) ;
 static int	ogg_page_classify (SF_PRIVATE * psf, const ogg_page * og) ;
 
+int
+ogg_write_page (SF_PRIVATE *psf, ogg_page *page)
+{       int bytes ;
+
+	bytes = psf_fwrite (page->header, 1, page->header_len, psf) ;
+	bytes += psf_fwrite (page->body, 1, page->body_len, psf) ;
+
+	return bytes == page->header_len + page->body_len ;
+} /* ogg_write_page */
+
 int
 ogg_open (SF_PRIVATE *psf)
 {	OGG_PRIVATE* odata = calloc (1, sizeof (OGG_PRIVATE)) ;
diff --git a/src/ogg.h b/src/ogg.h
index 88544bb..3cb6d07 100644
--- a/src/ogg.h
+++ b/src/ogg.h
@@ -49,4 +49,10 @@ typedef struct
 
 
 
+/*
+** Write the whole Ogg page out. Convenience function as the ogg_page struct
+** splits header and body data into separate buffers.
+*/
+int	ogg_write_page	(SF_PRIVATE *, ogg_page *) ;
+
 #endif /* SF_SRC_OGG_H */
diff --git a/src/ogg_vorbis.c b/src/ogg_vorbis.c
index 78acd38..03c34d5 100644
--- a/src/ogg_vorbis.c
+++ b/src/ogg_vorbis.c
@@ -423,8 +423,7 @@ vorbis_write_header (SF_PRIVATE *psf, int UNUSED (calc_length))
 		 * audio data will start on a new page, as per spec
 		 */
 		while ((result = ogg_stream_flush (&odata->ostream, &odata->opage)) != 0)
-		{	psf_fwrite (odata->opage.header, 1, odata->opage.header_len, psf) ;
-			psf_fwrite (odata->opage.body, 1, odata->opage.body_len, psf) ;
+		{	ogg_write_page (psf, &odata->opage) ;
 			} ;
 	}
 
@@ -463,8 +462,7 @@ vorbis_close (SF_PRIVATE *psf)
 				while (!odata->eos)
 				{	int result = ogg_stream_pageout (&odata->ostream, &odata->opage) ;
 					if (result == 0) break ;
-					psf_fwrite (odata->opage.header, 1, odata->opage.header_len, psf) ;
-					psf_fwrite (odata->opage.body, 1, odata->opage.body_len, psf) ;
+					ogg_write_page (psf, &odata->opage) ;
 
 		/* this could be set above, but for illustrative purposes, I do
 		   it here (to show that vorbis does know where the stream ends) */
@@ -778,8 +776,7 @@ vorbis_write_samples (SF_PRIVATE *psf, OGG_PRIVATE *odata, VORBIS_PRIVATE *vdata
 			{	int result = ogg_stream_pageout (&odata->ostream, &odata->opage) ;
 				if (result == 0)
 					break ;
-				psf_fwrite (odata->opage.header, 1, odata->opage.header_len, psf) ;
-				psf_fwrite (odata->opage.body, 1, odata->opage.body_len, psf) ;
+				ogg_write_page (psf, &odata->opage) ;
 
 				/*	This could be set above, but for illustrative purposes, I do
 				**	it here (to show that vorbis does know where the stream ends) */
-- 
2.24.4

