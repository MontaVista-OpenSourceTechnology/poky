
m 83056792a8bd179d7e4ba4b3d234ab75205e47d2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?= <sebastian@centricular.com>
Date: Fri, 27 Sep 2024 10:39:30 +0300
Subject: [PATCH] qtdemux: Actually handle errors returns from various
 functions instead of ignoring them

Ignoring them might cause the element to continue as if all is fine despite the
internal state being inconsistent. This can lead to all kinds of follow-up
issues, including memory safety issues.

Thanks to Antonio Morales for finding and reporting the issue.

Fixes GHSL-2024-245
Fixes https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/3847

Part-of: <https://gitlab.freedesktop.org/gstreamer/gstreamer/-/merge_requests/8060>
---
 subprojects/gst-plugins-good/gst/isomp4/qtdemux.c | 29 ++++++++++++++++++-----
 1 file changed, 23 insertions(+), 6 deletions(-)

This fixes CVE-2024-47597. Patch #2.

Signed-off-by: Javier Campos <jcampos@mvista.com>

Index: gst-plugins-good-1.12.2/gst/isomp4/qtdemux.c
===================================================================
--- gst-plugins-good-1.12.2.orig/gst/isomp4/qtdemux.c
+++ gst-plugins-good-1.12.2/gst/isomp4/qtdemux.c
@@ -4524,10 +4524,15 @@ gst_qtdemux_loop_state_header (GstQTDemu
 beach:
   if (ret == GST_FLOW_EOS && (qtdemux->got_moov || qtdemux->media_caps)) {
     /* digested all data, show what we have */
-    qtdemux_prepare_streams (qtdemux);
+    ret = qtdemux_prepare_streams (qtdemux);
+    if (ret != GST_FLOW_OK)
+      return ret;
+
     QTDEMUX_EXPOSE_LOCK (qtdemux);
     ret = qtdemux_expose_streams (qtdemux);
     QTDEMUX_EXPOSE_UNLOCK (qtdemux);
+    if (ret != GST_FLOW_OK)
+      return ret;
 
     qtdemux->state = QTDEMUX_STATE_MOVIE;
     GST_DEBUG_OBJECT (qtdemux, "switching state to STATE_MOVIE (%d)",
@@ -6846,13 +6851,21 @@ gst_qtdemux_process_adapter (GstQTDemux
                 g_list_concat (demux->old_streams, demux->active_streams);
             demux->active_streams = NULL;
 
-            qtdemux_parse_moov (demux, data, demux->neededbytes);
+            if (!qtdemux_parse_moov (demux, data, demux->neededbytes)) {
+              ret = GST_FLOW_ERROR;
+              break;
+            }
             qtdemux_node_dump (demux, demux->moov_node);
             qtdemux_parse_tree (demux);
-            qtdemux_prepare_streams (demux);
+            ret = qtdemux_prepare_streams (demux);
+            if (ret != GST_FLOW_OK)
+              break;
+
             QTDEMUX_EXPOSE_LOCK (demux);
-            qtdemux_expose_streams (demux);
+            ret = qtdemux_expose_streams (demux);
             QTDEMUX_EXPOSE_UNLOCK (demux);
+            if (ret != GST_FLOW_OK)
+              break;
 
             demux->got_moov = TRUE;
             gst_qtdemux_check_send_pending_segment (demux);
@@ -6958,8 +6971,10 @@ gst_qtdemux_process_adapter (GstQTDemux
                       demux->segment_seqnum);
               }
               QTDEMUX_EXPOSE_LOCK (demux);
-              qtdemux_expose_streams (demux);
+              ret = qtdemux_expose_streams (demux);
               QTDEMUX_EXPOSE_UNLOCK (demux);
+              if (ret != GST_FLOW_OK)
+                goto done;
             }
           } else {
             GST_DEBUG_OBJECT (demux, "Discarding [moof]");
@@ -12271,8 +12286,10 @@ qtdemux_prepare_streams (GstQTDemux * qt
 
     /* parse the initial sample for use in setting the frame rate cap */
     while (sample_num == 0 && sample_num < stream->n_samples) {
-      if (!qtdemux_parse_samples (qtdemux, stream, sample_num))
+      if (!qtdemux_parse_samples (qtdemux, stream, sample_num)) {
+        ret = GST_FLOW_ERROR;
         break;
+      }
       ++sample_num;
     }
     if (stream->n_samples > 0 && stream->stbl_index >= 0) {
