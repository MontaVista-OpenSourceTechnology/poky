From 0227130244c007870c106fc613903d078730e45c Mon Sep 17 00:00:00 2001
From: Johannes Schindelin <Johannes.Schindelin@gmx.de>
Date: Thu, 12 Jan 2023 01:05:02 +0100
Subject: [PATCH] attr: adjust a mismatched data type

On platforms where `size_t` does not have the same width as `unsigned
long`, passing a pointer to the former when a pointer to the latter is
expected can lead to problems.

Windows and 32-bit Linux are among the affected platforms.

In this instance, we want to store the size of the blob that was read in
that variable. However, `read_blob_data_from_index()` passes that
pointer to `read_object_file()` which expects an `unsigned long *`.
Which means that on affected platforms, the variable is not fully
populated and part of its value is left uninitialized. (On Big-Endian
platforms, this problem would be even worse.)

The consequence is that depending on the uninitialized memory's
contents, we may erroneously reject perfectly fine attributes.

Let's address this by passing a pointer to a variable of the expected
data type.

Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
Signed-off-by: Junio C Hamano <gitster@pobox.com>

Upstream-Status: Backport [https://github.com/git/git/commit/0227130244c007870c106fc613903d078730e45c]
Signed-off-by: Vijay Anusuri <vanusuri@mvista.com>
---
 attr.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/attr.c b/attr.c
index 0188ace..b371a60 100644
--- a/attr.c
+++ b/attr.c
@@ -768,7 +768,7 @@ static struct attr_stack *read_attr_from_index(const char *path, int macro_ok)
 	struct attr_stack *res;
 	char *buf, *sp;
 	int lineno = 0;
-        size_t size;
+        unsigned long size;
 
 	buf = read_blob_data_from_index(use_index ? use_index : &the_index, path, &size);
 	if (!buf)
-- 
2.18.2

