From d10cc8c16c53a3092457f6cc89dc727685d17364 Mon Sep 17 00:00:00 2001
From: Vijay Anusuri <vanusuri@mvista.com>
Date: Thu, 22 Dec 2022 11:32:09 +0000
Subject: [PATCH] builtin/clone.c: disallow --local clones with symlinks

When cloning a repository with `--local`, Git relies on either making a
hardlink or copy to every file in the "objects" directory of the source
repository. This is done through the callpath `cmd_clone()` ->
`clone_local()` -> `copy_or_link_directory()`.

The way this optimization works is by enumerating every file and
directory recursively in the source repository's `$GIT_DIR/objects`
directory, and then either making a copy or hardlink of each file. The
only exception to this rule is when copying the "alternates" file, in
which case paths are rewritten to be absolute before writing a new
"alternates" file in the destination repo.

One quirk of this implementation is that it dereferences symlinks when
cloning. This behavior was most recently modified in 36596fd (clone:
better handle symlinked files at .git/objects/, 2019-07-10), which
attempted to support `--local` clones of repositories with symlinks in
their objects directory in a platform-independent way.

Unfortunately, this behavior of dereferencing symlinks (that is,
creating a hardlink or copy of the source's link target in the
destination repository) can be used as a component in attacking a
victim by inadvertently exposing the contents of file stored outside of
the repository.

Take, for example, a repository that stores a Dockerfile and is used to
build Docker images. When building an image, Docker copies the directory
contents into the VM, and then instructs the VM to execute the
Dockerfile at the root of the copied directory. This protects against
directory traversal attacks by copying symbolic links as-is without
dereferencing them.

That is, if a user has a symlink pointing at their private key material
(where the symlink is present in the same directory as the Dockerfile,
but the key itself is present outside of that directory), the key is
unreadable to a Docker image, since the link will appear broken from the
container's point of view.

This behavior enables an attack whereby a victim is convinced to clone a
repository containing an embedded submodule (with a URL like
"file:///proc/self/cwd/path/to/submodule") which has a symlink pointing
at a path containing sensitive information on the victim's machine. If a
user is tricked into doing this, the contents at the destination of
those symbolic links are exposed to the Docker image at runtime.

One approach to preventing this behavior is to recreate symlinks in the
destination repository. But this is problematic, since symlinking the
objects directory are not well-supported. (One potential problem is that
when sharing, e.g. a "pack" directory via symlinks, different writers
performing garbage collection may consider different sets of objects to
be reachable, enabling a situation whereby garbage collecting one
repository may remove reachable objects in another repository).

Instead, prohibit the local clone optimization when any symlinks are
present in the `$GIT_DIR/objects` directory of the source repository.
Users may clone the repository again by prepending the "file://" scheme
to their clone URL, or by adding the `--no-local` option to their `git
clone` invocation.

The directory iterator used by `copy_or_link_directory()` must no longer
dereference symlinks (i.e., it *must* call `lstat()` instead of `stat()`
in order to discover whether or not there are symlinks present). This has
no bearing on the overall behavior, since we will immediately `die()` on
encounter a symlink.

Note that t5604.33 suggests that we do support local clones with
symbolic links in the source repository's objects directory, but this
was likely unintentional, or at least did not take into consideration
the problem with sharing parts of the objects directory with symbolic
links at the time. Update this test to reflect which options are and
aren't supported.

Helped-by: Johannes Schindelin <Johannes.Schindelin@gmx.de>
Signed-off-by: Taylor Blau <me@ttaylorr.com>

Upstream-Status: Backport [https://github.com/git/git/commit/6f054f9fb3a501c35b55c65e547a244f14c38d56]
CVE: CVE-2022-39253
Signed-off-by: Vijay Anusuri <vanusuri@mvista.com>
---
 builtin/clone.c            | 65 ++++++++++++++++++++++++--------------
 t/t5604-clone-reference.sh | 62 ++++++++++++++++++++++++++++++++++++
 2 files changed, 104 insertions(+), 23 deletions(-)

diff --git a/builtin/clone.c b/builtin/clone.c
index d0e0ff1..1d75764 100644
--- a/builtin/clone.c
+++ b/builtin/clone.c
@@ -21,6 +21,8 @@
 #include "transport.h"
 #include "strbuf.h"
 #include "dir.h"
+#include "dir-iterator.h"
+#include "iterator.h"
 #include "sigchain.h"
 #include "branch.h"
 #include "remote.h"
@@ -390,50 +392,62 @@ static void copy_alternates(struct strbuf *src, struct strbuf *dst,
 	fclose(in);
 }
 
+static void mkdir_if_missing(const char *pathname, mode_t mode)
+{
+       struct stat st;
+
+       if (!mkdir(pathname, mode))
+               return;
+
+       if (errno != EEXIST)
+               die_errno(_("failed to create directory '%s'"), pathname);
+       else if (stat(pathname, &st))
+               die_errno(_("failed to stat '%s'"), pathname);
+       else if (!S_ISDIR(st.st_mode))
+               die(_("%s exists and is not a directory"), pathname);
+}
+
 static void copy_or_link_directory(struct strbuf *src, struct strbuf *dest,
 				   const char *src_repo, int src_baselen)
 {
-	struct dirent *de;
-	struct stat buf;
 	int src_len, dest_len;
 	DIR *dir;
+        int iter_status;
+        struct dir_iterator *iter;
 
 	dir = opendir(src->buf);
 	if (!dir)
 		die_errno(_("failed to open '%s'"), src->buf);
 
-	if (mkdir(dest->buf, 0777)) {
-		if (errno != EEXIST)
-			die_errno(_("failed to create directory '%s'"), dest->buf);
-		else if (stat(dest->buf, &buf))
-			die_errno(_("failed to stat '%s'"), dest->buf);
-		else if (!S_ISDIR(buf.st_mode))
-			die(_("%s exists and is not a directory"), dest->buf);
-	}
+        mkdir_if_missing(dest->buf, 0777);
+
+        iter = dir_iterator_begin(src->buf);
+
+        if (!iter)
+                die_errno(_("failed to start iterator over '%s'"), src->buf);
 
 	strbuf_addch(src, '/');
 	src_len = src->len;
 	strbuf_addch(dest, '/');
 	dest_len = dest->len;
 
-	while ((de = readdir(dir)) != NULL) {
+        while ((iter_status = dir_iterator_advance(iter)) == ITER_OK) {
 		strbuf_setlen(src, src_len);
-		strbuf_addstr(src, de->d_name);
+                strbuf_addstr(src, iter->relative_path);
 		strbuf_setlen(dest, dest_len);
-		strbuf_addstr(dest, de->d_name);
-		if (stat(src->buf, &buf)) {
-			warning (_("failed to stat %s\n"), src->buf);
-			continue;
-		}
-		if (S_ISDIR(buf.st_mode)) {
-			if (de->d_name[0] != '.')
-				copy_or_link_directory(src, dest,
-						       src_repo, src_baselen);
+                strbuf_addstr(dest, iter->relative_path);
+
+                if (S_ISLNK(iter->st.st_mode))
+                        die(_("symlink '%s' exists, refusing to clone with --local"),
+                                        iter->relative_path);
+
+                if (S_ISDIR(iter->st.st_mode)) {
+                        mkdir_if_missing(dest->buf, 0777);
 			continue;
 		}
 
 		/* Files that cannot be copied bit-for-bit... */
-		if (!strcmp(src->buf + src_baselen, "/info/alternates")) {
+                if (!strcmp(iter->relative_path, "info/alternates")) {
 			copy_alternates(src, dest, src_repo);
 			continue;
 		}
@@ -441,7 +455,7 @@ static void copy_or_link_directory(struct strbuf *src, struct strbuf *dest,
 		if (unlink(dest->buf) && errno != ENOENT)
 			die_errno(_("failed to unlink '%s'"), dest->buf);
 		if (!option_no_hardlinks) {
-			if (!link(src->buf, dest->buf))
+                        if (!link(real_path(src->buf), dest->buf))
 				continue;
 			if (option_local > 0)
 				die_errno(_("failed to create link '%s'"), dest->buf);
@@ -450,6 +464,11 @@ static void copy_or_link_directory(struct strbuf *src, struct strbuf *dest,
 		if (copy_file_with_time(dest->buf, src->buf, 0666))
 			die_errno(_("failed to copy file to '%s'"), dest->buf);
 	}
+
+        if (iter_status != ITER_DONE) {
+                strbuf_setlen(src, src_len);
+                die(_("failed to iterate over '%s'"), src->buf);
+        }
 	closedir(dir);
 }
 
diff --git a/t/t5604-clone-reference.sh b/t/t5604-clone-reference.sh
index 4320082..ce67be7 100755
--- a/t/t5604-clone-reference.sh
+++ b/t/t5604-clone-reference.sh
@@ -221,4 +221,66 @@ test_expect_success 'clone, dissociate from alternates' '
 	( cd C && git fsck )
 '
 
+test_expect_success SYMLINKS 'setup repo with manually symlinked or unknown files at objects/' '
+       git init T &&
+       (
+               cd T &&
+               git config gc.auto 0 &&
+               test_commit A &&
+               git gc &&
+               test_commit B &&
+
+               cd .git/objects &&
+               mv pack packs &&
+               ln -s packs pack &&
+               find ?? -type d >loose-dirs &&
+               last_loose=$(tail -n 1 loose-dirs) &&
+               mv $last_loose a-loose-dir &&
+               ln -s a-loose-dir $last_loose &&
+               first_loose=$(head -n 1 loose-dirs) &&
+               rm -f loose-dirs &&
+
+               cd $first_loose &&
+               obj=$(ls *) &&
+               mv $obj ../an-object &&
+               ln -s ../an-object $obj &&
+
+               cd ../ &&
+               echo unknown_content >unknown_file
+       ) &&
+       git -C T fsck &&
+       git -C T rev-list --all --objects >T.objects
+'
+test_expect_success SYMLINKS 'clone repo with symlinked or unknown files at objects/' '
+       # None of these options work when cloning locally, since T has
+       # symlinks in its `$GIT_DIR/objects` directory
+       for option in --local --no-hardlinks --dissociate
+       do
+               test_must_fail git clone $option T T$option 2>err || return 1 &&
+               test_i18ngrep "symlink.*exists" err || return 1
+       done &&
+
+       # But `--shared` clones should still work, even when specifying
+       # a local path *and* that repository has symlinks present in its
+       # `$GIT_DIR/objects` directory.
+       git clone --shared T T--shared &&
+       git -C T--shared fsck &&
+       git -C T--shared rev-list --all --objects >T--shared.objects &&
+       test_cmp T.objects T--shared.objects &&
+       (
+               cd T--shared/.git/objects &&
+               find . -type f | sort >../../../T--shared.objects-files.raw &&
+               find . -type l | sort >../../../T--shared.objects-symlinks.raw
+       ) &&
+
+       for raw in $(ls T*.raw)
+       do
+               sed -e "s!/../!/Y/!; s![0-9a-f]\{38,\}!Z!" -e "/commit-graph/d" \
+                   -e "/multi-pack-index/d" <$raw >$raw.de-sha || return 1
+       done &&
+
+       echo ./info/alternates >expected-files &&
+       test_cmp expected-files T--shared.objects-files.raw &&
+       test_must_be_empty T--shared.objects-symlinks.raw
+'
 test_done
-- 
2.18.2

