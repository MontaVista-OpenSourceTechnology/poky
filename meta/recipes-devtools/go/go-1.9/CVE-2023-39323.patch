From 461afc3cdbcef512a54db350a38360c7d08cf01b Mon Sep 17 00:00:00 2001
From: Vivek Kumbhar <vkumbhar@mvista.com>
Date: Wed, 8 Nov 2023 07:57:08 +0000
Subject: [PATCH] CVE-2023-39323

---
 misc/cgo/errors/errors_test.go                | 151 ++++++
 misc/cgo/errors/issue13635.go                 |  24 -
 misc/cgo/errors/ptr_test.go                   | 508 ++++++++++++++++++
 misc/cgo/errors/src/err1.go                   |  18 +
 misc/cgo/errors/src/err2.go                   |  13 +
 misc/cgo/errors/src/err3.go                   |  18 +
 misc/cgo/errors/src/issue11097a.go            |  15 +
 misc/cgo/errors/src/issue11097b.go            |  15 +
 misc/cgo/errors/src/issue13129.go             |  14 +
 misc/cgo/errors/src/issue13423.go             |  12 +
 misc/cgo/errors/src/issue13635.go             |  24 +
 misc/cgo/errors/src/issue13830.go             |  26 +
 misc/cgo/errors/src/issue14669.go             |  23 +
 misc/cgo/errors/src/issue16116.go             |  12 +
 misc/cgo/errors/src/issue18452.go             |  18 +
 misc/cgo/errors/src/issue18889.go             |   7 +
 misc/cgo/errors/src/issue7757.go              |  14 +
 misc/cgo/errors/src/issue8442.go              |  17 +
 misc/cgo/errors/src/long_double_size.go       |  16 +
 misc/cgo/errors/src/malloc.go                 |  34 ++
 .../cgo/internal/testerrors/testdata/err5.go  |  10 +
 src/cmd/compile/internal/gc/noder.go          |   2 +-
 src/cmd/dist/test.go                          |   2 +-
 23 files changed, 967 insertions(+), 26 deletions(-)
 create mode 100644 misc/cgo/errors/errors_test.go
 delete mode 100644 misc/cgo/errors/issue13635.go
 create mode 100644 misc/cgo/errors/ptr_test.go
 create mode 100644 misc/cgo/errors/src/err1.go
 create mode 100644 misc/cgo/errors/src/err2.go
 create mode 100644 misc/cgo/errors/src/err3.go
 create mode 100644 misc/cgo/errors/src/issue11097a.go
 create mode 100644 misc/cgo/errors/src/issue11097b.go
 create mode 100644 misc/cgo/errors/src/issue13129.go
 create mode 100644 misc/cgo/errors/src/issue13423.go
 create mode 100644 misc/cgo/errors/src/issue13635.go
 create mode 100644 misc/cgo/errors/src/issue13830.go
 create mode 100644 misc/cgo/errors/src/issue14669.go
 create mode 100644 misc/cgo/errors/src/issue16116.go
 create mode 100644 misc/cgo/errors/src/issue18452.go
 create mode 100644 misc/cgo/errors/src/issue18889.go
 create mode 100644 misc/cgo/errors/src/issue7757.go
 create mode 100644 misc/cgo/errors/src/issue8442.go
 create mode 100644 misc/cgo/errors/src/long_double_size.go
 create mode 100644 misc/cgo/errors/src/malloc.go
 create mode 100644 src/cmd/cgo/internal/testerrors/testdata/err5.go

diff --git a/misc/cgo/errors/errors_test.go b/misc/cgo/errors/errors_test.go
new file mode 100644
index 0000000..2924993
--- /dev/null
+++ b/misc/cgo/errors/errors_test.go
@@ -0,0 +1,151 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package errorstest
+
+import (
+	"bytes"
+	"fmt"
+	"io/ioutil"
+	"os"
+	"os/exec"
+	"path/filepath"
+	"regexp"
+	"strconv"
+	"strings"
+	"testing"
+)
+
+func path(file string) string {
+	return filepath.Join("src", file)
+}
+
+func check(t *testing.T, file string) {
+	t.Run(file, func(t *testing.T) {
+		t.Parallel()
+
+		contents, err := ioutil.ReadFile(path(file))
+		if err != nil {
+			t.Fatal(err)
+		}
+		var errors []*regexp.Regexp
+		for i, line := range bytes.Split(contents, []byte("\n")) {
+			if !bytes.Contains(line, []byte("ERROR HERE")) {
+				continue
+			}
+			var re *regexp.Regexp
+			frags := bytes.SplitAfterN(line, []byte("ERROR HERE: "), 1)
+			if len(frags) == 1 {
+				re = regexp.MustCompile(regexp.QuoteMeta(fmt.Sprintf("%s:%d:", file, i+1)))
+			} else {
+				re, err = regexp.Compile(string(frags[1]))
+				if err != nil {
+					t.Errorf("Invalid regexp after `ERROR HERE: `: %q", frags[1])
+					continue
+				}
+			}
+			errors = append(errors, re)
+		}
+		if len(errors) == 0 {
+			t.Fatalf("cannot find ERROR HERE")
+		}
+		expect(t, file, errors)
+	})
+}
+
+func expect(t *testing.T, file string, errors []*regexp.Regexp) {
+	cmd := exec.Command("go", "build", "-gcflags=-C", path(file))
+	out, err := cmd.CombinedOutput()
+	if err == nil {
+		t.Errorf("expected cgo to fail but it succeeded")
+	}
+
+	lines := bytes.Split(out, []byte("\n"))
+	for _, re := range errors {
+		found := false
+		for _, line := range lines {
+			if re.Match(line) {
+				found = true
+				break
+			}
+		}
+		if !found {
+			t.Errorf("expected error output to contain %q", re)
+		}
+	}
+
+	if t.Failed() {
+		t.Logf("actual output:\n%s", out)
+	}
+}
+
+func sizeofLongDouble(t *testing.T) int {
+	cmd := exec.Command("go", "run", path("long_double_size.go"))
+	out, err := cmd.CombinedOutput()
+	if err != nil {
+		t.Fatalf("%#q: %v:\n%s", strings.Join(cmd.Args, " "), err, out)
+	}
+
+	i, err := strconv.Atoi(strings.TrimSpace(string(out)))
+	if err != nil {
+		t.Fatalf("long_double_size.go printed invalid size: %s", out)
+	}
+	return i
+}
+
+func TestReportsTypeErrors(t *testing.T) {
+	for _, file := range []string{
+		"err1.go",
+		"err2.go",
+		"err3.go",
+		"issue7757.go",
+		"issue8442.go",
+		"issue11097a.go",
+		"issue11097b.go",
+		"issue13129.go",
+		"issue13423.go",
+		"issue13635.go",
+		"issue13830.go",
+		"issue16116.go",
+		"issue16591.go",
+		"issue18452.go",
+		"issue18889.go",
+	} {
+		check(t, file)
+	}
+
+	if sizeofLongDouble(t) > 8 {
+		check(t, "err4.go")
+	}
+}
+
+func TestToleratesOptimizationFlag(t *testing.T) {
+	for _, cflags := range []string{
+		"",
+		"-O",
+	} {
+		cflags := cflags
+		t.Run(cflags, func(t *testing.T) {
+			t.Parallel()
+
+			cmd := exec.Command("go", "build", path("issue14669.go"))
+			cmd.Env = append(os.Environ(), "CGO_CFLAGS="+cflags)
+			out, err := cmd.CombinedOutput()
+			if err != nil {
+				t.Errorf("%#q: %v:\n%s", strings.Join(cmd.Args, " "), err, out)
+			}
+		})
+	}
+}
+
+func TestMallocCrashesOnNil(t *testing.T) {
+	t.Parallel()
+
+	cmd := exec.Command("go", "run", path("malloc.go"))
+	out, err := cmd.CombinedOutput()
+	if err == nil {
+		t.Logf("%#q:\n%s", strings.Join(cmd.Args, " "), out)
+		t.Fatalf("succeeded unexpectedly")
+	}
+}
diff --git a/misc/cgo/errors/issue13635.go b/misc/cgo/errors/issue13635.go
deleted file mode 100644
index 0ce2b1e..0000000
--- a/misc/cgo/errors/issue13635.go
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// issue 13635: used to output error about C.unsignedchar.
-// This test tests all such types.
-
-package pkg
-
-import "C"
-
-func main() {
-	var (
-		_ C.uchar         = "uc"  // ERROR HERE
-		_ C.schar         = "sc"  // ERROR HERE
-		_ C.ushort        = "us"  // ERROR HERE
-		_ C.uint          = "ui"  // ERROR HERE
-		_ C.ulong         = "ul"  // ERROR HERE
-		_ C.longlong      = "ll"  // ERROR HERE
-		_ C.ulonglong     = "ull" // ERROR HERE
-		_ C.complexfloat  = "cf"  // ERROR HERE
-		_ C.complexdouble = "cd"  // ERROR HERE
-	)
-}
diff --git a/misc/cgo/errors/ptr_test.go b/misc/cgo/errors/ptr_test.go
new file mode 100644
index 0000000..a8f5f4c
--- /dev/null
+++ b/misc/cgo/errors/ptr_test.go
@@ -0,0 +1,508 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Tests that cgo detects invalid pointer passing at runtime.
+
+package errorstest
+
+import (
+	"bufio"
+	"bytes"
+	"fmt"
+	"io/ioutil"
+	"os"
+	"os/exec"
+	"path/filepath"
+	"strings"
+	"testing"
+)
+
+// ptrTest is the tests without the boilerplate.
+type ptrTest struct {
+	name      string   // for reporting
+	c         string   // the cgo comment
+	imports   []string // a list of imports
+	support   string   // supporting functions
+	body      string   // the body of the main function
+	extra     []extra  // extra files
+	fail      bool     // whether the test should fail
+	expensive bool     // whether the test requires the expensive check
+}
+
+type extra struct {
+	name     string
+	contents string
+}
+
+var ptrTests = []ptrTest{
+	{
+		// Passing a pointer to a struct that contains a Go pointer.
+		name: "ptr1",
+		c:    `typedef struct s { int *p; } s; void f(s *ps) {}`,
+		body: `C.f(&C.s{new(C.int)})`,
+		fail: true,
+	},
+	{
+		// Passing a pointer to a struct that contains a Go pointer.
+		name: "ptr2",
+		c:    `typedef struct s { int *p; } s; void f(s *ps) {}`,
+		body: `p := &C.s{new(C.int)}; C.f(p)`,
+		fail: true,
+	},
+	{
+		// Passing a pointer to an int field of a Go struct
+		// that (irrelevantly) contains a Go pointer.
+		name: "ok1",
+		c:    `struct s { int i; int *p; }; void f(int *p) {}`,
+		body: `p := &C.struct_s{i: 0, p: new(C.int)}; C.f(&p.i)`,
+		fail: false,
+	},
+	{
+		// Passing a pointer to a pointer field of a Go struct.
+		name: "ptr-field",
+		c:    `struct s { int i; int *p; }; void f(int **p) {}`,
+		body: `p := &C.struct_s{i: 0, p: new(C.int)}; C.f(&p.p)`,
+		fail: true,
+	},
+	{
+		// Passing a pointer to a pointer field of a Go
+		// struct, where the field does not contain a Go
+		// pointer, but another field (irrelevantly) does.
+		name: "ptr-field-ok",
+		c:    `struct s { int *p1; int *p2; }; void f(int **p) {}`,
+		body: `p := &C.struct_s{p1: nil, p2: new(C.int)}; C.f(&p.p1)`,
+		fail: false,
+	},
+	{
+		// Passing the address of a slice with no Go pointers.
+		name:    "slice-ok-1",
+		c:       `void f(void **p) {}`,
+		imports: []string{"unsafe"},
+		body:    `s := []unsafe.Pointer{nil}; C.f(&s[0])`,
+		fail:    false,
+	},
+	{
+		// Passing the address of a slice with a Go pointer.
+		name:    "slice-ptr-1",
+		c:       `void f(void **p) {}`,
+		imports: []string{"unsafe"},
+		body:    `i := 0; s := []unsafe.Pointer{unsafe.Pointer(&i)}; C.f(&s[0])`,
+		fail:    true,
+	},
+	{
+		// Passing the address of a slice with a Go pointer,
+		// where we are passing the address of an element that
+		// is not a Go pointer.
+		name:    "slice-ptr-2",
+		c:       `void f(void **p) {}`,
+		imports: []string{"unsafe"},
+		body:    `i := 0; s := []unsafe.Pointer{nil, unsafe.Pointer(&i)}; C.f(&s[0])`,
+		fail:    true,
+	},
+	{
+		// Passing the address of a slice that is an element
+		// in a struct only looks at the slice.
+		name:    "slice-ok-2",
+		c:       `void f(void **p) {}`,
+		imports: []string{"unsafe"},
+		support: `type S struct { p *int; s []unsafe.Pointer }`,
+		body:    `i := 0; p := &S{p:&i, s:[]unsafe.Pointer{nil}}; C.f(&p.s[0])`,
+		fail:    false,
+	},
+	{
+		// Passing the address of a slice of an array that is
+		// an element in a struct, with a type conversion.
+		name:    "slice-ok-3",
+		c:       `void f(void* p) {}`,
+		imports: []string{"unsafe"},
+		support: `type S struct { p *int; a [4]byte }`,
+		body:    `i := 0; p := &S{p:&i}; s := p.a[:]; C.f(unsafe.Pointer(&s[0]))`,
+		fail:    false,
+	},
+	{
+		// Passing the address of a slice of an array that is
+		// an element in a struct, with a type conversion.
+		name:    "slice-ok-4",
+		c:       `typedef void* PV; void f(PV p) {}`,
+		imports: []string{"unsafe"},
+		support: `type S struct { p *int; a [4]byte }`,
+		body:    `i := 0; p := &S{p:&i}; C.f(C.PV(unsafe.Pointer(&p.a[0])))`,
+		fail:    false,
+	},
+	{
+		// Passing the address of a static variable with no
+		// pointers doesn't matter.
+		name:    "varok",
+		c:       `void f(char** parg) {}`,
+		support: `var hello = [...]C.char{'h', 'e', 'l', 'l', 'o'}`,
+		body:    `parg := [1]*C.char{&hello[0]}; C.f(&parg[0])`,
+		fail:    false,
+	},
+	{
+		// Passing the address of a static variable with
+		// pointers does matter.
+		name:    "var",
+		c:       `void f(char*** parg) {}`,
+		support: `var hello = [...]*C.char{new(C.char)}`,
+		body:    `parg := [1]**C.char{&hello[0]}; C.f(&parg[0])`,
+		fail:    true,
+	},
+	{
+		// Storing a Go pointer into C memory should fail.
+		name: "barrier",
+		c: `#include <stdlib.h>
+                    char **f1() { return malloc(sizeof(char*)); }
+                    void f2(char **p) {}`,
+		body:      `p := C.f1(); *p = new(C.char); C.f2(p)`,
+		fail:      true,
+		expensive: true,
+	},
+	{
+		// Storing a Go pointer into C memory by assigning a
+		// large value should fail.
+		name: "barrier-struct",
+		c: `#include <stdlib.h>
+                    struct s { char *a[10]; };
+                    struct s *f1() { return malloc(sizeof(struct s)); }
+                    void f2(struct s *p) {}`,
+		body:      `p := C.f1(); p.a = [10]*C.char{new(C.char)}; C.f2(p)`,
+		fail:      true,
+		expensive: true,
+	},
+	{
+		// Storing a Go pointer into C memory using a slice
+		// copy should fail.
+		name: "barrier-slice",
+		c: `#include <stdlib.h>
+                    struct s { char *a[10]; };
+                    struct s *f1() { return malloc(sizeof(struct s)); }
+                    void f2(struct s *p) {}`,
+		body:      `p := C.f1(); copy(p.a[:], []*C.char{new(C.char)}); C.f2(p)`,
+		fail:      true,
+		expensive: true,
+	},
+	{
+		// A very large value uses a GC program, which is a
+		// different code path.
+		name: "barrier-gcprog-array",
+		c: `#include <stdlib.h>
+                    struct s { char *a[32769]; };
+                    struct s *f1() { return malloc(sizeof(struct s)); }
+                    void f2(struct s *p) {}`,
+		body:      `p := C.f1(); p.a = [32769]*C.char{new(C.char)}; C.f2(p)`,
+		fail:      true,
+		expensive: true,
+	},
+	{
+		// Similar case, with a source on the heap.
+		name: "barrier-gcprog-array-heap",
+		c: `#include <stdlib.h>
+                    struct s { char *a[32769]; };
+                    struct s *f1() { return malloc(sizeof(struct s)); }
+                    void f2(struct s *p) {}
+                    void f3(void *p) {}`,
+		imports:   []string{"unsafe"},
+		body:      `p := C.f1(); n := &[32769]*C.char{new(C.char)}; p.a = *n; C.f2(p); n[0] = nil; C.f3(unsafe.Pointer(n))`,
+		fail:      true,
+		expensive: true,
+	},
+	{
+		// A GC program with a struct.
+		name: "barrier-gcprog-struct",
+		c: `#include <stdlib.h>
+                    struct s { char *a[32769]; };
+                    struct s2 { struct s f; };
+                    struct s2 *f1() { return malloc(sizeof(struct s2)); }
+                    void f2(struct s2 *p) {}`,
+		body:      `p := C.f1(); p.f = C.struct_s{[32769]*C.char{new(C.char)}}; C.f2(p)`,
+		fail:      true,
+		expensive: true,
+	},
+	{
+		// Similar case, with a source on the heap.
+		name: "barrier-gcprog-struct-heap",
+		c: `#include <stdlib.h>
+                    struct s { char *a[32769]; };
+                    struct s2 { struct s f; };
+                    struct s2 *f1() { return malloc(sizeof(struct s2)); }
+                    void f2(struct s2 *p) {}
+                    void f3(void *p) {}`,
+		imports:   []string{"unsafe"},
+		body:      `p := C.f1(); n := &C.struct_s{[32769]*C.char{new(C.char)}}; p.f = *n; C.f2(p); n.a[0] = nil; C.f3(unsafe.Pointer(n))`,
+		fail:      true,
+		expensive: true,
+	},
+	{
+		// Exported functions may not return Go pointers.
+		name: "export1",
+		c:    `extern unsigned char *GoFn();`,
+		support: `//export GoFn
+                          func GoFn() *byte { return new(byte) }`,
+		body: `C.GoFn()`,
+		fail: true,
+	},
+	{
+		// Returning a C pointer is fine.
+		name: "exportok",
+		c: `#include <stdlib.h>
+                    extern unsigned char *GoFn();`,
+		support: `//export GoFn
+                          func GoFn() *byte { return (*byte)(C.malloc(1)) }`,
+		body: `C.GoFn()`,
+	},
+	{
+		// Passing a Go string is fine.
+		name: "pass-string",
+		c: `#include <stddef.h>
+                    typedef struct { const char *p; ptrdiff_t n; } gostring;
+                    gostring f(gostring s) { return s; }`,
+		imports: []string{"unsafe"},
+		body:    `s := "a"; r := C.f(*(*C.gostring)(unsafe.Pointer(&s))); if *(*string)(unsafe.Pointer(&r)) != s { panic(r) }`,
+	},
+	{
+		// Passing a slice of Go strings fails.
+		name:    "pass-string-slice",
+		c:       `void f(void *p) {}`,
+		imports: []string{"strings", "unsafe"},
+		support: `type S struct { a [1]string }`,
+		body:    `s := S{a:[1]string{strings.Repeat("a", 2)}}; C.f(unsafe.Pointer(&s.a[0]))`,
+		fail:    true,
+	},
+	{
+		// Exported functions may not return strings.
+		name:    "ret-string",
+		c:       `extern void f();`,
+		imports: []string{"strings"},
+		support: `//export GoStr
+                          func GoStr() string { return strings.Repeat("a", 2) }`,
+		body: `C.f()`,
+		extra: []extra{
+			{
+				"call.c",
+				`#include <stddef.h>
+                                 typedef struct { const char *p; ptrdiff_t n; } gostring;
+                                 extern gostring GoStr();
+                                 void f() { GoStr(); }`,
+			},
+		},
+		fail: true,
+	},
+	{
+		// Don't check non-pointer data.
+		// Uses unsafe code to get a pointer we shouldn't check.
+		// Although we use unsafe, the uintptr represents an integer
+		// that happens to have the same representation as a pointer;
+		// that is, we are testing something that is not unsafe.
+		name: "ptrdata1",
+		c: `#include <stdlib.h>
+                    void f(void* p) {}`,
+		imports: []string{"unsafe"},
+		support: `type S struct { p *int; a [8*8]byte; u uintptr }`,
+		body:    `i := 0; p := &S{u:uintptr(unsafe.Pointer(&i))}; q := (*S)(C.malloc(C.size_t(unsafe.Sizeof(*p)))); *q = *p; C.f(unsafe.Pointer(q))`,
+		fail:    false,
+	},
+	{
+		// Like ptrdata1, but with a type that uses a GC program.
+		name: "ptrdata2",
+		c: `#include <stdlib.h>
+                    void f(void* p) {}`,
+		imports: []string{"unsafe"},
+		support: `type S struct { p *int; a [32769*8]byte; q *int; u uintptr }`,
+		body:    `i := 0; p := S{u:uintptr(unsafe.Pointer(&i))}; q := (*S)(C.malloc(C.size_t(unsafe.Sizeof(p)))); *q = p; C.f(unsafe.Pointer(q))`,
+		fail:    false,
+	},
+	{
+		// Check deferred pointers when they are used, not
+		// when the defer statement is run.
+		name: "defer",
+		c:    `typedef struct s { int *p; } s; void f(s *ps) {}`,
+		body: `p := &C.s{}; defer C.f(p); p.p = new(C.int)`,
+		fail: true,
+	},
+	{
+		// Check a pointer to a union if the union has any
+		// pointer fields.
+		name:    "union1",
+		c:       `typedef union { char **p; unsigned long i; } u; void f(u *pu) {}`,
+		imports: []string{"unsafe"},
+		body:    `var b C.char; p := &b; C.f((*C.u)(unsafe.Pointer(&p)))`,
+		fail:    true,
+	},
+	{
+		// Don't check a pointer to a union if the union does
+		// not have any pointer fields.
+		// Like ptrdata1 above, the uintptr represents an
+		// integer that happens to have the same
+		// representation as a pointer.
+		name:    "union2",
+		c:       `typedef union { unsigned long i; } u; void f(u *pu) {}`,
+		imports: []string{"unsafe"},
+		body:    `var b C.char; p := &b; C.f((*C.u)(unsafe.Pointer(&p)))`,
+		fail:    false,
+	},
+	{
+		// Issue #21306.
+		name:    "preempt-during-call",
+		c:       `void f() {}`,
+		imports: []string{"runtime", "sync"},
+		body:    `var wg sync.WaitGroup; wg.Add(100); for i := 0; i < 100; i++ { go func(i int) { for j := 0; j < 100; j++ { C.f(); runtime.GOMAXPROCS(i) }; wg.Done() }(i) }; wg.Wait()`,
+		fail:    false,
+	},
+}
+
+func TestPointerChecks(t *testing.T) {
+	for _, pt := range ptrTests {
+		pt := pt
+		t.Run(pt.name, func(t *testing.T) {
+			testOne(t, pt)
+		})
+	}
+}
+
+func testOne(t *testing.T, pt ptrTest) {
+	t.Parallel()
+
+	gopath, err := ioutil.TempDir("", filepath.Base(t.Name()))
+	if err != nil {
+		t.Fatal(err)
+	}
+	defer os.RemoveAll(gopath)
+
+	src := filepath.Join(gopath, "src")
+	if err := os.Mkdir(src, 0777); err != nil {
+		t.Fatal(err)
+	}
+
+	name := filepath.Join(src, fmt.Sprintf("%s.go", filepath.Base(t.Name())))
+	f, err := os.Create(name)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	b := bufio.NewWriter(f)
+	fmt.Fprintln(b, `package main`)
+	fmt.Fprintln(b)
+	fmt.Fprintln(b, `/*`)
+	fmt.Fprintln(b, pt.c)
+	fmt.Fprintln(b, `*/`)
+	fmt.Fprintln(b, `import "C"`)
+	fmt.Fprintln(b)
+	for _, imp := range pt.imports {
+		fmt.Fprintln(b, `import "`+imp+`"`)
+	}
+	if len(pt.imports) > 0 {
+		fmt.Fprintln(b)
+	}
+	if len(pt.support) > 0 {
+		fmt.Fprintln(b, pt.support)
+		fmt.Fprintln(b)
+	}
+	fmt.Fprintln(b, `func main() {`)
+	fmt.Fprintln(b, pt.body)
+	fmt.Fprintln(b, `}`)
+
+	if err := b.Flush(); err != nil {
+		t.Fatalf("flushing %s: %v", name, err)
+	}
+	if err := f.Close(); err != nil {
+		t.Fatalf("closing %s: %v", name, err)
+	}
+
+	for _, e := range pt.extra {
+		if err := ioutil.WriteFile(filepath.Join(src, e.name), []byte(e.contents), 0644); err != nil {
+			t.Fatalf("writing %s: %v", e.name, err)
+		}
+	}
+
+	args := func(cmd *exec.Cmd) string {
+		return strings.Join(cmd.Args, " ")
+	}
+
+	cmd := exec.Command("go", "build")
+	cmd.Dir = src
+	cmd.Env = addEnv("GOPATH", gopath)
+	buf, err := cmd.CombinedOutput()
+	if err != nil {
+		t.Logf("%#q:\n%s", args(cmd), buf)
+		t.Fatalf("failed to build: %v", err)
+	}
+
+	exe := filepath.Join(src, filepath.Base(src))
+	cmd = exec.Command(exe)
+	cmd.Dir = src
+
+	if pt.expensive {
+		cmd.Env = cgocheckEnv("1")
+		buf, err := cmd.CombinedOutput()
+		if err != nil {
+			t.Logf("%#q:\n%s", args(cmd), buf)
+			if pt.fail {
+				t.Fatalf("test marked expensive, but failed when not expensive: %v", err)
+			} else {
+				t.Errorf("failed unexpectedly with GODEBUG=cgocheck=1: %v", err)
+			}
+		}
+
+		cmd = exec.Command(exe)
+		cmd.Dir = src
+	}
+
+	if pt.expensive {
+		cmd.Env = cgocheckEnv("2")
+	}
+
+	buf, err = cmd.CombinedOutput()
+	if pt.fail {
+		if err == nil {
+			t.Logf("%#q:\n%s", args(cmd), buf)
+			t.Fatalf("did not fail as expected")
+		} else if !bytes.Contains(buf, []byte("Go pointer")) {
+			t.Logf("%#q:\n%s", args(cmd), buf)
+			t.Fatalf("did not print expected error (failed with %v)", err)
+		}
+	} else {
+		if err != nil {
+			t.Logf("%#q:\n%s", args(cmd), buf)
+			t.Fatalf("failed unexpectedly: %v", err)
+		}
+
+		if !pt.expensive {
+			// Make sure it passes with the expensive checks.
+			cmd := exec.Command(exe)
+			cmd.Dir = src
+			cmd.Env = cgocheckEnv("2")
+			buf, err := cmd.CombinedOutput()
+			if err != nil {
+				t.Logf("%#q:\n%s", args(cmd), buf)
+				t.Fatalf("failed unexpectedly with expensive checks: %v", err)
+			}
+		}
+	}
+
+	if pt.fail {
+		cmd = exec.Command(exe)
+		cmd.Dir = src
+		cmd.Env = cgocheckEnv("0")
+		buf, err := cmd.CombinedOutput()
+		if err != nil {
+			t.Logf("%#q:\n%s", args(cmd), buf)
+			t.Fatalf("failed unexpectedly with GODEBUG=cgocheck=0: %v", err)
+		}
+	}
+}
+
+func cgocheckEnv(val string) []string {
+	return addEnv("GODEBUG", "cgocheck="+val)
+}
+
+func addEnv(key, val string) []string {
+	env := []string{key + "=" + val}
+	look := key + "="
+	for _, e := range os.Environ() {
+		if !strings.HasPrefix(e, look) {
+			env = append(env, e)
+		}
+	}
+	return env
+}
diff --git a/misc/cgo/errors/src/err1.go b/misc/cgo/errors/src/err1.go
new file mode 100644
index 0000000..2c232cf
--- /dev/null
+++ b/misc/cgo/errors/src/err1.go
@@ -0,0 +1,18 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+/*
+#cgo LDFLAGS: -L/nonexist
+
+void test() {
+	xxx;		// ERROR HERE
+}
+*/
+import "C"
+
+func main() {
+	C.test()
+}
diff --git a/misc/cgo/errors/src/err2.go b/misc/cgo/errors/src/err2.go
new file mode 100644
index 0000000..3ab410b
--- /dev/null
+++ b/misc/cgo/errors/src/err2.go
@@ -0,0 +1,13 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+import "C"
+
+func main() {
+	s := ""
+	_ = s
+	C.malloc(s) // ERROR HERE
+}
diff --git a/misc/cgo/errors/src/err3.go b/misc/cgo/errors/src/err3.go
new file mode 100644
index 0000000..609e1a0
--- /dev/null
+++ b/misc/cgo/errors/src/err3.go
@@ -0,0 +1,18 @@
+// Copyright 2014 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+/*
+typedef struct foo foo_t;
+typedef struct bar bar_t;
+
+foo_t *foop;
+*/
+import "C"
+
+func main() {
+	x := (*C.bar_t)(nil)
+	C.foop = x // ERROR HERE
+}
diff --git a/misc/cgo/errors/src/issue11097a.go b/misc/cgo/errors/src/issue11097a.go
new file mode 100644
index 0000000..028d10c
--- /dev/null
+++ b/misc/cgo/errors/src/issue11097a.go
@@ -0,0 +1,15 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+/*
+//enum test { foo, bar };
+*/
+import "C"
+
+func main() {
+	var a = C.enum_test(1) // ERROR HERE
+	_ = a
+}
diff --git a/misc/cgo/errors/src/issue11097b.go b/misc/cgo/errors/src/issue11097b.go
new file mode 100644
index 0000000..b00f24f
--- /dev/null
+++ b/misc/cgo/errors/src/issue11097b.go
@@ -0,0 +1,15 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+/*
+//enum test { foo, bar };
+*/
+import "C"
+
+func main() {
+	p := new(C.enum_test) // ERROR HERE
+	_ = p
+}
diff --git a/misc/cgo/errors/src/issue13129.go b/misc/cgo/errors/src/issue13129.go
new file mode 100644
index 0000000..057bce4
--- /dev/null
+++ b/misc/cgo/errors/src/issue13129.go
@@ -0,0 +1,14 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// issue 13129: used to output error about C.unsignedshort with CC=clang
+
+package main
+
+import "C"
+
+func main() {
+	var x C.ushort
+	x = int(0) // ERROR HERE: C\.ushort
+}
diff --git a/misc/cgo/errors/src/issue13423.go b/misc/cgo/errors/src/issue13423.go
new file mode 100644
index 0000000..fc19157
--- /dev/null
+++ b/misc/cgo/errors/src/issue13423.go
@@ -0,0 +1,12 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+// #include <stdio.h>
+import "C"
+
+func main() {
+	_ = C.fopen() // ERROR HERE
+}
diff --git a/misc/cgo/errors/src/issue13635.go b/misc/cgo/errors/src/issue13635.go
new file mode 100644
index 0000000..3f38f5d
--- /dev/null
+++ b/misc/cgo/errors/src/issue13635.go
@@ -0,0 +1,24 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// issue 13635: used to output error about C.unsignedchar.
+// This test tests all such types.
+
+package pkg
+
+import "C"
+
+func main() {
+	var (
+		_ C.uchar         = "uc"  // ERROR HERE: C\.uchar
+		_ C.schar         = "sc"  // ERROR HERE: C\.schar
+		_ C.ushort        = "us"  // ERROR HERE: C\.ushort
+		_ C.uint          = "ui"  // ERROR HERE: C\.uint
+		_ C.ulong         = "ul"  // ERROR HERE: C\.ulong
+		_ C.longlong      = "ll"  // ERROR HERE: C\.longlong
+		_ C.ulonglong     = "ull" // ERROR HERE: C\.ulonglong
+		_ C.complexfloat  = "cf"  // ERROR HERE: C\.complexfloat
+		_ C.complexdouble = "cd"  // ERROR HERE: C\.complexdouble
+	)
+}
diff --git a/misc/cgo/errors/src/issue13830.go b/misc/cgo/errors/src/issue13830.go
new file mode 100644
index 0000000..ac20c82
--- /dev/null
+++ b/misc/cgo/errors/src/issue13830.go
@@ -0,0 +1,26 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// cgo converts C void* to Go unsafe.Pointer, so despite appearances C
+// void** is Go *unsafe.Pointer. This test verifies that we detect the
+// problem at build time.
+
+package main
+
+// typedef void v;
+// void F(v** p) {}
+import "C"
+
+import "unsafe"
+
+type v [0]byte
+
+func f(p **v) {
+	C.F((**C.v)(unsafe.Pointer(p))) // ERROR HERE
+}
+
+func main() {
+	var p *v
+	f(&p)
+}
diff --git a/misc/cgo/errors/src/issue14669.go b/misc/cgo/errors/src/issue14669.go
new file mode 100644
index 0000000..04d2bcb
--- /dev/null
+++ b/misc/cgo/errors/src/issue14669.go
@@ -0,0 +1,23 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Issue 14669: test that fails when build with CGO_CFLAGS selecting
+// optimization.
+
+package p
+
+/*
+const int E = 1;
+
+typedef struct s {
+	int       c;
+} s;
+*/
+import "C"
+
+func F() {
+	_ = C.s{
+		c: C.E,
+	}
+}
diff --git a/misc/cgo/errors/src/issue16116.go b/misc/cgo/errors/src/issue16116.go
new file mode 100644
index 0000000..1e01cab
--- /dev/null
+++ b/misc/cgo/errors/src/issue16116.go
@@ -0,0 +1,12 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+// void f(void *p, int x) {}
+import "C"
+
+func main() {
+	_ = C.f(1) // ERROR HERE
+}
diff --git a/misc/cgo/errors/src/issue18452.go b/misc/cgo/errors/src/issue18452.go
new file mode 100644
index 0000000..0386d76
--- /dev/null
+++ b/misc/cgo/errors/src/issue18452.go
@@ -0,0 +1,18 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Issue 18452: show pos info in undefined name errors
+
+package p
+
+import (
+	"C"
+	"fmt"
+)
+
+func a() {
+	fmt.Println("Hello, world!")
+	C.function_that_does_not_exist() // ERROR HERE
+	C.pi                             // ERROR HERE
+}
diff --git a/misc/cgo/errors/src/issue18889.go b/misc/cgo/errors/src/issue18889.go
new file mode 100644
index 0000000..bba6b8f
--- /dev/null
+++ b/misc/cgo/errors/src/issue18889.go
@@ -0,0 +1,7 @@
+package main
+
+import "C"
+
+func main() {
+	_ = C.malloc // ERROR HERE
+}
diff --git a/misc/cgo/errors/src/issue7757.go b/misc/cgo/errors/src/issue7757.go
new file mode 100644
index 0000000..0426e9f
--- /dev/null
+++ b/misc/cgo/errors/src/issue7757.go
@@ -0,0 +1,14 @@
+// Copyright 2014 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+/*
+void foo() {}
+*/
+import "C"
+
+func main() {
+	C.foo = C.foo // ERROR HERE
+}
diff --git a/misc/cgo/errors/src/issue8442.go b/misc/cgo/errors/src/issue8442.go
new file mode 100644
index 0000000..60477ad
--- /dev/null
+++ b/misc/cgo/errors/src/issue8442.go
@@ -0,0 +1,17 @@
+// Copyright 2014 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+// Issue 8442.  Cgo output unhelpful error messages for
+// invalid C preambles.
+
+/*
+void issue8442foo(UNDEF*); // ERROR HERE
+*/
+import "C"
+
+func main() {
+	C.issue8442foo(nil)
+}
diff --git a/misc/cgo/errors/src/long_double_size.go b/misc/cgo/errors/src/long_double_size.go
new file mode 100644
index 0000000..8b797f8
--- /dev/null
+++ b/misc/cgo/errors/src/long_double_size.go
@@ -0,0 +1,16 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+/*
+const int sizeofLongDouble = sizeof(long double);
+*/
+import "C"
+
+import "fmt"
+
+func main() {
+	fmt.Println(C.sizeofLongDouble)
+}
diff --git a/misc/cgo/errors/src/malloc.go b/misc/cgo/errors/src/malloc.go
new file mode 100644
index 0000000..65da020
--- /dev/null
+++ b/misc/cgo/errors/src/malloc.go
@@ -0,0 +1,34 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Test that C.malloc does not return nil.
+
+package main
+
+// #include <stdlib.h>
+import "C"
+
+import (
+	"fmt"
+	"runtime"
+)
+
+func main() {
+	var size C.size_t
+	size--
+
+	// The Dragonfly libc succeeds when asked to allocate
+	// 0xffffffffffffffff bytes, so pass a different value that
+	// causes it to fail.
+	if runtime.GOOS == "dragonfly" {
+		size = C.size_t(0x7fffffff << (32 * (^uintptr(0) >> 63)))
+	}
+
+	p := C.malloc(size)
+	if p == nil {
+		fmt.Println("malloc: C.malloc returned nil")
+		// Just exit normally--the test script expects this
+		// program to crash, so exiting normally indicates failure.
+	}
+}
diff --git a/src/cmd/cgo/internal/testerrors/testdata/err5.go b/src/cmd/cgo/internal/testerrors/testdata/err5.go
new file mode 100644
index 0000000..779d745
--- /dev/null
+++ b/src/cmd/cgo/internal/testerrors/testdata/err5.go
@@ -0,0 +1,10 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+//line /tmp/_cgo_.go:1
+//go:cgo_dynamic_linker "/elf/interp" // ERROR HERE: only allowed in cgo-generated code
+
+func main() {}
diff --git a/src/cmd/compile/internal/gc/noder.go b/src/cmd/compile/internal/gc/noder.go
index 7cd9412..130e88d 100644
--- a/src/cmd/compile/internal/gc/noder.go
+++ b/src/cmd/compile/internal/gc/noder.go
@@ -1224,7 +1224,7 @@ func (p *noder) pragma(pos src.Pos, text string) syntax.Pragma {
 // (primarily misuse of linker flags), other files are not.
 // See golang.org/issue/23672.
 func isCgoGeneratedFile(pos src.Pos) bool {
-	return strings.HasPrefix(filepath.Base(filepath.Clean(pos.AbsFilename())), "_cgo_")
+        return strings.HasPrefix(filepath.Base(filepath.Clean(pos.AbsFilename())), "_cgo_")
 }

 func mkname(sym *types.Sym) *Node {
diff --git a/src/cmd/dist/test.go b/src/cmd/dist/test.go
index 73432d3..ff241a8 100644
--- a/src/cmd/dist/test.go
+++ b/src/cmd/dist/test.go
@@ -623,7 +623,7 @@ func (t *tester) registerTests() {
			t.registerTest("testsanitizers", "../misc/cgo/testsanitizers", "./test.bash")
		}
		if t.hasBash() && t.goos != "android" && !t.iOS() && t.gohostos != "windows" {
-			t.registerTest("cgo_errors", "../misc/cgo/errors", "./test.bash")
+			t.registerHostTest("cgo_errors", "../misc/cgo/errors", "misc/cgo/errors", ".")
		}
		if t.gohostos == "linux" && t.extLink() {
			t.registerTest("testsigfwd", "../misc/cgo/testsigfwd", "go", "run", "main.go")
--
2.18.2
