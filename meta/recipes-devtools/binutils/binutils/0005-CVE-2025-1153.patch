From 08029f9bc0cc075fe78edfef5036227a07291b8c Mon Sep 17 00:00:00 2001
From: Alan Modra <amodra@gmail.com>
Date: Thu, 6 Feb 2025 21:46:22 +1030
Subject: [PATCH 05/12] CVE-2025-1153

ld -w currently causes segmentation faults and other misbehaviour
since it changes einfo with %F in the format string (fatal error) to
not exit.  This patch fixes that by introducing a new variant of einfo
called "fatal" that always exits, and replaces all einfo calls using
%F with a call to fatal without the %F.  I considered modifying einfo
to inspect the first 2 or 4 chars in the format string, looking for
%F, but decided that was probably a bad idea given that translators
might have moved the %F.  It's also a little nicer to inform the
compiler of a function that doesn't return.

The patch also fixes some formatting nits, and makes use of %pA
to print section names in a couple of places in aix.em.

Signed-off-by: Siddharth Doshi <sdoshi@mvista.com>
---
 ld/emulparams/call_nop.sh    |  6 +--
 ld/emulparams/cet.sh         |  2 +-
 ld/emulparams/elf32mcore.sh  |  2 +-
 ld/emultempl/aarch64elf.em   |  6 +--
 ld/emultempl/aix.em          | 35 ++++++++-------
 ld/emultempl/armelf.em       | 10 ++---
 ld/emultempl/avrelf.em       |  2 +-
 ld/emultempl/beos.em         | 24 ++++------
 ld/emultempl/cr16elf.em      |  4 +-
 ld/emultempl/cskyelf.em      |  4 +-
 ld/emultempl/elf.em          | 10 ++---
 ld/emultempl/hppaelf.em      |  4 +-
 ld/emultempl/m68hc1xelf.em   |  2 +-
 ld/emultempl/m68kelf.em      |  4 +-
 ld/emultempl/metagelf.em     |  4 +-
 ld/emultempl/mipself.em      |  2 +-
 ld/emultempl/mmix-elfnmmo.em |  5 +--
 ld/emultempl/nds32elf.em     |  6 +--
 ld/emultempl/pe.em           | 18 ++++----
 ld/emultempl/pep.em          | 14 +++---
 ld/emultempl/ppc32elf.em     |  4 +-
 ld/emultempl/ppc64elf.em     |  8 ++--
 ld/emultempl/riscvelf.em     |  2 +-
 ld/emultempl/s390.em         |  2 +-
 ld/emultempl/scoreelf.em     |  2 +-
 ld/emultempl/spuelf.em       | 20 ++++-----
 ld/emultempl/tic6xdsbt.em    | 10 ++---
 ld/emultempl/ticoff.em       |  2 +-
 ld/emultempl/v850elf.em      |  2 +-
 ld/emultempl/vms.em          |  2 +-
 ld/emultempl/xtensaelf.em    | 10 ++---
 ld/ldcref.c                  |  8 ++--
 ld/ldelf.c                   | 28 ++++++------
 ld/ldelfgen.c                |  8 ++--
 ld/ldemul.c                  |  2 +-
 ld/ldexp.c                   | 40 ++++++++---------
 ld/ldfile.c                  | 10 ++---
 ld/ldgram.y                  |  6 +--
 ld/ldlang.c                  | 85 +++++++++++++++++-------------------
 ld/ldlex.l                   | 14 +++---
 ld/ldmain.c                  | 42 +++++++++---------
 ld/ldmisc.c                  | 28 +++++++++---
 ld/ldmisc.h                  |  1 +
 ld/ldwrite.c                 | 18 ++++----
 ld/lexsup.c                  | 57 ++++++++++++------------
 ld/mri.c                     |  2 +-
 ld/pe-dll.c                  | 12 ++---
 ld/plugin.c                  | 27 ++++++------
 48 files changed, 304 insertions(+), 312 deletions(-)

diff --git a/ld/emulparams/call_nop.sh b/ld/emulparams/call_nop.sh
index b1e2e73cbf8..8e12dcfd743 100644
--- a/ld/emulparams/call_nop.sh
+++ b/ld/emulparams/call_nop.sh
@@ -20,7 +20,7 @@ PARSE_AND_LIST_ARGS_CASE_Z_CALL_NOP='
 	      char *end;
 	      params.call_nop_byte = strtoul (optarg + 16 , &end, 0);
 	      if (*end)
-		einfo (_("%F%P: invalid number for -z call-nop=prefix-: %s\n"),
+		fatal (_("%P: invalid number for -z call-nop=prefix-: %s\n"),
 		       optarg + 16);
 	      params.call_nop_as_suffix = FALSE;
 	    }
@@ -29,12 +29,12 @@ PARSE_AND_LIST_ARGS_CASE_Z_CALL_NOP='
 	      char *end;
 	      params.call_nop_byte = strtoul (optarg + 16, &end, 0);
 	      if (*end)
-		einfo (_("%F%P: invalid number for -z call-nop=suffix-: %s\n"),
+		fatal (_("%P: invalid number for -z call-nop=suffix-: %s\n"),
 		       optarg + 16);
 	      params.call_nop_as_suffix = TRUE;
 	    }
 	  else
-	    einfo (_("%F%P: unsupported option: -z %s\n"), optarg);
+	    fatal (_("%P: unsupported option: -z %s\n"), optarg);
 	}
 '
 
diff --git a/ld/emulparams/cet.sh b/ld/emulparams/cet.sh
index f9a83ec099b..8f5092f3453 100644
--- a/ld/emulparams/cet.sh
+++ b/ld/emulparams/cet.sh
@@ -29,7 +29,7 @@ PARSE_AND_LIST_ARGS_CASE_Z_CET='
 				 | cet_report_ibt
 				 | cet_report_shstk);
 	  else
-	    einfo (_("%F%P: invalid option for -z cet-report=: %s\n"),
+	    fatal (_("%P: invalid option for -z cet-report=: %s\n"),
 		   optarg + 11);
 	}
 '
diff --git a/ld/emulparams/elf32mcore.sh b/ld/emulparams/elf32mcore.sh
index 88a8cb6e70b..275a796f84c 100644
--- a/ld/emulparams/elf32mcore.sh
+++ b/ld/emulparams/elf32mcore.sh
@@ -46,6 +46,6 @@ PARSE_AND_LIST_ARGS_CASES='
     case OPTION_BASE_FILE:
       link_info.base_file = fopen (optarg, FOPEN_WB);
       if (link_info.base_file == NULL)
-	einfo (_("%F%P: cannot open base file %s\n"), optarg);
+	fatal (_("%P: cannot open base file %s\n"), optarg);
       break;
 '
diff --git a/ld/emultempl/aarch64elf.em b/ld/emultempl/aarch64elf.em
index d0519b3d7b2..03b7b672b60 100644
--- a/ld/emultempl/aarch64elf.em
+++ b/ld/emultempl/aarch64elf.em
@@ -306,7 +306,7 @@ aarch64_elf_create_output_section_statements (void)
 	 These will only be created if the output format is an arm format,
 	 hence we do not support linking and changing output formats at the
 	 same time.  Use a link followed by objcopy to change output formats.  */
-      einfo (_("%F%P: error: cannot change output format "
+      fatal (_("%P: error: cannot change output format "
 	       "whilst linking %s binaries\n"), "AArch64");
       return;
     }
@@ -332,7 +332,7 @@ aarch64_elf_create_output_section_statements (void)
 			      bfd_get_arch (link_info.output_bfd),
 			      bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -458,7 +458,7 @@ PARSE_AND_LIST_ARGS_CASES='
 
 	group_size = bfd_scan_vma (optarg, &end, 0);
 	if (*end)
-	  einfo (_("%F%P: invalid number `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid number `%s'\''\n"), optarg);
       }
       break;
 '
diff --git a/ld/emultempl/aix.em b/ld/emultempl/aix.em
index c39491eab43..4f6e250587d 100644
--- a/ld/emultempl/aix.em
+++ b/ld/emultempl/aix.em
@@ -322,7 +322,7 @@ read_file_list (const char *filename)
   f = fopen (filename, FOPEN_RT);
   if (f == NULL)
     {
-      einfo (_("%F%P: cannot open %s\n"), filename);
+      fatal (_("%P: cannot open %s\n"), filename);
       return;
     }
   if (fseek (f, 0L, SEEK_END) == -1)
@@ -369,7 +369,7 @@ read_file_list (const char *filename)
   return;
 
  error:
-  einfo (_("%F%P: cannot read %s\n"), optarg);
+  fatal (_("%P: cannot read %s\n"), optarg);
   fclose (f);
 }
 
@@ -721,7 +721,7 @@ gld${EMULATION_NAME}_after_open (void)
       size = (p->count + 2) * 4;
       if (!bfd_xcoff_link_record_set (link_info.output_bfd, &link_info,
 				      p->h, size))
-	einfo (_("%F%P: bfd_xcoff_link_record_set failed: %E\n"));
+	fatal (_("%P: bfd_xcoff_link_record_set failed: %E\n"));
     }
 }
 
@@ -751,9 +751,9 @@ gld${EMULATION_NAME}_before_allocation (void)
 
       h = bfd_link_hash_lookup (link_info.hash, el->name, FALSE, FALSE, FALSE);
       if (h == NULL)
-	einfo (_("%F%P: bfd_link_hash_lookup of export symbol failed: %E\n"));
+	fatal (_("%P: bfd_link_hash_lookup of export symbol failed: %E\n"));
       if (!bfd_xcoff_export_symbol (link_info.output_bfd, &link_info, h))
-	einfo (_("%F%P: bfd_xcoff_export_symbol failed: %E\n"));
+	fatal (_("%P: bfd_xcoff_export_symbol failed: %E\n"));
     }
 
   /* Track down all relocations called for by the linker script (these
@@ -837,7 +837,7 @@ gld${EMULATION_NAME}_before_allocation (void)
        maxstack, maxdata, gc && !unix_ld ? TRUE : FALSE,
        modtype, textro ? TRUE : FALSE, flags, special_sections,
        rtld ? TRUE : FALSE))
-    einfo (_("%F%P: failed to set dynamic section sizes: %E\n"));
+    fatal (_("%P: failed to set dynamic section sizes: %E\n"));
 
   /* Look through the special sections, and put them in the right
      place in the link ordering.  This is especially magic.  */
@@ -859,8 +859,8 @@ gld${EMULATION_NAME}_before_allocation (void)
       is = NULL;
       os = lang_output_section_get (sec->output_section);
       if (os == NULL)
-	einfo (_("%F%P: can't find output section %s\n"),
-	       sec->output_section->name);
+	fatal (_("%P: can't find output section %pA\n"),
+	       sec->output_section);
 
       for (pls = &os->children.head; *pls != NULL; pls = &(*pls)->header.next)
 	{
@@ -896,8 +896,7 @@ gld${EMULATION_NAME}_before_allocation (void)
 
       if (is == NULL)
 	{
-	  einfo (_("%F%P: can't find %s in output section\n"),
-		 bfd_section_name (sec));
+	  fatal (_("%P: can't find %pA in output section\n"), sec);
 	}
 
       /* Now figure out where the section should go.  */
@@ -1110,7 +1109,7 @@ gld${EMULATION_NAME}_read_file (const char *filename, bfd_boolean import)
   if (f == NULL)
     {
       bfd_set_error (bfd_error_system_call);
-      einfo ("%F%P: %s: %E\n", filename);
+      fatal ("%P: %s: %E\n", filename);
       return;
     }
 
@@ -1172,7 +1171,7 @@ gld${EMULATION_NAME}_read_file (const char *filename, bfd_boolean import)
 	      obstack_free (o, obstack_base (o));
 	    }
 	  else if (*s == '(')
-	    einfo (_("%F%P:%s:%d: #! ([member]) is not supported "
+	    fatal (_("%P:%s:%d: #! ([member]) is not supported "
 		     "in import files\n"),
 		   filename, lineno);
 	  else
@@ -1189,7 +1188,7 @@ gld${EMULATION_NAME}_read_file (const char *filename, bfd_boolean import)
 	      *s = '\0';
 	      if (!bfd_xcoff_split_import_path (link_info.output_bfd,
 						start, &imppath, &impfile))
-		einfo (_("%F%P: could not parse import path: %E\n"));
+		fatal (_("%P: could not parse import path: %E\n"));
 	      while (ISSPACE (cs))
 		{
 		  ++s;
@@ -1344,10 +1343,10 @@ gld${EMULATION_NAME}_find_relocs (lang_statement_union_type *s)
 
       rs = &s->reloc_statement;
       if (rs->name == NULL)
-	einfo (_("%F%P: only relocations against symbols are permitted\n"));
+	fatal (_("%P: only relocations against symbols are permitted\n"));
       if (!bfd_xcoff_link_count_reloc (link_info.output_bfd, &link_info,
 				       rs->name))
-	einfo (_("%F%P: bfd_xcoff_link_count_reloc failed: %E\n"));
+	fatal (_("%P: bfd_xcoff_link_count_reloc failed: %E\n"));
     }
 
   if (s->header.type == lang_assignment_statement_enum)
@@ -1375,7 +1374,7 @@ gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)
 	  if (!bfd_xcoff_record_link_assignment (link_info.output_bfd,
 						 &link_info,
 						 exp->assign.dst))
-	    einfo (_("%F%P: failed to record assignment to %s: %E\n"),
+	    fatal (_("%P: failed to record assignment to %s: %E\n"),
 		   exp->assign.dst);
 	}
       gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
@@ -1473,7 +1472,7 @@ gld${EMULATION_NAME}_create_output_section_statements (void)
 				  bfd_get_arch (link_info.output_bfd),
 				  bfd_get_mach (link_info.output_bfd)))
 	{
-	  einfo (_("%F%P: can not create BFD: %E\n"));
+	  fatal (_("%P: can not create BFD: %E\n"));
 	  return;
 	}
 
@@ -1483,7 +1482,7 @@ gld${EMULATION_NAME}_create_output_section_statements (void)
 					    link_info.fini_function,
 					    rtld))
 	{
-	  einfo (_("%F%P: can not create BFD: %E\n"));
+	  fatal (_("%P: can not create BFD: %E\n"));
 	  return;
 	}
 
diff --git a/ld/emultempl/armelf.em b/ld/emultempl/armelf.em
index efdcf5a2aa7..01aa94dfe62 100644
--- a/ld/emultempl/armelf.em
+++ b/ld/emultempl/armelf.em
@@ -513,7 +513,7 @@ arm_elf_create_output_section_statements (void)
 	 These will only be created if the output format is an arm format,
 	 hence we do not support linking and changing output formats at the
 	 same time.  Use a link followed by objcopy to change output formats.  */
-      einfo (_("%F%P: error: cannot change output format "
+      fatal (_("%P: error: cannot change output format "
 	       "whilst linking %s binaries\n"), "ARM");
       return;
     }
@@ -524,10 +524,10 @@ arm_elf_create_output_section_statements (void)
 					bfd_get_target (link_info.output_bfd));
 
       if (params.in_implib_bfd == NULL)
-	einfo (_("%F%P: %s: can't open: %E\n"), in_implib_filename);
+	fatal (_("%P: %s: can't open: %E\n"), in_implib_filename);
 
       if (!bfd_check_format (params.in_implib_bfd, bfd_object))
-	einfo (_("%F%P: %s: not a relocatable file: %E\n"), in_implib_filename);
+	fatal (_("%P: %s: not a relocatable file: %E\n"), in_implib_filename);
     }
 
   bfd_elf32_arm_set_target_params (link_info.output_bfd, &link_info, &params);
@@ -541,7 +541,7 @@ arm_elf_create_output_section_statements (void)
 			      bfd_get_arch (link_info.output_bfd),
 			      bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -726,7 +726,7 @@ PARSE_AND_LIST_ARGS_CASES='
 
 	group_size = bfd_scan_vma (optarg, &end, 0);
 	if (*end)
-	  einfo (_("%F%P: invalid number `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid number `%s'\''\n"), optarg);
       }
       break;
 
diff --git a/ld/emultempl/avrelf.em b/ld/emultempl/avrelf.em
index 6ff8204bebb..37eb313b50f 100644
--- a/ld/emultempl/avrelf.em
+++ b/ld/emultempl/avrelf.em
@@ -116,7 +116,7 @@ avr_elf_create_output_section_statements (void)
 
   if (bfd_get_flavour (link_info.output_bfd) != bfd_target_elf_flavour)
     {
-      einfo (_("%F%P: error: cannot change output format "
+      fatal (_("%P: error: cannot change output format "
 	       "whilst linking %s binaries\n"), "AVR");
       return;
     }
diff --git a/ld/emultempl/beos.em b/ld/emultempl/beos.em
index 97cde99c335..a7614f9fad9 100644
--- a/ld/emultempl/beos.em
+++ b/ld/emultempl/beos.em
@@ -227,7 +227,7 @@ set_pe_subsystem (void)
 	  return;
 	}
     }
-  einfo (_("%F%P: invalid subsystem type %s\n"), optarg);
+  fatal (_("%P: invalid subsystem type %s\n"), optarg);
 }
 
 
@@ -237,9 +237,7 @@ set_pe_value (char *name)
   char *end;
   set_pe_name (name,  strtoul (optarg, &end, 0));
   if (end == optarg)
-    {
-      einfo (_("%F%P: invalid hex number for PE parameter '%s'\n"), optarg);
-    }
+    fatal (_("%P: invalid hex number for PE parameter '%s'\n"), optarg);
 
   optarg = end;
 }
@@ -254,9 +252,7 @@ set_pe_stack_heap (char *resname, char *comname)
       set_pe_value (comname);
     }
   else if (*optarg)
-    {
-      einfo (_("%F%P: strange hex info for PE parameter '%s'\n"), optarg);
-    }
+    fatal (_("%P: strange hex info for PE parameter '%s'\n"), optarg);
 }
 
 
@@ -271,7 +267,7 @@ gld${EMULATION_NAME}_handle_option (int optc)
     case OPTION_BASE_FILE:
       link_info.base_file = fopen (optarg, FOPEN_WB);
       if (link_info.base_file == NULL)
-	einfo (_("%F%P: cannot open base file %s\n"), optarg);
+	fatal (_("%P: cannot open base file %s\n"), optarg);
       break;
 
       /* PE options */
@@ -380,9 +376,7 @@ gld_${EMULATION_NAME}_after_open (void)
      FIXME: This should be done via a function, rather than by
      including an internal BFD header.  */
   if (!coff_data(link_info.output_bfd)->pe)
-    {
-      einfo (_("%F%P: PE operations on non PE file\n"));
-    }
+    fatal (_("%P: PE operations on non PE file\n"));
 
   pe_data(link_info.output_bfd)->pe_opthdr = pe;
   pe_data(link_info.output_bfd)->dll = init[DLLOFF].value;
@@ -430,12 +424,12 @@ sort_by_file_name (const void *a, const void *b)
 
       if (!bfd_get_section_contents (sa->owner, sa, &a_sec, (file_ptr) 0,
 				     (bfd_size_type) sizeof (a_sec)))
-	einfo (_("%F%P: %pB: can't read contents of section .idata: %E\n"),
+	fatal (_("%P: %pB: can't read contents of section .idata: %E\n"),
 	       sa->owner);
 
       if (!bfd_get_section_contents (sb->owner, sb, &b_sec, (file_ptr) 0,
 				     (bfd_size_type) sizeof (b_sec)))
-	einfo (_("%F%P: %pB: can't read contents of section .idata: %E\n"),
+	fatal (_("%P: %pB: can't read contents of section .idata: %E\n"),
 	       sb->owner);
 
       i = a_sec < b_sec ? -1 : 0;
@@ -684,7 +678,7 @@ gld${EMULATION_NAME}_place_orphan (asection *s,
   /* Everything from the '\$' on gets deleted so don't allow '\$' as the
      first character.  */
   if (*secname == '\$')
-    einfo (_("%F%P: section %s has '\$' as first character\n"), secname);
+    fatal (_("%P: section %s has '\$' as first character\n"), secname);
   if (strchr (secname + 1, '\$') == NULL)
     return NULL;
 
@@ -716,7 +710,7 @@ gld${EMULATION_NAME}_place_orphan (asection *s,
       }
   ps[0] = 0;
   if (l == NULL)
-    einfo (_("%F%P: *(%s\$) missing from linker script\n"), output_secname);
+    fatal (_("%P: *(%s\$) missing from linker script\n"), output_secname);
 
   /* Link the input section in and we're done for now.
      The sections still have to be sorted, but that has to wait until
diff --git a/ld/emultempl/cr16elf.em b/ld/emultempl/cr16elf.em
index 5bbc170364c..954354fb607 100644
--- a/ld/emultempl/cr16elf.em
+++ b/ld/emultempl/cr16elf.em
@@ -58,7 +58,7 @@ cr16_elf_after_open (void)
 	     COFF and ELF.  */
 	  if (bfd_get_flavour (abfd) != bfd_target_coff_flavour
 	      && bfd_get_flavour (abfd) != bfd_target_elf_flavour)
-	    einfo (_("%F%P: %pB: all input objects must be COFF or ELF "
+	    fatal (_("%P: %pB: all input objects must be COFF or ELF "
 		     "for --embedded-relocs\n"));
 
 	  datasec = bfd_get_section_by_name (abfd, ".data.rel");
@@ -82,7 +82,7 @@ cr16_elf_after_open (void)
 						      | SEC_IN_MEMORY))
 		  || !bfd_set_section_alignment (relsec, 2)
 		  || !bfd_set_section_size (relsec, datasec->reloc_count * 8))
-		einfo (_("%F%P: %pB: can not create .emreloc section: %E\n"));
+		fatal (_("%P: %pB: can not create .emreloc section: %E\n"));
 	    }
 
 	  /* Double check that all other data sections are empty, as is
diff --git a/ld/emultempl/cskyelf.em b/ld/emultempl/cskyelf.em
index aa2c2a6c1ea..0e40310093d 100644
--- a/ld/emultempl/cskyelf.em
+++ b/ld/emultempl/cskyelf.em
@@ -151,7 +151,7 @@ csky_elf_create_output_section_statements (void)
 	  bfd_get_arch (link_info.output_bfd),
 	  bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -322,7 +322,7 @@ PARSE_AND_LIST_ARGS_CASES='
 
       group_size = bfd_scan_vma (optarg, &end, 0);
       if (*end)
-	einfo (_("%F%P: invalid number `%s'\''\n"), optarg);
+	fatal (_("%P: invalid number `%s'\''\n"), optarg);
     }
     break;
 '
diff --git a/ld/emultempl/elf.em b/ld/emultempl/elf.em
index 42c552b36ed..3ff2134f56d 100644
--- a/ld/emultempl/elf.em
+++ b/ld/emultempl/elf.em
@@ -641,7 +641,7 @@ gld${EMULATION_NAME}_handle_option (int optc)
       else if (strcasecmp (optarg, "zlib-gabi") == 0)
 	link_info.compress_debug = COMPRESS_DEBUG_GABI_ZLIB;
       else
-	einfo (_("%F%P: invalid --compress-debug-sections option: \`%s'\n"),
+	fatal (_("%P: invalid --compress-debug-sections option: \`%s'\n"),
 	       optarg);
       break;
 EOF
@@ -696,7 +696,7 @@ fragment <<EOF
 	  link_info.emit_gnu_hash = TRUE;
 	}
       else
-	einfo (_("%F%P: invalid hash style \`%s'\n"), optarg);
+	fatal (_("%P: invalid hash style \`%s'\n"), optarg);
       break;
 
 EOF
@@ -715,7 +715,7 @@ fragment <<EOF
 
 	  config.maxpagesize = strtoul (optarg + 14, &end, 0);
 	  if (*end || (config.maxpagesize & (config.maxpagesize - 1)) != 0)
-	    einfo (_("%F%P: invalid maximum page size \`%s'\n"),
+	    fatal (_("%P: invalid maximum page size \`%s'\n"),
 		   optarg + 14);
 	}
       else if (CONST_STRNEQ (optarg, "common-page-size="))
@@ -724,7 +724,7 @@ fragment <<EOF
 	  config.commonpagesize = strtoul (optarg + 17, &end, 0);
 	  if (*end
 	      || (config.commonpagesize & (config.commonpagesize - 1)) != 0)
-	    einfo (_("%F%P: invalid common page size \`%s'\n"),
+	    fatal (_("%P: invalid common page size \`%s'\n"),
 		   optarg + 17);
 	}
       else if (CONST_STRNEQ (optarg, "stack-size="))
@@ -732,7 +732,7 @@ fragment <<EOF
 	  char *end;
 	  link_info.stacksize = strtoul (optarg + 11, &end, 0);
 	  if (*end || link_info.stacksize < 0)
-	    einfo (_("%F%P: invalid stack size \`%s'\n"), optarg + 11);
+	    fatal (_("%P: invalid stack size \`%s'\n"), optarg + 11);
 	  if (!link_info.stacksize)
 	    /* Use -1 for explicit no-stack, because zero means
 	       'default'.   */
diff --git a/ld/emultempl/hppaelf.em b/ld/emultempl/hppaelf.em
index 7c47e9918f2..3d7296bdb25 100644
--- a/ld/emultempl/hppaelf.em
+++ b/ld/emultempl/hppaelf.em
@@ -82,7 +82,7 @@ hppaelf_create_output_section_statements (void)
 			      bfd_get_arch (link_info.output_bfd),
 			      bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -351,7 +351,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	const char *end;
 	group_size = bfd_scan_vma (optarg, &end, 0);
 	if (*end)
-	  einfo (_("%F%P: invalid number `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid number `%s'\''\n"), optarg);
       }
       break;
 '
diff --git a/ld/emultempl/m68hc1xelf.em b/ld/emultempl/m68hc1xelf.em
index 5fba1d16a22..8afac5b6489 100644
--- a/ld/emultempl/m68hc1xelf.em
+++ b/ld/emultempl/m68hc1xelf.em
@@ -159,7 +159,7 @@ m68hc11elf_create_output_section_statements (void)
 			     bfd_get_arch (link_info.output_bfd),
 			     bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
diff --git a/ld/emultempl/m68kelf.em b/ld/emultempl/m68kelf.em
index e909f755da7..6c1f86f8dc0 100644
--- a/ld/emultempl/m68kelf.em
+++ b/ld/emultempl/m68kelf.em
@@ -82,7 +82,7 @@ m68k_elf_after_open (void)
 	  asection *datasec;
 
 	  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
-	    einfo (_("%F%P: %pB: all input objects must be ELF "
+	    fatal (_("%P: %pB: all input objects must be ELF "
 		     "for --embedded-relocs\n"));
 
 	  datasec = bfd_get_section_by_name (abfd, ".data");
@@ -106,7 +106,7 @@ m68k_elf_after_open (void)
 	      if (relsec == NULL
 		  || !bfd_set_section_alignment (relsec, 2)
 		  || !bfd_set_section_size (relsec, datasec->reloc_count * 12))
-		einfo (_("%F%P: %pB: can not create .emreloc section: %E\n"));
+		fatal (_("%P: %pB: can not create .emreloc section: %E\n"));
 	    }
 
 	  /* Double check that all other data sections are empty, as is
diff --git a/ld/emultempl/metagelf.em b/ld/emultempl/metagelf.em
index 0921882939a..f3ec8633671 100644
--- a/ld/emultempl/metagelf.em
+++ b/ld/emultempl/metagelf.em
@@ -59,7 +59,7 @@ metagelf_create_output_section_statements (void)
 			      bfd_get_arch (link_info.output_bfd),
 			      bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -309,7 +309,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	const char *end;
 	group_size = bfd_scan_vma (optarg, &end, 0);
 	if (*end)
-	  einfo (_("%F%P: invalid number `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid number `%s'\''\n"), optarg);
       }
       break;
 '
diff --git a/ld/emultempl/mipself.em b/ld/emultempl/mipself.em
index 48e998afa93..aa6f700aaf9 100644
--- a/ld/emultempl/mipself.em
+++ b/ld/emultempl/mipself.em
@@ -152,7 +152,7 @@ mips_add_stub_section (const char *stub_sec_name, asection *input_section,
 				 bfd_get_arch (link_info.output_bfd),
 				 bfd_get_mach (link_info.output_bfd)))
 	{
-	  einfo (_("%F%P: can not create BFD: %E\n"));
+	  fatal (_("%P: can not create BFD: %E\n"));
 	  return NULL;
 	}
       stub_bfd->flags |= BFD_LINKER_CREATED;
diff --git a/ld/emultempl/mmix-elfnmmo.em b/ld/emultempl/mmix-elfnmmo.em
index c05e4f1847c..e7a0ca0a39b 100644
--- a/ld/emultempl/mmix-elfnmmo.em
+++ b/ld/emultempl/mmix-elfnmmo.em
@@ -113,10 +113,7 @@ mmix_after_allocation (void)
     bfd_set_section_vma (sec, 0);
 
   if (!_bfd_mmix_after_linker_allocation (link_info.output_bfd, &link_info))
-    {
-      /* This is a fatal error; make einfo call not return.  */
-      einfo (_("%F%P: can't finalize linker-allocated global registers\n"));
-    }
+    fatal (_("%P: can't finalize linker-allocated global registers\n"));
 }
 EOF
 
diff --git a/ld/emultempl/nds32elf.em b/ld/emultempl/nds32elf.em
index 48f64335db2..884c95a8841 100644
--- a/ld/emultempl/nds32elf.em
+++ b/ld/emultempl/nds32elf.em
@@ -44,7 +44,7 @@ nds32_elf_create_output_section_statements (void)
   if (strstr (bfd_get_target (link_info.output_bfd), "nds32") == NULL)
     {
       /* Check the output target is nds32.  */
-      einfo (_("%F%P: error: cannot change output format whilst "
+      fatal (_("%P: error: cannot change output format whilst "
 	       "linking %s binaries\n"), "NDS32");
       return;
     }
@@ -96,7 +96,7 @@ nds32_elf_after_open (void)
 	       && abi_ver != (elf_elfheader (abfd)->e_flags & EF_NDS_ABI))
 	{
 	  /* Incompatible objects.  */
-	  einfo (_("%F%P: %pB: ABI version of object files mismatched\n"),
+	  fatal (_("%P: %pB: ABI version of object files mismatched\n"),
 		 abfd);
 	}
     }
@@ -195,7 +195,7 @@ PARSE_AND_LIST_ARGS_CASES='
       {
 	sym_ld_script = fopen (optarg, FOPEN_WT);
 	if(sym_ld_script == NULL)
-	  einfo (_("%F%P: cannot open map file %s: %E\n"), optarg);
+	  fatal (_("%P: cannot open map file %s: %E\n"), optarg);
       }
     break;
   case OPTION_HYPER_RELAX:
diff --git a/ld/emultempl/pe.em b/ld/emultempl/pe.em
index 26fa7465c09..3730279fed1 100644
--- a/ld/emultempl/pe.em
+++ b/ld/emultempl/pe.em
@@ -647,7 +647,7 @@ set_pe_subsystem (void)
 
       if (v[i].name == NULL)
 	{
-	  einfo (_("%F%P: invalid subsystem type %s\n"), optarg);
+	  fatal (_("%P: invalid subsystem type %s\n"), optarg);
 	  return;
 	}
 
@@ -668,7 +668,7 @@ set_pe_value (char *name)
   set_pe_name (name,  strtoul (optarg, &end, 0));
 
   if (end == optarg)
-    einfo (_("%F%P: invalid hex number for PE parameter '%s'\n"), optarg);
+    fatal (_("%P: invalid hex number for PE parameter '%s'\n"), optarg);
 
   optarg = end;
 }
@@ -685,7 +685,7 @@ set_pe_stack_heap (char *resname, char *comname)
       set_pe_value (comname);
     }
   else if (*optarg)
-    einfo (_("%F%P: strange hex info for PE parameter '%s'\n"), optarg);
+    fatal (_("%P: strange hex info for PE parameter '%s'\n"), optarg);
 }
 
 #define DEFAULT_BUILD_ID_STYLE	"md5"
@@ -701,7 +701,7 @@ gld${EMULATION_NAME}_handle_option (int optc)
     case OPTION_BASE_FILE:
       link_info.base_file = fopen (optarg, FOPEN_WB);
       if (link_info.base_file == NULL)
-	einfo (_("%F%P: cannot open base file %s\n"), optarg);
+	fatal (_("%P: cannot open base file %s\n"), optarg);
       break;
 
       /* PE options.  */
@@ -1369,7 +1369,7 @@ gld_${EMULATION_NAME}_after_open (void)
   if (bfd_get_flavour (link_info.output_bfd) != bfd_target_coff_flavour
       || coff_data (link_info.output_bfd) == NULL
       || coff_data (link_info.output_bfd)->pe == 0)
-    einfo (_("%F%P: cannot perform PE operations on non PE output file '%pB'\n"),
+    fatal (_("%P: cannot perform PE operations on non PE output file '%pB'\n"),
 	   link_info.output_bfd);
 
   pe_data (link_info.output_bfd)->pe_opthdr = pe;
@@ -1439,7 +1439,7 @@ gld_${EMULATION_NAME}_after_open (void)
 	 These will only be created if the output format is an arm format,
 	 hence we do not support linking and changing output formats at the
 	 same time.  Use a link followed by objcopy to change output formats.  */
-      einfo (_("%F%P: error: cannot change output format "
+      fatal (_("%P: error: cannot change output format "
 	       "whilst linking %s binaries\n"), "ARM");
       return;
     }
@@ -1499,7 +1499,7 @@ gld_${EMULATION_NAME}_after_open (void)
 
 		    if (!bfd_generic_link_read_symbols (is->the_bfd))
 		      {
-			einfo (_("%F%P: %pB: could not read symbols: %E\n"),
+			fatal (_("%P: %pB: could not read symbols: %E\n"),
 			       is->the_bfd);
 			return;
 		      }
@@ -1719,7 +1719,7 @@ gld_${EMULATION_NAME}_after_open (void)
 
 		if (!bfd_generic_link_read_symbols (is->the_bfd))
 		  {
-		    einfo (_("%F%P: %pB: could not read symbols: %E\n"),
+		    fatal (_("%P: %pB: could not read symbols: %E\n"),
 			   is->the_bfd);
 		    return;
 		  }
@@ -1847,7 +1847,7 @@ gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIB
 
 	      h = bfd_link_hash_lookup (link_info.hash, buf, TRUE, TRUE, TRUE);
 	      if (h == (struct bfd_link_hash_entry *) NULL)
-		einfo (_("%F%P: bfd_link_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_link_hash_lookup failed: %E\n"));
 	      if (h->type == bfd_link_hash_new)
 		{
 		  h->type = bfd_link_hash_undefined;
diff --git a/ld/emultempl/pep.em b/ld/emultempl/pep.em
index ef23221c03b..c07e18784e9 100644
--- a/ld/emultempl/pep.em
+++ b/ld/emultempl/pep.em
@@ -609,7 +609,7 @@ set_pep_subsystem (void)
 
       if (v[i].name == NULL)
 	{
-	  einfo (_("%F%P: invalid subsystem type %s\n"), optarg);
+	  fatal (_("%P: invalid subsystem type %s\n"), optarg);
 	  return;
 	}
 
@@ -630,7 +630,7 @@ set_pep_value (char *name)
   set_pep_name (name,  (bfd_vma) strtoull (optarg, &end, 0));
 
   if (end == optarg)
-    einfo (_("%F%P: invalid hex number for PE parameter '%s'\n"), optarg);
+    fatal (_("%P: invalid hex number for PE parameter '%s'\n"), optarg);
 
   optarg = end;
 }
@@ -647,7 +647,7 @@ set_pep_stack_heap (char *resname, char *comname)
       set_pep_value (comname);
     }
   else if (*optarg)
-    einfo (_("%F%P: strange hex info for PE parameter '%s'\n"), optarg);
+    fatal (_("%P: strange hex info for PE parameter '%s'\n"), optarg);
 }
 
 #define DEFAULT_BUILD_ID_STYLE	"md5"
@@ -664,7 +664,7 @@ gld${EMULATION_NAME}_handle_option (int optc)
     case OPTION_BASE_FILE:
       link_info.base_file = fopen (optarg, FOPEN_WB);
       if (link_info.base_file == NULL)
-	einfo (_("%F%P: cannot open base file %s\n"), optarg);
+	fatal (_("%P: cannot open base file %s\n"), optarg);
       break;
 
       /* PE options.  */
@@ -1358,7 +1358,7 @@ gld_${EMULATION_NAME}_after_open (void)
   if (bfd_get_flavour (link_info.output_bfd) != bfd_target_coff_flavour
       || coff_data (link_info.output_bfd) == NULL
       || coff_data (link_info.output_bfd)->pe == 0)
-    einfo (_("%F%P: cannot perform PE operations on non PE output file '%pB'\n"),
+    fatal (_("%P: cannot perform PE operations on non PE output file '%pB'\n"),
 	   link_info.output_bfd);
 
   pe_data (link_info.output_bfd)->pe_opthdr = pep;
@@ -1467,7 +1467,7 @@ gld_${EMULATION_NAME}_after_open (void)
 
 		    if (!bfd_generic_link_read_symbols (is->the_bfd))
 		      {
-			einfo (_("%F%P: %pB: could not read symbols: %E\n"),
+			fatal (_("%P: %pB: could not read symbols: %E\n"),
 			       is->the_bfd);
 			return;
 		      }
@@ -1704,7 +1704,7 @@ gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIB
 
 	      h = bfd_link_hash_lookup (link_info.hash, buf, TRUE, TRUE, TRUE);
 	      if (h == (struct bfd_link_hash_entry *) NULL)
-		einfo (_("%F%P: bfd_link_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_link_hash_lookup failed: %E\n"));
 	      if (h->type == bfd_link_hash_new)
 		{
 		  h->type = bfd_link_hash_undefined;
diff --git a/ld/emultempl/ppc32elf.em b/ld/emultempl/ppc32elf.em
index 0402ffbb99f..a900034a483 100644
--- a/ld/emultempl/ppc32elf.em
+++ b/ld/emultempl/ppc32elf.em
@@ -386,7 +386,7 @@ PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'
 	  char *end;
 	  unsigned long val = strtoul (optarg, &end, 0);
 	  if (*end || val > 5)
-	    einfo (_("%F%P: invalid --plt-align `%s'\''\n"), optarg);
+	    fatal (_("%P: invalid --plt-align `%s'\''\n"), optarg);
 	  params.plt_stub_align = val;
 	}
       else
@@ -419,7 +419,7 @@ PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'
 	  if (*end
 	      || (params.pagesize < 4096 && params.pagesize != 0)
 	      || params.pagesize != (params.pagesize & -params.pagesize))
-	    einfo (_("%F%P: invalid pagesize `%s'\''\n"), optarg);
+	    fatal (_("%P: invalid pagesize `%s'\''\n"), optarg);
 	}
       break;
 
diff --git a/ld/emultempl/ppc64elf.em b/ld/emultempl/ppc64elf.em
index caa4f820837..77929a7581c 100644
--- a/ld/emultempl/ppc64elf.em
+++ b/ld/emultempl/ppc64elf.em
@@ -89,7 +89,7 @@ ppc_create_output_section_statements (void)
 			     bfd_get_arch (link_info.output_bfd),
 			     bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -99,7 +99,7 @@ ppc_create_output_section_statements (void)
   if (params.save_restore_funcs < 0)
     params.save_restore_funcs = !bfd_link_relocatable (&link_info);
   if (!ppc64_elf_init_stub_bfd (&link_info, &params))
-    einfo (_("%F%P: can not init BFD: %E\n"));
+    fatal (_("%P: can not init BFD: %E\n"));
 }
 
 /* Called after opening files but before mapping sections.  */
@@ -824,7 +824,7 @@ PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'
 	const char *end;
 	params.group_size = bfd_scan_vma (optarg, &end, 0);
 	if (*end)
-	  einfo (_("%F%P: invalid number `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid number `%s'\''\n"), optarg);
       }
       break;
 
@@ -850,7 +850,7 @@ PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'
 	  char *end;
 	  long val = strtol (optarg, &end, 0);
 	  if (*end || (unsigned long) val + 8 > 16)
-	    einfo (_("%F%P: invalid --plt-align `%s'\''\n"), optarg);
+	    fatal (_("%P: invalid --plt-align `%s'\''\n"), optarg);
 	  params.plt_stub_align = val;
 	}
       else
diff --git a/ld/emultempl/riscvelf.em b/ld/emultempl/riscvelf.em
index da5c934d25d..b293504c8f0 100644
--- a/ld/emultempl/riscvelf.em
+++ b/ld/emultempl/riscvelf.em
@@ -78,7 +78,7 @@ riscv_create_output_section_statements (void)
 	 These will only be created if the output format is a RISC-V format,
 	 hence we do not support linking and changing output formats at the
 	 same time.  Use a link followed by objcopy to change output formats.  */
-      einfo (_("%F%P: error: cannot change output format"
+      fatal (_("%P: error: cannot change output format"
 	       " whilst linking %s binaries\n"), "RISC-V");
       return;
     }
diff --git a/ld/emultempl/s390.em b/ld/emultempl/s390.em
index 5d3b4465e53..c38bacd39c3 100644
--- a/ld/emultempl/s390.em
+++ b/ld/emultempl/s390.em
@@ -34,7 +34,7 @@ static void
 s390_elf_create_output_section_statements (void)
 {
   if (!bfd_elf_s390_set_options (&link_info, &params))
-    einfo (_("%F%P: can not init BFD: %E\n"));
+    fatal (_("%P: can not init BFD: %E\n"));
 }
 
 EOF
diff --git a/ld/emultempl/scoreelf.em b/ld/emultempl/scoreelf.em
index 327ec6b6fff..7234ac6289a 100644
--- a/ld/emultempl/scoreelf.em
+++ b/ld/emultempl/scoreelf.em
@@ -52,7 +52,7 @@ score_elf_after_open (void)
 	 These will only be created if the output format is an score format,
 	 hence we do not support linking and changing output formats at the
 	 same time.  Use a link followed by objcopy to change output formats.  */
-      einfo (_("%F%P: error: cannot change output format "
+      fatal (_("%P: error: cannot change output format "
 	       "whilst linking %s binaries\n"), "S+core");
       return;
     }
diff --git a/ld/emultempl/spuelf.em b/ld/emultempl/spuelf.em
index baaf44f3b46..dce0c8f8c1e 100644
--- a/ld/emultempl/spuelf.em
+++ b/ld/emultempl/spuelf.em
@@ -202,7 +202,7 @@ spu_elf_load_ovl_mgr (void)
       /* User supplied __ovly_load.  */
     }
   else if (mgr_stream->start == mgr_stream->end)
-    einfo (_("%F%P: no built-in overlay manager\n"));
+    fatal (_("%P: no built-in overlay manager\n"));
   else
     {
       lang_input_statement_type *ovl_is;
@@ -379,7 +379,7 @@ spu_elf_open_overlay_script (void)
   if (script == NULL)
     {
     file_err:
-      einfo (_("%F%P: can not open script: %E\n"));
+      fatal (_("%P: can not open script: %E\n"));
     }
   return script;
 }
@@ -719,7 +719,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	    if (*end == 0)
 	      break;
 	  }
-	einfo (_("%F%P: invalid --local-store address range `%s'\''\n"), optarg);
+	fatal (_("%P: invalid --local-store address range `%s'\''\n"), optarg);
       }
       break;
 
@@ -755,12 +755,12 @@ PARSE_AND_LIST_ARGS_CASES='
       if (!num_lines_set)
 	params.num_lines = 32;
       else if ((params.num_lines & -params.num_lines) != params.num_lines)
-	einfo (_("%F%P: invalid --num-lines/--num-regions `%u'\''\n"),
+	fatal (_("%P: invalid --num-lines/--num-regions `%u'\''\n"),
 	       params.num_lines);
       if (!line_size_set)
 	params.line_size = 1024;
       else if ((params.line_size & -params.line_size) != params.line_size)
-	einfo (_("%F%P: invalid --line-size/--region-size `%u'\''\n"),
+	fatal (_("%P: invalid --line-size/--region-size `%u'\''\n"),
 	       params.line_size);
       break;
 
@@ -781,7 +781,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	    && (params.ovly_flavour != ovly_soft_icache
 		|| (params.num_lines & -params.num_lines) == params.num_lines))
 	  break;
-	einfo (_("%F%P: invalid --num-lines/--num-regions `%s'\''\n"), optarg);
+	fatal (_("%P: invalid --num-lines/--num-regions `%s'\''\n"), optarg);
       }
       break;
 
@@ -794,7 +794,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	    && (params.ovly_flavour != ovly_soft_icache
 		|| (params.line_size & -params.line_size) == params.line_size))
 	  break;
-	einfo (_("%F%P: invalid --line-size/--region-size `%s'\''\n"), optarg);
+	fatal (_("%P: invalid --line-size/--region-size `%s'\''\n"), optarg);
       }
       break;
 
@@ -803,7 +803,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	char *end;
 	params.auto_overlay_fixed = strtoul (optarg, &end, 0);
 	if (*end != 0)
-	  einfo (_("%F%P: invalid --fixed-space value `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid --fixed-space value `%s'\''\n"), optarg);
       }
       break;
 
@@ -812,7 +812,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	char *end;
 	params.auto_overlay_reserved = strtoul (optarg, &end, 0);
 	if (*end != 0)
-	  einfo (_("%F%P: invalid --reserved-space value `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid --reserved-space value `%s'\''\n"), optarg);
       }
       break;
 
@@ -821,7 +821,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	char *end;
 	params.extra_stack_space = strtol (optarg, &end, 0);
 	if (*end != 0)
-	  einfo (_("%F%P: invalid --extra-stack-space value `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid --extra-stack-space value `%s'\''\n"), optarg);
       }
       break;
 
diff --git a/ld/emultempl/tic6xdsbt.em b/ld/emultempl/tic6xdsbt.em
index ef31238858f..8265dc7a065 100644
--- a/ld/emultempl/tic6xdsbt.em
+++ b/ld/emultempl/tic6xdsbt.em
@@ -59,10 +59,8 @@ tic6x_after_open (void)
   if (is_tic6x_target ())
     {
       if (params.dsbt_index >= params.dsbt_size)
-	{
-	  einfo (_("%F%P: invalid --dsbt-index %d, outside DSBT size\n"),
-		 params.dsbt_index);
-	}
+	fatal (_("%P: invalid --dsbt-index %d, outside DSBT size\n"),
+	       params.dsbt_index);
       elf32_tic6x_setup (&link_info, &params);
     }
 
@@ -192,7 +190,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	if (*end == 0
 	    && params.dsbt_index >= 0 && params.dsbt_index < 0x7fff)
 	  break;
-	einfo (_("%F%P: invalid --dsbt-index %s\n"), optarg);
+	fatal (_("%P: invalid --dsbt-index %s\n"), optarg);
       }
       break;
     case OPTION_DSBT_SIZE:
@@ -202,7 +200,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	if (*end == 0
 	    && params.dsbt_size >= 0 && params.dsbt_size < 0x7fff)
 	  break;
-	einfo (_("%F%P: invalid --dsbt-size %s\n"), optarg);
+	fatal (_("%P: invalid --dsbt-size %s\n"), optarg);
       }
       break;
    case OPTION_NO_MERGE_EXIDX_ENTRIES:
diff --git a/ld/emultempl/ticoff.em b/ld/emultempl/ticoff.em
index 2b6fae64a08..8178d7d44c2 100644
--- a/ld/emultempl/ticoff.em
+++ b/ld/emultempl/ticoff.em
@@ -88,7 +88,7 @@ gld${EMULATION_NAME}_handle_option (int optc)
 	}
       else
 	{
-	  einfo (_("%F%P: invalid COFF format version %s\n"), optarg);
+	fatal (_("%P: invalid COFF format version %s\n"), optarg);
 	}
       break;
     }
diff --git a/ld/emultempl/v850elf.em b/ld/emultempl/v850elf.em
index 38be6d66821..386d0c6305c 100644
--- a/ld/emultempl/v850elf.em
+++ b/ld/emultempl/v850elf.em
@@ -63,7 +63,7 @@ v850_create_output_section_statements (void)
 	 These will only be created if the output format is an arm format,
 	 hence we do not support linking and changing output formats at the
 	 same time.  Use a link followed by objcopy to change output formats.  */
-      einfo (_("%F%P: error: cannot change output format"
+      fatal (_("%P: error: cannot change output format"
 	       " whilst linking %s binaries\n"), "V850");
       return;
     }
diff --git a/ld/emultempl/vms.em b/ld/emultempl/vms.em
index fffbf122381..7199b1914ff 100644
--- a/ld/emultempl/vms.em
+++ b/ld/emultempl/vms.em
@@ -200,7 +200,7 @@ gld${EMULATION_NAME}_before_allocation (void)
       && bed->elf_backend_size_dynamic_sections
       && ! (*bed->elf_backend_size_dynamic_sections) (link_info.output_bfd,
 						      &link_info))
-    einfo (_("%F%P: failed to set dynamic section sizes: %E\n"));
+    fatal (_("%P: failed to set dynamic section sizes: %E\n"));
 
   before_allocation_default ();
 }
diff --git a/ld/emultempl/xtensaelf.em b/ld/emultempl/xtensaelf.em
index 1aca7b77ace..629b3eec12d 100644
--- a/ld/emultempl/xtensaelf.em
+++ b/ld/emultempl/xtensaelf.em
@@ -384,7 +384,7 @@ check_xtensa_info (bfd *abfd, asection *info_sec)
 
   data = xmalloc (info_sec->size);
   if (! bfd_get_section_contents (abfd, info_sec, data, 0, info_sec->size))
-    einfo (_("%F%P: %pB: cannot read contents of section %pA\n"), abfd, info_sec);
+    fatal (_("%P: %pB: cannot read contents of section %pA\n"), abfd, info_sec);
 
   if (info_sec->size > 24
       && info_sec->size >= 24 + bfd_get_32 (abfd, data + 4)
@@ -425,13 +425,13 @@ elf_xtensa_before_allocation (void)
   if (is_big_endian
       && link_info.output_bfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
     {
-      einfo (_("%F%P: little endian output does not match "
+      fatal (_("%P: little endian output does not match "
 	       "Xtensa configuration\n"));
     }
   if (!is_big_endian
       && link_info.output_bfd->xvec->byteorder == BFD_ENDIAN_BIG)
     {
-      einfo (_("%F%P: big endian output does not match "
+      fatal (_("%P: big endian output does not match "
 	       "Xtensa configuration\n"));
     }
 
@@ -450,7 +450,7 @@ elf_xtensa_before_allocation (void)
 	 cannot go any further if there are any mismatches.  */
       if ((is_big_endian && f->the_bfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
 	  || (!is_big_endian && f->the_bfd->xvec->byteorder == BFD_ENDIAN_BIG))
-	einfo (_("%F%P: cross-endian linking for %pB not supported\n"),
+	fatal (_("%P: cross-endian linking for %pB not supported\n"),
 	       f->the_bfd);
 
       if (! first_bfd)
@@ -481,7 +481,7 @@ elf_xtensa_before_allocation (void)
       info_sec = bfd_make_section_with_flags (first_bfd, ".xtensa.info",
 					      SEC_HAS_CONTENTS | SEC_READONLY);
       if (! info_sec)
-	einfo (_("%F%P: failed to create .xtensa.info section\n"));
+	fatal (_("%P: failed to create .xtensa.info section\n"));
     }
   if (info_sec)
     {
diff --git a/ld/ldcref.c b/ld/ldcref.c
index 9120bf87fbd..d686d403bad 100644
--- a/ld/ldcref.c
+++ b/ld/ldcref.c
@@ -515,7 +515,7 @@ check_local_sym_xref (lang_input_statement_type *statement)
     return;
 
   if (!bfd_generic_link_read_symbols (abfd))
-    einfo (_("%F%P: %pB: could not read symbols: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read symbols: %E\n"), abfd);
 
   for (syms = bfd_get_outsymbols (abfd); *syms; ++syms)
     {
@@ -626,7 +626,7 @@ check_refs (const char *name,
      BFD might contain a prohibited cross reference.  */
 
   if (!bfd_generic_link_read_symbols (abfd))
-    einfo (_("%F%P: %pB: could not read symbols: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read symbols: %E\n"), abfd);
 
   info.sym_name = name;
   info.global = global;
@@ -688,14 +688,14 @@ check_reloc_refs (bfd *abfd, asection *sec, void *iarg)
 
   relsize = bfd_get_reloc_upper_bound (abfd, sec);
   if (relsize < 0)
-    einfo (_("%F%P: %pB: could not read relocs: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read relocs: %E\n"), abfd);
   if (relsize == 0)
     return;
 
   relpp = (arelent **) xmalloc (relsize);
   relcount = bfd_canonicalize_reloc (abfd, sec, relpp, info->asymbols);
   if (relcount < 0)
-    einfo (_("%F%P: %pB: could not read relocs: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read relocs: %E\n"), abfd);
 
   p = relpp;
   pend = p + relcount;
diff --git a/ld/ldelf.c b/ld/ldelf.c
index f97d3fc1ca1..84fd8a0c42b 100644
--- a/ld/ldelf.c
+++ b/ld/ldelf.c
@@ -95,7 +95,7 @@ ldelf_load_symbols (lang_input_statement_type *entry)
 
   if (entry->flags.just_syms
       && (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) != 0)
-    einfo (_("%F%P: %pB: --just-symbols may not be used on DSO\n"),
+    fatal (_("%P: %pB: --just-symbols may not be used on DSO\n"),
 	   entry->the_bfd);
 
   if (link_class == 0
@@ -293,7 +293,7 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)
       struct bfd_link_needed_list *needs;
 
       if (! bfd_elf_get_bfd_needed_list (abfd, &needs))
-	einfo (_("%F%P: %pB: bfd_elf_get_bfd_needed_list failed: %E\n"), abfd);
+	fatal (_("%P: %pB: bfd_elf_get_bfd_needed_list failed: %E\n"), abfd);
 
       if (needs != NULL)
 	{
@@ -341,7 +341,7 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)
      can only check that using stat.  */
 
   if (bfd_stat (abfd, &global_stat) != 0)
-    einfo (_("%F%P: %pB: bfd_stat failed: %E\n"), abfd);
+    fatal (_("%P: %pB: bfd_stat failed: %E\n"), abfd);
 
   /* First strip off everything before the last '/'.  */
   soname = lbasename (bfd_get_filename (abfd));
@@ -377,7 +377,7 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)
 
   /* Add this file into the symbol table.  */
   if (! bfd_link_add_symbols (abfd, &link_info))
-    einfo (_("%F%P: %pB: error adding symbols: %E\n"), abfd);
+    fatal (_("%P: %pB: error adding symbols: %E\n"), abfd);
 
   return TRUE;
 }
@@ -1007,10 +1007,8 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,
 		     bfd_get_target (link_info.output_bfd));
 
       if (link_info.out_implib_bfd == NULL)
-	{
-	  einfo (_("%F%P: %s: can't open for writing: %E\n"),
-		 command_line.out_implib_filename);
-	}
+	fatal (_("%P: %s: can't open for writing: %E\n"),
+	       command_line.out_implib_filename);
     }
 
   if (ldelf_emit_note_gnu_build_id != NULL)
@@ -1085,7 +1083,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,
 		}
 	      else if (seen_type != type)
 		{
-		  einfo (_("%F%P: compact frame descriptions incompatible with"
+		  fatal (_("%P: compact frame descriptions incompatible with"
 			   " DWARF2 .eh_frame from %pB\n"),
 			 type == DWARF2_EH_HDR ? abfd : elfbfd);
 		  break;
@@ -1294,7 +1292,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,
 
   if (link_info.eh_frame_hdr_type == COMPACT_EH_HDR)
     if (!bfd_elf_parse_eh_frame_entries (NULL, &link_info))
-      einfo (_("%F%P: failed to parse EH frame entries\n"));
+      fatal (_("%P: failed to parse EH frame entries\n"));
 }
 
 static bfd_size_type
@@ -1429,7 +1427,7 @@ ldelf_find_exp_assignment (etree_type *exp)
 					       &link_info,
 					       exp->assign.dst, provide,
 					       exp->assign.hidden))
-	    einfo (_("%F%P: failed to record assignment to %s: %E\n"),
+	    fatal (_("%P: failed to record assignment to %s: %E\n"),
 		   exp->assign.dst);
 	}
       ldelf_find_exp_assignment (exp->assign.src);
@@ -1613,7 +1611,7 @@ ldelf_before_allocation (char *audit, char *depaudit,
 	  command_line.filter_shlib, audit, depaudit,
 	  (const char * const *) command_line.auxiliary_filters,
 	  &link_info, &sinterp)))
-    einfo (_("%F%P: failed to set dynamic section sizes: %E\n"));
+    fatal (_("%P: failed to set dynamic section sizes: %E\n"));
 
   if (sinterp != NULL)
     {
@@ -1650,8 +1648,8 @@ ldelf_before_allocation (char *audit, char *depaudit,
 	msg = (char *) xmalloc ((size_t) (sz + 1));
 	if (! bfd_get_section_contents (is->the_bfd, s,	msg,
 					(file_ptr) 0, sz))
-	  einfo (_("%F%P: %pB: can't read contents of section .gnu.warning: %E\n"),
-		 is->the_bfd);
+	  fatal (_("%P: %pB: can't read contents of section %pA: %E\n"),
+		 is->the_bfd, s);
 	msg[sz] = '\0';
 	(*link_info.callbacks->warning) (&link_info, msg,
 					 (const char *) NULL, is->the_bfd,
@@ -1678,7 +1676,7 @@ ldelf_before_allocation (char *audit, char *depaudit,
   before_allocation_default ();
 
   if (!bfd_elf_size_dynsym_hash_dynstr (link_info.output_bfd, &link_info))
-    einfo (_("%F%P: failed to set dynamic section sizes: %E\n"));
+    fatal (_("%P: failed to set dynamic section sizes: %E\n"));
 
   if (ehdr_start != NULL)
     {
diff --git a/ld/ldelfgen.c b/ld/ldelfgen.c
index 21739b19ca1..8bcb05a19d8 100644
--- a/ld/ldelfgen.c
+++ b/ld/ldelfgen.c
@@ -52,7 +52,7 @@ ldelf_map_segments (bfd_boolean need_layout)
 	    elf_seg_map (link_info.output_bfd) = NULL;
 	  if (!_bfd_elf_map_sections_to_segments (link_info.output_bfd,
 						  &link_info))
-	    einfo (_("%F%P: map sections to segments failed: %E\n"));
+	    fatal (_("%P: map sections to segments failed: %E\n"));
 
 	  if (phdr_size != elf_program_header_size (link_info.output_bfd))
 	    {
@@ -72,7 +72,7 @@ ldelf_map_segments (bfd_boolean need_layout)
   while (need_layout && --tries);
 
   if (tries == 0)
-    einfo (_("%F%P: looping in map_segments"));
+    fatal (_("%P: looping in map_segments\n"));
 }
 
 /* We want to emit CTF early if and only if we are not targetting ELF with this
@@ -174,13 +174,13 @@ ldelf_examine_strtab_for_ctf
     {
       if (ctf_link_add_strtab (ctf_output, ldelf_ctf_strtab_iter_cb,
 			       &args) < 0)
-	einfo (_("%F%P: warning: CTF strtab association failed; strings will "
+	fatal (_("%P: warning: CTF strtab association failed; strings will "
 		 "not be shared: %s\n"),
 	       ctf_errmsg (ctf_errno (ctf_output)));
 
       if (ctf_link_shuffle_syms (ctf_output, ldelf_ctf_symbols_iter_cb,
 				 &args) < 0)
-	einfo (_("%F%P: warning: CTF symbol shuffling failed; slight space "
+	fatal (_("%P: warning: CTF symbol shuffling failed; slight space "
 		 "cost: %s\n"), ctf_errmsg (ctf_errno (ctf_output)));
     }
 }
diff --git a/ld/ldemul.c b/ld/ldemul.c
index 1f5228d2a4a..c4d53657b0c 100644
--- a/ld/ldemul.c
+++ b/ld/ldemul.c
@@ -329,7 +329,7 @@ ldemul_choose_mode (char *target)
   einfo (_("%P: unrecognised emulation mode: %s\n"), target);
   einfo (_("Supported emulations: "));
   ldemul_list_emulations (stderr);
-  einfo ("%F\n");
+  fatal ("\n");
 }
 
 void
diff --git a/ld/ldexp.c b/ld/ldexp.c
index 6d1457b929a..40aa71463f9 100644
--- a/ld/ldexp.c
+++ b/ld/ldexp.c
@@ -281,7 +281,7 @@ definedness_newfunc (struct bfd_hash_entry *entry,
       bfd_hash_allocate (table, sizeof (struct definedness_hash_entry));
 
   if (ret == NULL)
-    einfo (_("%F%P: bfd_hash_allocate failed creating symbol %s\n"), name);
+    fatal (_("%P: bfd_hash_allocate failed creating symbol %s\n"), name);
 
   ret->by_object = 0;
   ret->iteration = 0;
@@ -628,7 +628,7 @@ fold_binary (etree_type *tree)
 	    expld.result.value = ((bfd_signed_vma) lhs.value
 				  % (bfd_signed_vma) expld.result.value);
 	  else if (expld.phase != lang_mark_phase_enum)
-	    einfo (_("%F%P:%pS %% by zero\n"), tree->binary.rhs);
+	    fatal (_("%P:%pS %% by zero\n"), tree->binary.rhs);
 	  arith_result_section (&lhs);
 	  break;
 
@@ -637,7 +637,7 @@ fold_binary (etree_type *tree)
 	    expld.result.value = ((bfd_signed_vma) lhs.value
 				  / (bfd_signed_vma) expld.result.value);
 	  else if (expld.phase != lang_mark_phase_enum)
-	    einfo (_("%F%P:%pS / by zero\n"), tree->binary.rhs);
+	    fatal (_("%P:%pS / by zero\n"), tree->binary.rhs);
 	  arith_result_section (&lhs);
 	  break;
 
@@ -732,7 +732,7 @@ fold_name (etree_type *tree)
 	  if (!h)
 	    {
 	      if (expld.phase != lang_first_phase_enum)
-		einfo (_("%F%P: bfd_link_hash_lookup failed: %E\n"));
+		fatal (_("%P: bfd_link_hash_lookup failed: %E\n"));
 	    }
 	  else if (h->type == bfd_link_hash_defined
 		   || h->type == bfd_link_hash_defweak)
@@ -760,7 +760,7 @@ fold_name (etree_type *tree)
 	  else if (expld.phase == lang_final_phase_enum
 		   || (expld.phase != lang_mark_phase_enum
 		       && expld.assigning_to_dot))
-	    einfo (_("%F%P:%pS: undefined symbol `%s'"
+	    fatal (_("%P:%pS: undefined symbol `%s'"
 		     " referenced in expression\n"),
 		   tree, tree->name.name);
 	  else if (h->type == bfd_link_hash_new)
@@ -798,7 +798,7 @@ fold_name (etree_type *tree)
 	  if (os == NULL)
 	    {
 	      if (expld.phase == lang_final_phase_enum)
-		einfo (_("%F%P:%pS: undefined section `%s'"
+		fatal (_("%P:%pS: undefined section `%s'"
 			 " referenced in expression\n"),
 		       tree, tree->name.name);
 	    }
@@ -816,7 +816,7 @@ fold_name (etree_type *tree)
 	  if (os == NULL)
 	    {
 	      if (expld.phase == lang_final_phase_enum)
-		einfo (_("%F%P:%pS: undefined section `%s'"
+		fatal (_("%P:%pS: undefined section `%s'"
 			 " referenced in expression\n"),
 		       tree, tree->name.name);
 	    }
@@ -844,7 +844,7 @@ fold_name (etree_type *tree)
 	  if (os == NULL)
 	    {
 	      if (expld.phase == lang_final_phase_enum)
-		einfo (_("%F%P:%pS: undefined section `%s'"
+		fatal (_("%P:%pS: undefined section `%s'"
 			 " referenced in expression\n"),
 		       tree, tree->name.name);
 	      new_number (0);
@@ -875,7 +875,7 @@ fold_name (etree_type *tree)
 	if (mem != NULL)
 	  new_number (mem->length);
 	else
-	  einfo (_("%F%P:%pS: undefined MEMORY region `%s'"
+	  fatal (_("%P:%pS: undefined MEMORY region `%s'"
 		   " referenced in expression\n"),
 		 tree, tree->name.name);
       }
@@ -889,7 +889,7 @@ fold_name (etree_type *tree)
 	if (mem != NULL)
 	  new_rel_from_abs (mem->origin);
 	else
-	  einfo (_("%F%P:%pS: undefined MEMORY region `%s'"
+	  fatal (_("%P:%pS: undefined MEMORY region `%s'"
 		   " referenced in expression\n"),
 		 tree, tree->name.name);
       }
@@ -901,7 +901,7 @@ fold_name (etree_type *tree)
       else if (strcmp (tree->name.name, "COMMONPAGESIZE") == 0)
 	new_number (config.commonpagesize);
       else
-	einfo (_("%F%P:%pS: unknown constant `%s' referenced in expression\n"),
+	fatal (_("%P:%pS: unknown constant `%s' referenced in expression\n"),
 	       tree, tree->name.name);
       break;
 
@@ -1049,7 +1049,7 @@ exp_fold_tree_1 (etree_type *tree)
       if (tree->assign.dst[0] == '.' && tree->assign.dst[1] == 0)
 	{
 	  if (tree->type.node_class != etree_assign)
-	    einfo (_("%F%P:%pS can not PROVIDE assignment to"
+	    fatal (_("%P:%pS can not PROVIDE assignment to"
 		     " location counter\n"), tree);
 	  if (expld.phase != lang_first_phase_enum)
 	    {
@@ -1082,11 +1082,11 @@ exp_fold_tree_1 (etree_type *tree)
 		  || expld.section == bfd_und_section_ptr)
 		{
 		  if (expld.phase != lang_mark_phase_enum)
-		    einfo (_("%F%P:%pS invalid assignment to"
+		    fatal (_("%P:%pS invalid assignment to"
 			     " location counter\n"), tree);
 		}
 	      else if (expld.dotp == NULL)
-		einfo (_("%F%P:%pS assignment to location counter"
+		fatal (_("%P:%pS assignment to location counter"
 			 " invalid outside of SECTIONS\n"), tree);
 
 	      /* After allocation, assignment to dot should not be
@@ -1105,7 +1105,7 @@ exp_fold_tree_1 (etree_type *tree)
 		    nextdot += expld.section->vma;
 		  if (nextdot < expld.dot
 		      && expld.section != bfd_abs_section_ptr)
-		    einfo (_("%F%P:%pS cannot move location counter backwards"
+		    fatal (_("%P:%pS cannot move location counter backwards"
 			     " (from %V to %V)\n"),
 			   tree, expld.dot, nextdot);
 		  else
@@ -1165,7 +1165,7 @@ exp_fold_tree_1 (etree_type *tree)
 		  h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,
 					    TRUE, FALSE, TRUE);
 		  if (h == NULL)
-		    einfo (_("%F%P:%s: hash creation failed\n"),
+		    fatal (_("%P:%s: hash creation failed\n"),
 			   tree->assign.dst);
 		}
 
@@ -1530,7 +1530,7 @@ exp_get_vma (etree_type *tree, bfd_vma def, char *name)
       if (expld.result.valid_p)
 	return expld.result.value;
       else if (name != NULL && expld.phase != lang_mark_phase_enum)
-	einfo (_("%F%P:%pS: nonconstant expression for %s\n"),
+	fatal (_("%P:%pS: nonconstant expression for %s\n"),
 	       tree, name);
     }
   return def;
@@ -1572,7 +1572,7 @@ exp_get_fill (etree_type *tree, fill_type *def, char *name)
   if (!expld.result.valid_p)
     {
       if (name != NULL && expld.phase != lang_mark_phase_enum)
-	einfo (_("%F%P:%pS: nonconstant expression for %s\n"),
+	fatal (_("%P:%pS: nonconstant expression for %s\n"),
 	       tree, name);
       return def;
     }
@@ -1632,7 +1632,7 @@ exp_get_abs_int (etree_type *tree, int def, char *name)
 	}
       else if (name != NULL && expld.phase != lang_mark_phase_enum)
 	{
-	  einfo (_("%F%P:%pS: nonconstant expression for %s\n"),
+	  fatal (_("%P:%pS: nonconstant expression for %s\n"),
 		 tree, name);
 	}
     }
@@ -1658,7 +1658,7 @@ ldexp_init (void)
 			      definedness_newfunc,
 			      sizeof (struct definedness_hash_entry),
 			      13))
-    einfo (_("%F%P: can not create hash table: %E\n"));
+    fatal (_("%P: can not create hash table: %E\n"));
 }
 
 /* Convert absolute symbols defined by a script from "dot" (also
diff --git a/ld/ldfile.c b/ld/ldfile.c
index 17db16c2cc9..3793fd378b8 100644
--- a/ld/ldfile.c
+++ b/ld/ldfile.c
@@ -155,7 +155,7 @@ ldfile_try_open_bfd (const char *attempt,
   if (entry->the_bfd == NULL)
     {
       if (bfd_get_error () == bfd_error_invalid_target)
-	einfo (_("%F%P: invalid BFD target `%s'\n"), entry->target);
+	fatal (_("%P: invalid BFD target `%s'\n"), entry->target);
       return FALSE;
     }
 
@@ -293,7 +293,7 @@ ldfile_try_open_bfd (const char *attempt,
 
 	  if (!entry->flags.dynamic && (entry->the_bfd->flags & DYNAMIC) != 0)
 	    {
-	      einfo (_("%F%P: attempted static link of dynamic object `%s'\n"),
+	      fatal (_("%P: attempted static link of dynamic object `%s'\n"),
 		     attempt);
 	      bfd_close (entry->the_bfd);
 	      entry->the_bfd = NULL;
@@ -634,7 +634,7 @@ ldfile_open_command_file_1 (const char *name, enum script_open_style open_how)
       if ((open_how != script_nonT || script->open_how != script_nonT)
 	  && strcmp (name, script->name) == 0)
 	{
-	  einfo (_("%F%P: error: linker script file '%s'"
+	  fatal (_("%P: error: linker script file '%s'"
 		   " appears multiple times\n"), name);
 	  return;
 	}
@@ -656,7 +656,7 @@ ldfile_open_command_file_1 (const char *name, enum script_open_style open_how)
   if (ldlex_input_stack == NULL)
     {
       bfd_set_error (bfd_error_system_call);
-      einfo (_("%F%P: cannot open linker script file %s: %E\n"), name);
+      fatal (_("%P: cannot open linker script file %s: %E\n"), name);
       return;
     }
 
@@ -727,5 +727,5 @@ ldfile_set_output_arch (const char *string, enum bfd_architecture defarch)
   else if (defarch != bfd_arch_unknown)
     ldfile_output_architecture = defarch;
   else
-    einfo (_("%F%P: cannot represent machine `%s'\n"), string);
+    fatal (_("%P: cannot represent machine `%s'\n"), string);
 }
diff --git a/ld/ldgram.y b/ld/ldgram.y
index df5c035c03a..07ecac5bf27 100644
--- a/ld/ldgram.y
+++ b/ld/ldgram.y
@@ -207,7 +207,7 @@ mri_script_command:
 		CHIP  exp
 	|	CHIP  exp ',' exp
 	|	NAME	{
-			einfo(_("%F%P: unrecognised keyword in MRI style script '%s'\n"),$1);
+			fatal (_("%P: unrecognised keyword in MRI style script '%s'\n"), $1);
 			}
 	|	LIST	{
 			config.map_filename = "-";
@@ -1477,7 +1477,7 @@ yyerror(arg)
     einfo (_("%P:%s: file format not recognized; treating as linker script\n"),
 	   ldlex_filename ());
   if (error_index > 0 && error_index < ERROR_NAME_MAX)
-    einfo ("%F%P:%pS: %s in %s\n", NULL, arg, error_names[error_index - 1]);
+    fatal (_("%P:%pS: %s in %s\n"), NULL, arg, error_names[error_index - 1]);
   else
-    einfo ("%F%P:%pS: %s\n", NULL, arg);
+    fatal ("%P:%pS: %s\n", NULL, arg);
 }
diff --git a/ld/ldlang.c b/ld/ldlang.c
index e100c0533cf..b6846880d00 100644
--- a/ld/ldlang.c
+++ b/ld/ldlang.c
@@ -1252,7 +1252,7 @@ output_section_statement_table_init (void)
 			      output_section_statement_newfunc,
 			      sizeof (struct out_section_hash_entry),
 			      61))
-    einfo (_("%F%P: can not create hash table: %E\n"));
+    fatal (_("%P: can not create hash table: %E\n"));
 }
 
 static void
@@ -1378,7 +1378,7 @@ lang_memory_region_alias (const char *alias, const char *region_name)
      the default memory region.  */
   if (strcmp (region_name, DEFAULT_MEMORY_REGION) == 0
       || strcmp (alias, DEFAULT_MEMORY_REGION) == 0)
-    einfo (_("%F%P:%pS: error: alias for default memory region\n"), NULL);
+    fatal (_("%P:%pS: error: alias for default memory region\n"), NULL);
 
   /* Look for the target region and check if the alias is not already
      in use.  */
@@ -1389,14 +1389,14 @@ lang_memory_region_alias (const char *alias, const char *region_name)
 	if (region == NULL && strcmp (n->name, region_name) == 0)
 	  region = r;
 	if (strcmp (n->name, alias) == 0)
-	  einfo (_("%F%P:%pS: error: redefinition of memory region "
+	  fatal (_("%P:%pS: error: redefinition of memory region "
 		   "alias `%s'\n"),
 		 NULL, alias);
       }
 
   /* Check if the target region exists.  */
   if (region == NULL)
-    einfo (_("%F%P:%pS: error: memory region `%s' "
+    fatal (_("%P:%pS: error: memory region `%s' "
 	     "for alias `%s' does not exist\n"),
 	   NULL, region_name, alias);
 
@@ -1455,7 +1455,7 @@ lang_output_section_statement_lookup (const char *name,
   if (entry == NULL)
     {
       if (create)
-	einfo (_("%F%P: failed creating section `%s': %E\n"), name);
+	fatal (_("%P: failed creating section `%s': %E\n"), name);
       return NULL;
     }
 
@@ -1494,7 +1494,7 @@ lang_output_section_statement_lookup (const char *name,
 					     name));
       if (entry == NULL)
 	{
-	  einfo (_("%F%P: failed creating section `%s': %E\n"), name);
+	  fatal (_("%P: failed creating section `%s': %E\n"), name);
 	  return NULL;
 	}
       entry->root = last_ent->root;
@@ -2362,7 +2362,7 @@ static void
 init_os (lang_output_section_statement_type *s, flagword flags)
 {
   if (strcmp (s->name, DISCARD_SECTION_NAME) == 0)
-    einfo (_("%F%P: illegal use of `%s' section\n"), DISCARD_SECTION_NAME);
+    fatal (_("%P: illegal use of `%s' section\n"), DISCARD_SECTION_NAME);
 
   if (s->constraint != SPECIAL)
     s->bfd_section = bfd_get_section_by_name (link_info.output_bfd, s->name);
@@ -2371,7 +2371,7 @@ init_os (lang_output_section_statement_type *s, flagword flags)
 							 s->name, flags);
   if (s->bfd_section == NULL)
     {
-      einfo (_("%F%P: output format %s cannot represent section"
+      fatal (_("%P: output format %s cannot represent section"
 	       " called %s: %E\n"),
 	     link_info.output_bfd->xvec->name, s->name);
     }
@@ -2994,11 +2994,11 @@ load_symbols (lang_input_statement_type *entry,
 		   " matching formats:"), entry->the_bfd);
 	  for (p = matching; *p != NULL; p++)
 	    einfo (" %s", *p);
-	  einfo ("%F\n");
+	  fatal ("\n");
 	}
       else if (err != bfd_error_file_not_recognized
 	       || place == NULL)
-	einfo (_("%F%P: %pB: file not recognized: %E\n"), entry->the_bfd);
+	fatal (_("%P: %pB: file not recognized: %E\n"), entry->the_bfd);
 
       bfd_close (entry->the_bfd);
       entry->the_bfd = NULL;
@@ -3069,8 +3069,8 @@ load_symbols (lang_input_statement_type *entry,
 
 	      if (!bfd_check_format (member, bfd_object))
 		{
-		  einfo (_("%F%P: %pB: member %pB in archive is not an object\n"),
-			 entry->the_bfd, member);
+		  fatal (_("%P: %pB: member %pB in archive is not an object\n"),
+				  entry->the_bfd, member);
 		  loaded = FALSE;
 		}
 
@@ -3084,7 +3084,7 @@ load_symbols (lang_input_statement_type *entry,
 		 substitute BFD for us.  */
 	      if (!bfd_link_add_symbols (subsbfd, &link_info))
 		{
-		  einfo (_("%F%P: %pB: error adding symbols: %E\n"), member);
+		  fatal (_("%P: %pB: error adding symbols: %E\n"), member);
 		  loaded = FALSE;
 		}
 	    }
@@ -3098,7 +3098,7 @@ load_symbols (lang_input_statement_type *entry,
   if (bfd_link_add_symbols (entry->the_bfd, &link_info))
     entry->flags.loaded = TRUE;
   else
-    einfo (_("%F%P: %pB: error adding symbols: %E\n"), entry->the_bfd);
+    fatal (_("%P: %pB: error adding symbols: %E\n"), entry->the_bfd);
 
   return entry->flags.loaded;
 }
@@ -3386,23 +3386,23 @@ open_output (const char *name)
   if (link_info.output_bfd == NULL)
     {
       if (bfd_get_error () == bfd_error_invalid_target)
-	einfo (_("%F%P: target %s not found\n"), output_target);
+	fatal (_("%P: target %s not found\n"), output_target);
 
-      einfo (_("%F%P: cannot open output file %s: %E\n"), name);
+      fatal (_("%P: cannot open output file %s: %E\n"), name);
     }
 
   delete_output_file_on_failure = TRUE;
 
   if (!bfd_set_format (link_info.output_bfd, bfd_object))
-    einfo (_("%F%P: %s: can not make object file: %E\n"), name);
+    fatal (_("%P: %s: can not make object file: %E\n"), name);
   if (!bfd_set_arch_mach (link_info.output_bfd,
-			   ldfile_output_architecture,
-			   ldfile_output_machine))
-    einfo (_("%F%P: %s: can not set architecture: %E\n"), name);
+			  ldfile_output_architecture,
+			  ldfile_output_machine))
+    fatal (_("%P: %s: can not set architecture: %E\n"), name);
 
   link_info.hash = bfd_link_hash_table_create (link_info.output_bfd);
   if (link_info.hash == NULL)
-    einfo (_("%F%P: can not create hash table: %E\n"));
+    fatal (_("%P: can not create hash table: %E\n"));
 
   bfd_set_gp_size (link_info.output_bfd, g_switch_value);
 }
@@ -3609,7 +3609,7 @@ open_input_bfds (lang_statement_union_type *s, enum open_bfd_mode mode)
 
   /* Exit if any of the files were missing.  */
   if (input_flags.missing_file)
-    einfo ("%F");
+    fatal ("");
 }
 
 /* Open the CTF sections in the input files with libctf: if any were opened,
@@ -3827,7 +3827,7 @@ insert_undefined (const char *name)
 
   h = bfd_link_hash_lookup (link_info.hash, name, TRUE, FALSE, TRUE);
   if (h == NULL)
-    einfo (_("%F%P: bfd_link_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_link_hash_lookup failed: %E\n"));
   if (h->type == bfd_link_hash_new)
     {
       h->type = bfd_link_hash_undefined;
@@ -4203,7 +4203,7 @@ process_insert_statements (lang_statement_union_type **start)
 	    }
 	  if (where == NULL)
 	    {
-	      einfo (_("%F%P: %s not found for insert\n"), i->where);
+	      fatal (_("%P: %s not found for insert\n"), i->where);
 	      return;
 	    }
 
@@ -5483,7 +5483,7 @@ lang_size_sections_1
 		      dot += expld.result.section->vma;
 		  }
 		else if (expld.phase != lang_mark_phase_enum)
-		  einfo (_("%F%P:%pS: non constant or forward reference"
+		  fatal (_("%P:%pS: non constant or forward reference"
 			   " address expression for section %s\n"),
 			 os->addr_tree, os->name);
 	      }
@@ -5566,7 +5566,7 @@ lang_size_sections_1
 			   overridden by the using the --no-check-sections
 			   switch.  */
 			if (command_line.check_section_addresses)
-			  einfo (_("%F%P: error: no memory region specified"
+			  fatal (_("%P: error: no memory region specified"
 				   " for loadable section `%s'\n"),
 				 bfd_section_name (os->bfd_section));
 			else
@@ -5869,7 +5869,7 @@ lang_size_sections_1
 		bfd_boolean again;
 
 		if (!bfd_relax_section (i->owner, i, &link_info, &again))
-		  einfo (_("%F%P: can't relax section: %E\n"));
+		  fatal (_("%P: can't relax section: %E\n"));
 		if (again)
 		  *relax = TRUE;
 	      }
@@ -6252,7 +6252,7 @@ lang_do_assignments_1 (lang_statement_union_type *s,
 		s->data_statement.value += expld.result.section->vma;
 	    }
 	  else if (expld.phase == lang_final_phase_enum)
-	    einfo (_("%F%P: invalid data statement\n"));
+	    fatal (_("%P: invalid data statement\n"));
 	  {
 	    unsigned int size;
 	    switch (s->data_statement.type)
@@ -6285,7 +6285,7 @@ lang_do_assignments_1 (lang_statement_union_type *s,
 	  if (expld.result.valid_p)
 	    s->reloc_statement.addend_value = expld.result.value;
 	  else if (expld.phase == lang_final_phase_enum)
-	    einfo (_("%F%P: invalid reloc statement\n"));
+	    fatal (_("%P: invalid reloc statement\n"));
 	  dot += TO_ADDR (bfd_get_reloc_size (s->reloc_statement.howto));
 	  break;
 
@@ -6663,7 +6663,7 @@ lang_end (void)
 	     + bfd_section_vma (h->u.def.section->output_section)
 	     + h->u.def.section->output_offset);
       if (!bfd_set_start_address (link_info.output_bfd, val))
-	einfo (_("%F%P: %s: can't set start address\n"), entry_symbol.name);
+	fatal (_("%P: %s: can't set start address\n"), entry_symbol.name);
     }
   else
     {
@@ -6676,7 +6676,7 @@ lang_end (void)
       if (*send == '\0')
 	{
 	  if (!bfd_set_start_address (link_info.output_bfd, val))
-	    einfo (_("%F%P: can't set start address\n"));
+	    fatal (_("%P: can't set start address\n"));
 	}
       else
 	{
@@ -6694,7 +6694,7 @@ lang_end (void)
 		       bfd_section_vma (ts));
 	      if (!bfd_set_start_address (link_info.output_bfd,
 					  bfd_section_vma (ts)))
-		einfo (_("%F%P: can't set start address\n"));
+		fatal (_("%P: can't set start address\n"));
 	    }
 	  else
 	    {
@@ -6755,11 +6755,10 @@ lang_check (void)
 		  != bfd_get_flavour (link_info.output_bfd)))
 	  && (bfd_get_file_flags (input_bfd) & HAS_RELOC) != 0)
 	{
-	  einfo (_("%F%P: relocatable linking with relocations from"
+	  fatal (_("%P: relocatable linking with relocations from"
 		   " format %s (%pB) to format %s (%pB) is not supported\n"),
 		 bfd_get_target (input_bfd), input_bfd,
 		 bfd_get_target (link_info.output_bfd), link_info.output_bfd);
-	  /* einfo with %F exits.  */
 	}
 
       if (compatible == NULL)
@@ -6858,7 +6857,7 @@ lang_one_common (struct bfd_link_hash_entry *h, void *info)
 
   section = h->u.c.p->section;
   if (!bfd_define_common_symbol (link_info.output_bfd, &link_info, h))
-    einfo (_("%F%P: could not define common symbol `%pT': %E\n"),
+    fatal (_("%P: could not define common symbol `%pT': %E\n"),
 	   h->root.string);
 
   if (config.map_file != NULL)
@@ -7054,7 +7053,7 @@ lang_set_flags (lang_memory_region_type *ptr, const char *flags, int invert)
 	  break;
 
 	default:
-	  einfo (_("%F%P: invalid character %c (%d) in flags\n"),
+	  fatal (_("%P: invalid character %c (%d) in flags\n"),
 		 *flags, *flags);
 	  break;
 	}
@@ -7162,7 +7161,7 @@ lang_enter_output_section_statement (const char *output_section_statement_name,
 
   os->align_lma_with_input = align_with_input == ALIGN_WITH_INPUT;
   if (os->align_lma_with_input && align != NULL)
-    einfo (_("%F%P:%pS: error: align with input and explicit align specified\n"),
+    fatal (_("%P:%pS: error: align with input and explicit align specified\n"),
 	   NULL);
 
   os->subsection_alignment = subalign;
@@ -7641,7 +7640,7 @@ lang_process (void)
   lang_place_undefineds ();
 
   if (!bfd_section_already_linked_table_init ())
-    einfo (_("%F%P: can not create hash table: %E\n"));
+    fatal (_("%P: can not create hash table: %E\n"));
 
   /* Create a bfd for each input file.  */
   current_target = default_target;
@@ -7668,7 +7667,7 @@ lang_process (void)
       files = file_chain;
       inputfiles = input_file_chain;
       if (plugin_call_all_symbols_read ())
-	einfo (_("%F%P: %s: plugin reported error after all symbols read\n"),
+	fatal (_("%P: %s: plugin reported error after all symbols read\n"),
 	       plugin_error_plugin ());
       /* Open any newly added files, updating the file chains.  */
       plugin_undefs = link_info.hash->undefs_tail;
@@ -8102,9 +8101,7 @@ void
 lang_startup (const char *name)
 {
   if (first_file->filename != NULL)
-    {
-      einfo (_("%F%P: multiple STARTUP files\n"));
-    }
+    fatal (_("%P: multiple STARTUP files\n"));
   first_file->filename = name;
   first_file->local_sym_name = name;
   first_file->flags.real = TRUE;
@@ -8328,7 +8325,7 @@ lang_record_phdrs (void)
 			break;
 		      }
 		  if (last == NULL)
-		    einfo (_("%F%P: no sections assigned to phdrs\n"));
+		    fatal (_("%P: no sections assigned to phdrs\n"));
 		}
 	      pl = last;
 	    }
@@ -8366,7 +8363,7 @@ lang_record_phdrs (void)
       if (!bfd_record_phdr (link_info.output_bfd, l->type,
 			    l->flags != NULL, flags, l->at != NULL,
 			    at, l->filehdr, l->phdrs, c, secs))
-	einfo (_("%F%P: bfd_record_phdr failed: %E\n"));
+	fatal (_("%P: bfd_record_phdr failed: %E\n"));
     }
 
   free (secs);
diff --git a/ld/ldlex.l b/ld/ldlex.l
index 0fcbe84c8b5..a581f76034c 100644
--- a/ld/ldlex.l
+++ b/ld/ldlex.l
@@ -492,9 +492,7 @@ void
 lex_push_file (FILE *file, const char *name, unsigned int sysrooted)
 {
   if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
-    {
-      einfo (_("%F:includes nested too deeply\n"));
-    }
+    fatal (_("%P: includes nested too deeply\n"));
   file_name_stack[include_stack_ptr] = name;
   lineno_stack[include_stack_ptr] = lineno;
   sysrooted_stack[include_stack_ptr] = input_flags.sysrooted;
@@ -557,9 +555,7 @@ lex_redirect (const char *string, const char *fake_filename, unsigned int count)
 
   yy_init = 0;
   if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
-    {
-      einfo (_("%F: macros nested too deeply\n"));
-    }
+    fatal (_("%P: macros nested too deeply\n"));
   file_name_stack[include_stack_ptr] = fake_filename;
   lineno_stack[include_stack_ptr] = lineno;
   include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;
@@ -660,7 +656,7 @@ yy_input (char *buf, int max_size)
 	{
 	  result = fread (buf, 1, max_size, yyin);
 	  if (result < max_size && ferror (yyin))
-	    einfo (_("%F%P: read in flex scanner failed\n"));
+	    fatal (_("%P: read in flex scanner failed\n"));
 	}
     }
   return result;
@@ -697,7 +693,7 @@ comment (void)
 
       if (c == 0)
 	{
-	  einfo (_("%F%P: EOF in comment\n"));
+	  fatal (_("%P: EOF in comment\n"));
 	  break;
 	}
     }
@@ -718,7 +714,7 @@ lex_warn_invalid (char *where, char *what)
   if (ldfile_assumed_script)
     {
       bfd_set_error (bfd_error_file_not_recognized);
-      einfo (_("%F%s: file not recognized: %E\n"), ldlex_filename ());
+      fatal (_("%s: file not recognized: %E\n"), ldlex_filename ());
     }
 
   if (! ISPRINT (*what))
diff --git a/ld/ldmain.c b/ld/ldmain.c
index 95b56b2d2d1..29c1cc40ddb 100644
--- a/ld/ldmain.c
+++ b/ld/ldmain.c
@@ -213,7 +213,7 @@ main (int argc, char **argv)
   expandargv (&argc, &argv);
 
   if (bfd_init () != BFD_INIT_MAGIC)
-    einfo (_("%F%P: fatal error: libbfd ABI mismatch\n"));
+    fatal (_("%P: fatal error: libbfd ABI mismatch\n"));
 
   bfd_set_error_program_name (program_name);
 
@@ -410,13 +410,13 @@ main (int argc, char **argv)
     xexit (0);
 
   if (link_info.inhibit_common_definition && !bfd_link_dll (&link_info))
-    einfo (_("%F%P: --no-define-common may not be used without -shared\n"));
+    fatal (_("%P: --no-define-common may not be used without -shared\n"));
 
   if (!lang_has_input_file)
     {
       if (version_printed || command_line.print_output_format)
 	xexit (0);
-      einfo (_("%F%P: no input files\n"));
+      fatal (_("%P: no input files\n"));
     }
 
   if (verbose)
@@ -436,7 +436,7 @@ main (int argc, char **argv)
 	  if (config.map_file == (FILE *) NULL)
 	    {
 	      bfd_set_error (bfd_error_system_call);
-	      einfo (_("%F%P: cannot open map file %s: %E\n"),
+	      einfo (_("%P: cannot open map file %s: %E\n"),
 		     config.map_filename);
 	    }
 	}
@@ -495,7 +495,7 @@ main (int argc, char **argv)
   else
     {
       if (!bfd_close (link_info.output_bfd))
-	einfo (_("%F%P: %pB: final close failed: %E\n"), link_info.output_bfd);
+	fatal (_("%P: %pB: final close failed: %E\n"), link_info.output_bfd);
 
       /* If the --force-exe-suffix is enabled, and we're making an
 	 executable file and it doesn't end in .exe, copy it to one
@@ -522,10 +522,10 @@ main (int argc, char **argv)
 	      dst = fopen (dst_name, FOPEN_WB);
 
 	      if (!src)
-		einfo (_("%F%P: unable to open for source of copy `%s'\n"),
+		fatal (_("%P: unable to open for source of copy `%s'\n"),
 		       output_filename);
 	      if (!dst)
-		einfo (_("%F%P: unable to open for destination of copy `%s'\n"),
+		fatal (_("%P: unable to open for destination of copy `%s'\n"),
 		       dst_name);
 	      while ((l = fread (buf, 1, bsize, src)) > 0)
 		{
@@ -638,7 +638,7 @@ get_emulation (int argc, char **argv)
 		  i++;
 		}
 	      else
-		einfo (_("%F%P: missing argument to -m\n"));
+		fatal (_("%P: missing argument to -m\n"));
 	    }
 	  else if (strcmp (argv[i], "-mips1") == 0
 		   || strcmp (argv[i], "-mips2") == 0
@@ -688,11 +688,11 @@ add_ysym (const char *name)
 				  bfd_hash_newfunc,
 				  sizeof (struct bfd_hash_entry),
 				  61))
-	einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
+	fatal (_("%P: bfd_hash_table_init failed: %E\n"));
     }
 
   if (bfd_hash_lookup (link_info.notice_hash, name, TRUE, TRUE) == NULL)
-    einfo (_("%F%P: bfd_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_hash_lookup failed: %E\n"));
 }
 
 void
@@ -705,11 +705,11 @@ add_ignoresym (struct bfd_link_info *info, const char *name)
 				  bfd_hash_newfunc,
 				  sizeof (struct bfd_hash_entry),
 				  61))
-	einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
+	fatal (_("%P: bfd_hash_table_init failed: %E\n"));
     }
 
   if (bfd_hash_lookup (info->ignore_hash, name, TRUE, TRUE) == NULL)
-    einfo (_("%F%P: bfd_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_hash_lookup failed: %E\n"));
 }
 
 /* Record a symbol to be wrapped, from the --wrap option.  */
@@ -725,11 +725,11 @@ add_wrap (const char *name)
 				  bfd_hash_newfunc,
 				  sizeof (struct bfd_hash_entry),
 				  61))
-	einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
+	fatal (_("%P: bfd_hash_table_init failed: %E\n"));
     }
 
   if (bfd_hash_lookup (link_info.wrap_hash, name, TRUE, TRUE) == NULL)
-    einfo (_("%F%P: bfd_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_hash_lookup failed: %E\n"));
 }
 
 /* Handle the -retain-symbols-file option.  */
@@ -757,7 +757,7 @@ add_keepsyms_file (const char *filename)
       xmalloc (sizeof (struct bfd_hash_table));
   if (!bfd_hash_table_init (link_info.keep_hash, bfd_hash_newfunc,
 			    sizeof (struct bfd_hash_entry)))
-    einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
+    fatal (_("%P: bfd_hash_table_init failed: %E\n"));
 
   bufsize = 100;
   buf = (char *) xmalloc (bufsize);
@@ -787,7 +787,7 @@ add_keepsyms_file (const char *filename)
 	  buf[len] = '\0';
 
 	  if (bfd_hash_lookup (link_info.keep_hash, buf, TRUE, TRUE) == NULL)
-	    einfo (_("%F%P: bfd_hash_lookup for insertion failed: %E\n"));
+	    fatal (_("%P: bfd_hash_lookup for insertion failed: %E\n"));
 	}
     }
 
@@ -1181,7 +1181,7 @@ constructor_callback (struct bfd_link_info *info,
   if (bfd_reloc_type_lookup (info->output_bfd, BFD_RELOC_CTOR) == NULL
       && (bfd_link_relocatable (info)
 	  || bfd_reloc_type_lookup (abfd, BFD_RELOC_CTOR) == NULL))
-    einfo (_("%F%P: BFD backend error: BFD_RELOC_CTOR unsupported\n"));
+    fatal (_("%P: BFD backend error: BFD_RELOC_CTOR unsupported\n"));
 
   s = set_name;
   if (bfd_get_symbol_leading_char (abfd) != '\0')
@@ -1193,7 +1193,7 @@ constructor_callback (struct bfd_link_info *info,
 
   h = bfd_link_hash_lookup (info->hash, set_name, TRUE, TRUE, TRUE);
   if (h == (struct bfd_link_hash_entry *) NULL)
-    einfo (_("%F%P: bfd_link_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_link_hash_lookup failed: %E\n"));
   if (h->type == bfd_link_hash_new)
     {
       h->type = bfd_link_hash_undefined;
@@ -1226,7 +1226,7 @@ symbol_warning (const char *warning, const char *symbol, bfd *abfd)
   struct warning_callback_info cinfo;
 
   if (!bfd_generic_link_read_symbols (abfd))
-    einfo (_("%F%P: %pB: could not read symbols: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read symbols: %E\n"), abfd);
 
   cinfo.found = FALSE;
   cinfo.warning = warning;
@@ -1288,14 +1288,14 @@ warning_find_reloc (bfd *abfd, asection *sec, void *iarg)
 
   relsize = bfd_get_reloc_upper_bound (abfd, sec);
   if (relsize < 0)
-    einfo (_("%F%P: %pB: could not read relocs: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read relocs: %E\n"), abfd);
   if (relsize == 0)
     return;
 
   relpp = (arelent **) xmalloc (relsize);
   relcount = bfd_canonicalize_reloc (abfd, sec, relpp, info->asymbols);
   if (relcount < 0)
-    einfo (_("%F%P: %pB: could not read relocs: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read relocs: %E\n"), abfd);
 
   p = relpp;
   pend = p + relcount;
diff --git a/ld/ldmisc.c b/ld/ldmisc.c
index b714b971053..0a5919341fe 100644
--- a/ld/ldmisc.c
+++ b/ld/ldmisc.c
@@ -67,7 +67,7 @@
 void
 vfinfo (FILE *fp, const char *fmt, va_list ap, bfd_boolean is_warning)
 {
-  bfd_boolean fatal = FALSE;
+  bfd_boolean isfatal = FALSE;
   const char *scan;
   int arg_type;
   unsigned int arg_count = 0;
@@ -290,7 +290,7 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bfd_boolean is_warning)
 
 	    case 'F':
 	      /* Error is fatal.  */
-	      fatal = TRUE;
+	      isfatal = TRUE;
 	      break;
 
 	    case 'P':
@@ -332,7 +332,7 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bfd_boolean is_warning)
 		if (abfd != NULL)
 		  {
 		    if (!bfd_generic_link_read_symbols (abfd))
-		      einfo (_("%F%P: %pB: could not read symbols: %E\n"), abfd);
+		      fatal (_("%P: %pB: could not read symbols: %E\n"), abfd);
 
 		    asymbols = bfd_get_outsymbols (abfd);
 		  }
@@ -586,7 +586,7 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bfd_boolean is_warning)
   if (is_warning && config.fatal_warnings)
     config.make_executable = FALSE;
 
-  if (fatal)
+  if (isfatal)
     xexit (1);
 }
 
@@ -619,10 +619,25 @@ einfo (const char *fmt, ...)
   fflush (stderr);
 }
 
+/* Fatal error.  */
+
+void
+fatal (const char *fmt, ...)
+{
+  va_list arg;
+
+  fflush (stdout);
+  va_start (arg, fmt);
+  vfinfo (stderr, fmt, arg, TRUE);
+  va_end (arg);
+  fflush (stderr);
+  xexit (1);
+}
+
 void
 info_assert (const char *file, unsigned int line)
 {
-  einfo (_("%F%P: internal error %s %d\n"), file, line);
+  fatal (_("%P: internal error %s %d\n"), file, line);
 }
 
 /* ('m' for map) Format info message and print on map.  */
@@ -691,6 +706,5 @@ ld_abort (const char *file, int line, const char *fn)
   else
     einfo (_("%P: internal error: aborting at %s:%d\n"),
 	   file, line);
-  einfo (_("%F%P: please report this bug\n"));
-  xexit (1);
+  fatal (_("%P: please report this bug\n"));
 }
diff --git a/ld/ldmisc.h b/ld/ldmisc.h
index 747bfbb8fba..db41c1122fd 100644
--- a/ld/ldmisc.h
+++ b/ld/ldmisc.h
@@ -23,6 +23,7 @@
 
 extern void vfinfo (FILE *fp, const char *fmt, va_list arg, bfd_boolean is_warning);
 extern void einfo (const char *, ...);
+extern void fatal (const char *, ...) ATTRIBUTE_NORETURN;
 extern void minfo (const char *, ...);
 extern void info_msg (const char *, ...);
 extern void lfinfo (FILE *, const char *, ...);
diff --git a/ld/ldwrite.c b/ld/ldwrite.c
index 5624dfdf4c0..2d310af6606 100644
--- a/ld/ldwrite.c
+++ b/ld/ldwrite.c
@@ -57,7 +57,7 @@ build_link_order (lang_statement_union_type *statement)
 
 	link_order = bfd_new_link_order (link_info.output_bfd, output_section);
 	if (link_order == NULL)
-	  einfo (_("%F%P: bfd_new_link_order failed\n"));
+	  fatal (_("%P: bfd_new_link_order failed: %E\n"));
 
 	link_order->type = bfd_data_link_order;
 	link_order->offset = statement->data_statement.output_offset;
@@ -167,7 +167,7 @@ build_link_order (lang_statement_union_type *statement)
 
 	link_order = bfd_new_link_order (link_info.output_bfd, output_section);
 	if (link_order == NULL)
-	  einfo (_("%F%P: bfd_new_link_order failed\n"));
+	  fatal (_("%P: bfd_new_link_order failed: %E\n"));
 
 	link_order->offset = rs->output_offset;
 	link_order->size = bfd_get_reloc_size (rs->howto);
@@ -219,7 +219,7 @@ build_link_order (lang_statement_union_type *statement)
 	    link_order = bfd_new_link_order (link_info.output_bfd,
 					     output_section);
 	    if (link_order == NULL)
-	      einfo (_("%F%P: bfd_new_link_order failed\n"));
+	      fatal (_("%P: bfd_new_link_order failed\n"));
 
 	    if ((i->flags & SEC_NEVER_LOAD) != 0
 		&& (i->flags & SEC_DEBUGGING) == 0)
@@ -260,7 +260,7 @@ build_link_order (lang_statement_union_type *statement)
 	link_order = bfd_new_link_order (link_info.output_bfd,
 					 output_section);
 	if (link_order == NULL)
-	  einfo (_("%F%P: bfd_new_link_order failed\n"));
+	  fatal (_("%P: bfd_new_link_order failed\n"));
 	link_order->type = bfd_data_link_order;
 	link_order->size = statement->padding_statement.size;
 	link_order->offset = statement->padding_statement.output_offset;
@@ -329,8 +329,7 @@ clone_section (bfd *abfd, asection *s, const char *name, int *count)
       if (CONST_STRNEQ (name, ".stab")
 	  || strcmp (name, "$GDB_SYMBOLS$") == 0)
 	{
-	  einfo (_ ("%F%P: cannot create split section name for %s\n"), name);
-	  /* Silence gcc warnings.  einfo exits, so we never reach here.  */
+	  fatal (_ ("%P: cannot create split section name for %s\n"), name);
 	  return NULL;
 	}
       tname[5] = 0;
@@ -341,8 +340,7 @@ clone_section (bfd *abfd, asection *s, const char *name, int *count)
       || (h = bfd_link_hash_lookup (link_info.hash,
 				    sname, TRUE, TRUE, FALSE)) == NULL)
     {
-      einfo (_("%F%P: clone section failed: %E\n"));
-      /* Silence gcc warnings.  einfo exits, so we never reach here.  */
+      fatal (_("%P: clone section failed: %E\n"));
       return NULL;
     }
   free (tname);
@@ -549,8 +547,8 @@ ldwrite (void)
 	 out.  */
 
       if (bfd_get_error () != bfd_error_no_error)
-	einfo (_("%F%P: final link failed: %E\n"));
+	fatal (_("%P: final link failed: %E\n"));
       else
-	xexit (1);
+	fatal (_("%P: final link failed\n"));
     }
 }
diff --git a/ld/lexsup.c b/ld/lexsup.c
index 64788214435..1e5270ff1ad 100644
--- a/ld/lexsup.c
+++ b/ld/lexsup.c
@@ -744,7 +744,7 @@ parse_args (unsigned argc, char **argv)
 	  /* Fall through.  */
 
 	default:
-	  einfo (_("%F%P: use the --help option for usage information\n"));
+	  fatal (_("%P: use the --help option for usage information\n"));
 	  break;
 
 	case 1:			/* File name.  */
@@ -763,7 +763,7 @@ parse_args (unsigned argc, char **argv)
 		   || strcmp (optarg, "default") == 0)
 	    input_flags.dynamic = TRUE;
 	  else
-	    einfo (_("%F%P: unrecognized -a option `%s'\n"), optarg);
+	    fatal (_("%P: unrecognized -a option `%s'\n"), optarg);
 	  break;
 	case OPTION_ASSERT:
 	  /* FIXME: We just ignore these, but we should handle them.  */
@@ -776,7 +776,7 @@ parse_args (unsigned argc, char **argv)
 	  else if (strcmp (optarg, "pure-text") == 0)
 	    ;
 	  else
-	    einfo (_("%F%P: unrecognized -assert option `%s'\n"), optarg);
+	    fatal (_("%P: unrecognized -assert option `%s'\n"), optarg);
 	  break;
 	case 'A':
 	  ldfile_add_arch (optarg);
@@ -820,8 +820,7 @@ parse_args (unsigned argc, char **argv)
 
 	      style = cplus_demangle_name_to_style (optarg);
 	      if (style == unknown_demangling)
-		einfo (_("%F%P: unknown demangling style `%s'\n"),
-		       optarg);
+		fatal (_("%P: unknown demangling style `%s'\n"), optarg);
 
 	      cplus_demangle_set_style (style);
 	    }
@@ -890,7 +889,7 @@ parse_args (unsigned argc, char **argv)
 	    char *end;
 	    g_switch_value = strtoul (optarg, &end, 0);
 	    if (*end)
-	      einfo (_("%F%P: invalid number `%s'\n"), optarg);
+	      fatal (_("%P: invalid number `%s'\n"), optarg);
 	  }
 	  break;
 	case 'g':
@@ -991,7 +990,7 @@ parse_args (unsigned argc, char **argv)
 	      link_info.unresolved_syms_in_shared_libs = RM_IGNORE;
 	    }
 	  else
-	    einfo (_("%F%P: bad --unresolved-symbols option: %s\n"), optarg);
+	    fatal (_("%P: bad --unresolved-symbols option: %s\n"), optarg);
 	  break;
 	case OPTION_WARN_UNRESOLVED_SYMBOLS:
 	  how_to_report_unresolved_symbols = RM_GENERATE_WARNING;
@@ -1068,7 +1067,7 @@ parse_args (unsigned argc, char **argv)
 	  break;
 	case OPTION_PLUGIN_OPT:
 	  if (plugin_opt_plugin_arg (optarg))
-	    einfo (_("%F%P: bad -plugin-opt option\n"));
+	    fatal (_("%P: bad -plugin-opt option\n"));
 	  break;
 #endif /* ENABLE_PLUGINS */
 	case 'q':
@@ -1085,11 +1084,11 @@ parse_args (unsigned argc, char **argv)
 	       an error message here.  We cannot just make this a warning,
 	       increment optind, and continue because getopt is too confused
 	       and will seg-fault the next time around.  */
-	    einfo(_("%F%P: unrecognised option: %s\n"), argv[optind]);
+	    fatal(_("%P: unrecognised option: %s\n"), argv[optind]);
 
 	  if (bfd_link_pic (&link_info))
-	    einfo (_("%F%P: -r and %s may not be used together\n"),
-		     bfd_link_dll (&link_info) ? "-shared" : "-pie");
+	    fatal (_("%P: -r and %s may not be used together\n"),
+		   bfd_link_dll (&link_info) ? "-shared" : "-pie");
 
 	  link_info.type = type_relocatable;
 	  config.build_constructors = FALSE;
@@ -1198,7 +1197,7 @@ parse_args (unsigned argc, char **argv)
 	  if (config.has_shared)
 	    {
 	      if (bfd_link_relocatable (&link_info))
-		einfo (_("%F%P: -r and %s may not be used together\n"),
+		fatal (_("%P: -r and %s may not be used together\n"),
 		       "-shared");
 
 	      link_info.type = type_dll;
@@ -1210,18 +1209,18 @@ parse_args (unsigned argc, char **argv)
 		link_info.unresolved_syms_in_shared_libs = RM_IGNORE;
 	    }
 	  else
-	    einfo (_("%F%P: -shared not supported\n"));
+	    fatal (_("%P: -shared not supported\n"));
 	  break;
 	case OPTION_PIE:
 	  if (config.has_shared)
 	    {
 	      if (bfd_link_relocatable (&link_info))
-		einfo (_("%F%P: -r and %s may not be used together\n"), "-pie");
+		fatal (_("%P: -r and %s may not be used together\n"), "-pie");
 
 	      link_info.type = type_pie;
 	    }
 	  else
-	    einfo (_("%F%P: -pie not supported\n"));
+	    fatal (_("%P: -pie not supported\n"));
 	  break;
 	case 'h':		/* Used on Solaris.  */
 	case OPTION_SONAME:
@@ -1238,7 +1237,7 @@ parse_args (unsigned argc, char **argv)
 	  else if (strcmp (optarg, N_("ascending")) == 0)
 	    config.sort_common = sort_ascending;
 	  else
-	    einfo (_("%F%P: invalid common section sorting option: %s\n"),
+	    fatal (_("%P: invalid common section sorting option: %s\n"),
 		   optarg);
 	  break;
 	case OPTION_SORT_SECTION:
@@ -1247,7 +1246,7 @@ parse_args (unsigned argc, char **argv)
 	  else if (strcmp (optarg, N_("alignment")) == 0)
 	    sort_section = by_alignment;
 	  else
-	    einfo (_("%F%P: invalid section sorting option: %s\n"),
+	    fatal (_("%P: invalid section sorting option: %s\n"),
 		   optarg);
 	  break;
 	case OPTION_STATS:
@@ -1281,14 +1280,14 @@ parse_args (unsigned argc, char **argv)
 	    /* Check for <something>=<somthing>...  */
 	    optarg2 = strchr (optarg, '=');
 	    if (optarg2 == NULL)
-	      einfo (_("%F%P: invalid argument to option"
+	      fatal (_("%P: invalid argument to option"
 		       " \"--section-start\"\n"));
 
 	    optarg2++;
 
 	    /* So far so good.  Are all the args present?  */
 	    if ((*optarg == '\0') || (*optarg2 == '\0'))
-	      einfo (_("%F%P: missing argument(s) to option"
+	      fatal (_("%P: missing argument(s) to option"
 		       " \"--section-start\"\n"));
 
 	    /* We must copy the section name as set_section_start
@@ -1332,8 +1331,8 @@ parse_args (unsigned argc, char **argv)
 	  /* Fall through.  */
 	case OPTION_UR:
 	  if (bfd_link_pic (&link_info))
-	    einfo (_("%F%P: -r and %s may not be used together\n"),
-		     bfd_link_dll (&link_info) ? "-shared" : "-pie");
+	    fatal (_("%P: -r and %s may not be used together\n"),
+		   bfd_link_dll (&link_info) ? "-shared" : "-pie");
 
 	  link_info.type = type_relocatable;
 	  config.build_constructors = TRUE;
@@ -1363,7 +1362,7 @@ parse_args (unsigned argc, char **argv)
 	      char *end;
 	      int level ATTRIBUTE_UNUSED = strtoul (optarg, &end, 0);
 	      if (*end)
-		einfo (_("%F%P: invalid number `%s'\n"), optarg);
+		fatal (_("%P: invalid number `%s'\n"), optarg);
 #ifdef ENABLE_PLUGINS
 	      report_plugin_symbols = level > 1;
 #endif /* ENABLE_PLUGINS */
@@ -1538,7 +1537,7 @@ parse_args (unsigned argc, char **argv)
 	  break;
 	case ')':
 	  if (! ingroup)
-	    einfo (_("%F%P: group ended before it began (--help for usage)\n"));
+	    fatal (_("%P: group ended before it began (--help for usage)\n"));
 
 	  lang_leave_group ();
 	  ingroup--;
@@ -1578,7 +1577,7 @@ parse_args (unsigned argc, char **argv)
 
 	case OPTION_POP_STATE:
 	  if (input_flags.pushed == NULL)
-	    einfo (_("%F%P: no state pushed before popping\n"));
+	    fatal (_("%P: no state pushed before popping\n"));
 	  else
 	    {
 	      struct lang_input_statement_flags *oldp = input_flags.pushed;
@@ -1601,7 +1600,7 @@ parse_args (unsigned argc, char **argv)
 	  else if (strcasecmp (optarg, "discard") == 0)
 	    config.orphan_handling = orphan_handling_discard;
 	  else
-	    einfo (_("%F%P: invalid argument to option"
+	    fatal (_("%P: invalid argument to option"
 		     " \"--orphan-handling\"\n"));
 	  break;
 
@@ -1695,9 +1694,9 @@ parse_args (unsigned argc, char **argv)
   if (!bfd_link_dll (&link_info))
     {
       if (command_line.filter_shlib)
-	einfo (_("%F%P: -F may not be used without -shared\n"));
+	fatal (_("%P: -F may not be used without -shared\n"));
       if (command_line.auxiliary_filters)
-	einfo (_("%F%P: -f may not be used without -shared\n"));
+	fatal (_("%P: -f may not be used without -shared\n"));
     }
 
   /* Treat ld -r -s as ld -r -S -x (i.e., strip all local symbols).  I
@@ -1738,7 +1737,7 @@ set_section_start (char *sect, char *valstr)
   const char *end;
   bfd_vma val = bfd_scan_vma (valstr, &end, 16);
   if (*end)
-    einfo (_("%F%P: invalid hex number `%s'\n"), valstr);
+    fatal (_("%P: invalid hex number `%s'\n"), valstr);
   lang_section_start (sect, exp_intop (val), NULL);
 }
 
@@ -1751,7 +1750,7 @@ set_segment_start (const char *section, char *valstr)
 
   bfd_vma val = bfd_scan_vma (valstr, &end, 16);
   if (*end)
-    einfo (_("%F%P: invalid hex number `%s'\n"), valstr);
+    fatal (_("%P: invalid hex number `%s'\n"), valstr);
   /* If we already have an entry for this segment, update the existing
      value.  */
   name = section + 1;
diff --git a/ld/mri.c b/ld/mri.c
index e5c379c8b60..70a8630cc5e 100644
--- a/ld/mri.c
+++ b/ld/mri.c
@@ -288,7 +288,7 @@ mri_format (const char *name)
     lang_add_output_format ("srec", NULL, NULL, 1);
 
   else
-    einfo (_("%F%P: unknown format type %s\n"), name);
+    fatal (_("%P: unknown format type %s\n"), name);
 }
 
 void
diff --git a/ld/pe-dll.c b/ld/pe-dll.c
index 397af8780e4..267891f1528 100644
--- a/ld/pe-dll.c
+++ b/ld/pe-dll.c
@@ -723,7 +723,7 @@ process_def_file_and_drectve (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *
 
 	  if (!bfd_generic_link_read_symbols (b))
 	    {
-	      einfo (_("%F%P: %pB: could not read symbols: %E\n"), b);
+	      fatal (_("%P: %pB: could not read symbols: %E\n"), b);
 	      return;
 	    }
 
@@ -1017,7 +1017,7 @@ build_filler_bfd (int include_edata)
 			     bfd_get_arch (link_info.output_bfd),
 			     bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -1302,7 +1302,7 @@ pe_walk_relocs (struct bfd_link_info *info,
 
       if (!bfd_generic_link_read_symbols (b))
 	{
-	  einfo (_("%F%P: %pB: could not read symbols: %E\n"), b);
+	  fatal (_("%P: %pB: could not read symbols: %E\n"), b);
 	  return;
 	}
 
@@ -1383,7 +1383,7 @@ pe_find_data_imports (const char *symhead,
       if (!bfd_hash_table_init (import_hash,
 				bfd_hash_newfunc,
 				sizeof (struct bfd_hash_entry)))
-	einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
+	fatal (_("%P: bfd_hash_table_init failed: %E\n"));
     }
   else
     import_hash = NULL;
@@ -1423,7 +1423,7 @@ pe_find_data_imports (const char *symhead,
 
 		if (!bfd_generic_link_read_symbols (b))
 		  {
-		    einfo (_("%F%P: %pB: could not read symbols: %E\n"), b);
+		    fatal (_("%P: %pB: could not read symbols: %E\n"), b);
 		    return;
 		  }
 
@@ -1546,7 +1546,7 @@ generate_reloc (bfd *abfd, struct bfd_link_info *info)
 
 	  if (!bfd_generic_link_read_symbols (b))
 	    {
-	      einfo (_("%F%P: %pB: could not read symbols: %E\n"), b);
+	      fatal (_("%P: %pB: could not read symbols: %E\n"), b);
 	      return;
 	    }
 
diff --git a/ld/plugin.c b/ld/plugin.c
index f8d3ec8e8b2..2d773428a4a 100644
--- a/ld/plugin.c
+++ b/ld/plugin.c
@@ -244,7 +244,7 @@ plugin_opt_plugin (const char *plugin)
   newplug->name = plugin;
   newplug->dlhandle = dlopen (plugin, RTLD_NOW);
   if (!newplug->dlhandle)
-    einfo (_("%F%P: %s: error loading plugin: %s\n"), plugin, dlerror ());
+    fatal (_("%P: %s: error loading plugin: %s\n"), plugin, dlerror ());
 
   /* Check if plugin has been loaded already.  */
   while (curplug)
@@ -337,7 +337,7 @@ plugin_get_ir_dummy_bfd (const char *name, bfd *srctemplate)
 	}
     }
 report_error:
-  einfo (_("%F%P: could not create dummy IR bfd: %E\n"));
+  fatal (_("%P: could not create dummy IR bfd: %E\n"));
   return NULL;
 }
 
@@ -418,7 +418,7 @@ asymbol_from_plugin_symbol (bfd *abfd, asymbol *asym,
       unsigned char visibility;
 
       if (!elfsym)
-	einfo (_("%F%P: %s: non-ELF symbol in ELF BFD!\n"), asym->name);
+	fatal (_("%P: %s: non-ELF symbol in ELF BFD!\n"), asym->name);
 
       if (ldsym->def == LDPK_COMMON)
 	{
@@ -429,7 +429,7 @@ asymbol_from_plugin_symbol (bfd *abfd, asymbol *asym,
       switch (ldsym->visibility)
 	{
 	default:
-	  einfo (_("%F%P: unknown ELF symbol visibility: %d!\n"),
+	  fatal (_("%P: unknown ELF symbol visibility: %d!\n"),
 		 ldsym->visibility);
 	  return LDPS_ERR;
 
@@ -538,7 +538,7 @@ get_view (const void *handle, const void **viewp)
 
   /* FIXME: einfo should support %lld.  */
   if ((off_t) size != input->filesize)
-    einfo (_("%F%P: unsupported input file size: %s (%ld bytes)\n"),
+    fatal (_("%P: unsupported input file size: %s (%ld bytes)\n"),
 	   input->name, (long) input->filesize);
 
   /* Check the cached view buffer.  */
@@ -801,7 +801,7 @@ get_symbols (const void *handle, int nsyms, struct ld_plugin_symbol *syms,
 	  && blhe->type != bfd_link_hash_common)
 	{
 	  /* We should not have a new, indirect or warning symbol here.  */
-	  einfo (_("%F%P: %s: plugin symbol table corrupt (sym type %d)\n"),
+	  fatal (_("%P: %s: plugin symbol table corrupt (sym type %d)\n"),
 		 called_plugin->name, blhe->type);
 	}
 
@@ -950,13 +950,14 @@ message (int level, const char *format, ...)
     case LDPL_ERROR:
     default:
       {
-	char *newfmt = concat (level == LDPL_FATAL ? "%F" : "%X",
-			       _("%P: error: "), format, "\n",
+	char *newfmt = concat (_("%X%P: error: "), format, "\n",
 			       (const char *) NULL);
 	fflush (stdout);
 	vfinfo (stderr, newfmt, args, TRUE);
 	fflush (stderr);
 	free (newfmt);
+	if (level == LDPL_FATAL)
+	  fatal ("");
       }
       break;
     }
@@ -1096,14 +1097,14 @@ plugin_load_plugins (void)
       if (!onloadfn)
 	onloadfn = (ld_plugin_onload) dlsym (curplug->dlhandle, "_onload");
       if (!onloadfn)
-	einfo (_("%F%P: %s: error loading plugin: %s\n"),
+	fatal (_("%P: %s: error loading plugin: %s\n"),
 	       curplug->name, dlerror ());
       set_tv_plugin_args (curplug, &my_tv[tv_header_size]);
       called_plugin = curplug;
       rv = (*onloadfn) (my_tv);
       called_plugin = NULL;
       if (rv != LDPS_OK)
-	einfo (_("%F%P: %s: plugin error: %d\n"), curplug->name, rv);
+	fatal (_("%P: %s: plugin error: %d\n"), curplug->name, rv);
       curplug = curplug->next;
     }
 
@@ -1158,7 +1159,7 @@ plugin_strdup (bfd *abfd, const char *str)
   strlength = strlen (str) + 1;
   copy = bfd_alloc (abfd, strlength);
   if (copy == NULL)
-    einfo (_("%F%P: plugin_strdup failed to allocate memory: %s\n"),
+    fatal (_("%P: plugin_strdup failed to allocate memory: %s\n"),
 	   bfd_get_error ());
   memcpy (copy, str, strlength);
   return copy;
@@ -1190,7 +1191,7 @@ plugin_object_p (bfd *ibfd)
 
   input = bfd_alloc (abfd, sizeof (*input));
   if (input == NULL)
-    einfo (_("%F%P: plugin failed to allocate memory for input: %s\n"),
+    fatal (_("%P: plugin failed to allocate memory for input: %s\n"),
 	   bfd_get_error ());
 
   if (!bfd_plugin_open_input (ibfd, &file))
@@ -1217,7 +1218,7 @@ plugin_object_p (bfd *ibfd)
   claimed = 0;
 
   if (plugin_call_claim_file (&file, &claimed))
-    einfo (_("%F%P: %s: plugin reported error claiming file\n"),
+    fatal (_("%P: %s: plugin reported error claiming file\n"),
 	   plugin_error_plugin ());
 
   if (input->fd != -1 && !bfd_plugin_target_p (ibfd->xvec))
-- 
2.24.4

