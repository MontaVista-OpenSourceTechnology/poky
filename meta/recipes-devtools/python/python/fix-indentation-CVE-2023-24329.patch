From c5ed982acb28377f29f5fd83612535dc2eb337a1 Mon Sep 17 00:00:00 2001
From: Vivek Kumbhar <vkumbhar@mvista.com>
Date: Fri, 12 May 2023 06:48:55 +0000
Subject: [PATCH] fix indentation CVE-2023-24329

---
 Lib/lib2to3/pgen2/parse.py | 69 +++++++++++++++++++-------------------
 1 file changed, 35 insertions(+), 34 deletions(-)

diff --git a/Lib/lib2to3/pgen2/parse.py b/Lib/lib2to3/pgen2/parse.py
index 56f1569..8f5ba2b 100644
--- a/Lib/lib2to3/pgen2/parse.py
+++ b/Lib/lib2to3/pgen2/parse.py
@@ -13,6 +13,7 @@ how this parsing engine works.
 # Local imports
 from . import token
 
+
 class ParseError(Exception):
     """Exception to signal the parser is stuck."""
 
@@ -24,6 +25,7 @@ class ParseError(Exception):
         self.value = value
         self.context = context
 
+
 class Parser(object):
     """Parser engine.
 
@@ -108,7 +110,7 @@ class Parser(object):
         stackentry = (self.grammar.dfas[start], 0, newnode)
         self.stack = [stackentry]
         self.rootnode = None
-        self.used_names = set() # Aliased to self.rootnode.used_names in pop()
+        self.used_names = set()  # Aliased to self.rootnode.used_names in pop()
 
     def addtoken(self, type, value, context):
         """Add a token; return True iff this is the end of the program."""
@@ -145,7 +147,7 @@ class Parser(object):
                     if ilabel in itsfirst:
                         # Push a symbol
                         self.push(t, self.grammar.dfas[t], newstate, context)
-                        break # To continue the outer while loop
+                        break  # To continue the outer while loop
             else:
                 if (0, state) in arcs:
                     # An accepting state, pop it and try something else
@@ -204,47 +206,46 @@ class Parser(object):
 # comparison since this API supports both bytes and str input.
     @functools.lru_cache(typed=True)
     def urlsplit(url, scheme='', allow_fragments=True):
-    	"""Parse a URL into 5 components:
-    	<scheme>://<netloc>/<path>?<query>#<fragment>
-    	The result is a named 5-tuple with fields corresponding to the
-    	above. It is either a SplitResult or SplitResultBytes object,
-    	depending on the type of the url parameter.
-    	The username, password, hostname, and port sub-components of netloc
-    	can also be accessed as attributes of the returned object.
-    	The scheme argument provides the default value of the scheme
-    	component when no scheme is found in url.
-    	If allow_fragments is False, no attempt is made to separate the
-    	fragment component from the previous component, which can be either
-    	path or query.
-    	Note that % escapes are not expanded.
-    	"""
-
-    	url, scheme, _coerce_result = _coerce_args(url, scheme)
-
-    	for b in _UNSAFE_URL_BYTES_TO_REMOVE:
+        """Parse a URL into 5 components:
+        <scheme>://<netloc>/<path>?<query>#<fragment>
+        The result is a named 5-tuple with fields corresponding to the
+        above. It is either a SplitResult or SplitResultBytes object,
+        depending on the type of the url parameter.
+        The username, password, hostname, and port sub-components of netloc
+        can also be accessed as attributes of the returned object.
+        The scheme argument provides the default value of the scheme
+        component when no scheme is found in url.
+        If allow_fragments is False, no attempt is made to separate the
+        fragment component from the previous component, which can be either
+        path or query.
+        Note that % escapes are not expanded.
+        """
+
+        url, scheme, _coerce_result = _coerce_args(url, scheme)
+
+        for b in _UNSAFE_URL_BYTES_TO_REMOVE:
             url = url.replace(b, "")
             scheme = scheme.replace(b, "")
 
-    	allow_fragments = bool(allow_fragments)
-    	netloc = query = fragment = ''
-    	i = url.find(':')
-    	if i > 0 and url[0].isascii() and url[0].isalpha():
+        allow_fragments = bool(allow_fragments)
+        netloc = query = fragment = ''
+        i = url.find(':')
+        if i > 0 and url[0].isascii() and url[0].isalpha():
             for c in url[:i]:
                 if c not in scheme_chars:
                     break
             else:
                 scheme, url = url[:i].lower(), url[i+1:]
 
-    	if url[:2] == '//':
+        if url[:2] == '//':
             netloc, url = _splitnetloc(url, 2)
-        if (('[' in netloc and ']' not in netloc) or
-            	(']' in netloc and '[' not in netloc)):
-            raise ValueError("Invalid IPv6 URL")
-    	if allow_fragments and '#' in url:
+            if (('[' in netloc and ']' not in netloc) or
+                    (']' in netloc and '[' not in netloc)):
+                raise ValueError("Invalid IPv6 URL")
+        if allow_fragments and '#' in url:
             url, fragment = url.split('#', 1)
-    	if '?' in url:
+        if '?' in url:
             url, query = url.split('?', 1)
-    	_checknetloc(netloc)
-   	 v = SplitResult(scheme, netloc, url, query, fragment)
-   	 return _coerce_result(v)
-
+        _checknetloc(netloc)
+        v = SplitResult(scheme, netloc, url, query, fragment)
+        return _coerce_result(v)
-- 
2.18.2

