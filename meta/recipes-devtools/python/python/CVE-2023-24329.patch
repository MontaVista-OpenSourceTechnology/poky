From 8e168b81bb3cfb717f3fd185880f8c324238ba25 Mon Sep 17 00:00:00 2001
From: Vivek Kumbhar <vkumbhar@mvista.com>
Date: Thu, 27 Apr 2023 12:12:38 +0000
Subject: [PATCH] CVE-2023-24329

---
 Lib/lib2to3/pgen2/parse.py                    | 49 +++++++++++++++++++
 Lib/test/test_urlparse.py                     | 18 +++++++
 ...2-11-12-15-45-51.gh-issue-99418.FxfAXS.rst |  2 +
 3 files changed, 69 insertions(+)
 create mode 100644 Misc/NEWS.d/next/Library/2022-11-12-15-45-51.gh-issue-99418.FxfAXS.rst

diff --git a/Lib/lib2to3/pgen2/parse.py b/Lib/lib2to3/pgen2/parse.py
index 6bebdbb..56f1569 100644
--- a/Lib/lib2to3/pgen2/parse.py
+++ b/Lib/lib2to3/pgen2/parse.py
@@ -199,3 +199,52 @@ class Parser(object):
             else:
                 self.rootnode = newnode
                 self.rootnode.used_names = self.used_names
+
+# typed=True avoids BytesWarnings being emitted during cache key
+# comparison since this API supports both bytes and str input.
+    @functools.lru_cache(typed=True)
+    def urlsplit(url, scheme='', allow_fragments=True):
+    	"""Parse a URL into 5 components:
+    	<scheme>://<netloc>/<path>?<query>#<fragment>
+    	The result is a named 5-tuple with fields corresponding to the
+    	above. It is either a SplitResult or SplitResultBytes object,
+    	depending on the type of the url parameter.
+    	The username, password, hostname, and port sub-components of netloc
+    	can also be accessed as attributes of the returned object.
+    	The scheme argument provides the default value of the scheme
+    	component when no scheme is found in url.
+    	If allow_fragments is False, no attempt is made to separate the
+    	fragment component from the previous component, which can be either
+    	path or query.
+    	Note that % escapes are not expanded.
+    	"""
+
+    	url, scheme, _coerce_result = _coerce_args(url, scheme)
+
+    	for b in _UNSAFE_URL_BYTES_TO_REMOVE:
+            url = url.replace(b, "")
+            scheme = scheme.replace(b, "")
+
+    	allow_fragments = bool(allow_fragments)
+    	netloc = query = fragment = ''
+    	i = url.find(':')
+    	if i > 0 and url[0].isascii() and url[0].isalpha():
+            for c in url[:i]:
+                if c not in scheme_chars:
+                    break
+            else:
+                scheme, url = url[:i].lower(), url[i+1:]
+
+    	if url[:2] == '//':
+            netloc, url = _splitnetloc(url, 2)
+        if (('[' in netloc and ']' not in netloc) or
+            	(']' in netloc and '[' not in netloc)):
+            raise ValueError("Invalid IPv6 URL")
+    	if allow_fragments and '#' in url:
+            url, fragment = url.split('#', 1)
+    	if '?' in url:
+            url, query = url.split('?', 1)
+    	_checknetloc(netloc)
+   	 v = SplitResult(scheme, netloc, url, query, fragment)
+   	 return _coerce_result(v)
+
diff --git a/Lib/test/test_urlparse.py b/Lib/test/test_urlparse.py
index 86c4a05..e44e027 100644
--- a/Lib/test/test_urlparse.py
+++ b/Lib/test/test_urlparse.py
@@ -555,6 +555,24 @@ class UrlParseTestCase(unittest.TestCase):
         self.assertEqual(p.netloc, "www.example.net:foo")
         self.assertRaises(ValueError, lambda: p.port)

+    def test_attributes_bad_scheme(self):
+        """Check handling of invalid schemes."""
+        for bytes in (False, True):
+            for parse in (urllib.parse.urlsplit, urllib.parse.urlparse):
+                for scheme in (".", "+", "-", "0", "http&", "à¥¬http"):
+                    with self.subTest(bytes=bytes, parse=parse, scheme=scheme):
+                        url = scheme + "://www.example.net"
+                        if bytes:
+                            if url.isascii():
+                                url = url.encode("ascii")
+                            else:
+                                continue
+                        p = parse(url)
+                        if bytes:
+                            self.assertEqual(p.scheme, b"")
+                        else:
+                            self.assertEqual(p.scheme, "")
+
     def test_attributes_without_netloc(self):
         # This example is straight from RFC 3261.  It looks like it
         # should allow the username, hostname, and port to be filled
diff --git a/Misc/NEWS.d/next/Library/2022-11-12-15-45-51.gh-issue-99418.FxfAXS.rst b/Misc/NEWS.d/next/Library/2022-11-12-15-45-51.gh-issue-99418.FxfAXS.rst
new file mode 100644
index 0000000..0a06e7c
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2022-11-12-15-45-51.gh-issue-99418.FxfAXS.rst
@@ -0,0 +1,2 @@
+Fix bug in :func:`urllib.parse.urlparse` that causes URL schemes that begin
+with a digit, a plus sign, or a minus sign to be parsed incorrectly.
--
2.18.2
