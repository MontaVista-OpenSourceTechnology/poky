From c9a1e257f1630a0866447e53a564f7ff96a80ead Mon Sep 17 00:00:00 2001
From: Christian Brabandt <cb@256bit.org>
Date: Sat, 11 Jan 2025 15:25:00 +0100
Subject: [PATCH] patch 9.1.1003: [security]: heap-buffer-overflow with visual
 mode

Problem:  [security]: heap-buffer-overflow with visual mode when
          using :all, causing Vim trying to access beyond end-of-line
          (gandalf)
Solution: Reset visual mode on :all, validate position in gchar_pos()
          and charwise_block_prep()

This fixes CVE-2025-22134

Github Advisory:
https://github.com/vim/vim/security/advisories/GHSA-5rgf-26wj-48v8

Co-authored-by: zeertzjq <zeertzjq@outlook.com>
Signed-off-by: Christian Brabandt <cb@256bit.org>

Upstream-Status: Backport from [https://github.com/vim/vim/commit/c9a1e257f1630a0866447e53a564f7ff96a80ead]
CVE: CVE-2025-22134
Signed-off-by: Milan Satpathy <msatpathy@mvista.com>

---
 src/arglist.c               |  4 ++++
 src/memline.c               | 21 +++++++++++++++++++++
 src/misc1.c                 |  4 ++++
 src/proto/memline.pro       |  2 ++
 src/structs.h               |  1 +
 src/testdir/test_visual.vim | 29 ++++++++++++++++++++++++-----
 6 files changed, 56 insertions(+), 5 deletions(-)

diff --git a/src/arglist.c b/src/arglist.c
index 0bc390954..657674aff 100644
--- a/src/arglist.c
+++ b/src/arglist.c
@@ -1252,6 +1252,10 @@ do_arg_all(
 
     tabpage_T *new_lu_tp = curtab;
 
+    // Stop Visual mode, the cursor and "VIsual" may very well be invalid after
+    // switching to another buffer.
+    reset_VIsual_and_resel();
+
     // Try closing all windows that are not in the argument list.
     // Also close windows that are not full width;
     // When 'hidden' or "forceit" set the buffer becomes hidden.
diff --git a/src/memline.c b/src/memline.c
index cf2dc8c31..735e17af9 100644
--- a/src/memline.c
+++ b/src/memline.c
@@ -2675,6 +2675,27 @@ ml_get_cursor(void)
 							curwin->w_cursor.col);
 }
 
+// return length (excluding the NUL) of the given line
+    colnr_T
+ml_get_len(linenr_T lnum)
+{
+    return ml_get_buf_len(curbuf, lnum);
+}
+
+// return length (excluding the NUL) of the given line in the given buffer
+    colnr_T
+ml_get_buf_len(buf_T *buf, linenr_T lnum)
+{
+    char_u	*line;
+
+    if (*(line = ml_get_buf(buf, lnum, FALSE)) == NUL)
+	return 0;
+
+    if (buf->b_ml.ml_line_textlen <= 0)
+	buf->b_ml.ml_line_textlen = (int)STRLEN(line) + 1;
+    return buf->b_ml.ml_line_textlen - 1;
+}
+
 /*
  * Return a pointer to a line in a specific buffer
  *
diff --git a/src/misc1.c b/src/misc1.c
index bf70e3847..244206f9e 100644
--- a/src/misc1.c
+++ b/src/misc1.c
@@ -535,11 +535,15 @@ plines_m_win(win_T *wp, linenr_T first, linenr_T last, int limit_winheight)
 gchar_pos(pos_T *pos)
 {
     char_u	*ptr;
+    int		ptrlen;
 
     // When searching columns is sometimes put at the end of a line.
     if (pos->col == MAXCOL)
 	return NUL;
+    ptrlen = ml_get_len(pos->lnum);
     ptr = ml_get_pos(pos);
+    if (pos->col > ptrlen)
+	return NUL;
     if (has_mbyte)
 	return (*mb_ptr2char)(ptr);
     return (int)*ptr;
diff --git a/src/proto/memline.pro b/src/proto/memline.pro
index 3fa8707d8..ffb2786b5 100644
--- a/src/proto/memline.pro
+++ b/src/proto/memline.pro
@@ -19,6 +19,8 @@ char_u *ml_get(linenr_T lnum);
 char_u *ml_get_pos(pos_T *pos);
 char_u *ml_get_curline(void);
 char_u *ml_get_cursor(void);
+colnr_T ml_get_len(linenr_T lnum);
+colnr_T ml_get_buf_len(buf_T *buf, linenr_T lnum);
 char_u *ml_get_buf(buf_T *buf, linenr_T lnum, int will_change);
 int ml_line_alloced(void);
 int ml_append(linenr_T lnum, char_u *line, colnr_T len, int newfile);
diff --git a/src/structs.h b/src/structs.h
index 91f1d17a2..bc007f1d3 100644
--- a/src/structs.h
+++ b/src/structs.h
@@ -801,6 +801,7 @@ typedef struct memline
     int		ml_flags;
 
     colnr_T	ml_line_len;	// length of the cached line, including NUL
+    colnr_T	ml_line_textlen;// length of the cached line + NUL, 0 if not known yet
     linenr_T	ml_line_lnum;	// line number of cached line, 0 if not valid
     char_u	*ml_line_ptr;	// pointer to cached line
 
diff --git a/src/testdir/test_visual.vim b/src/testdir/test_visual.vim
index 401a3504a..ad77f7bcf 100644
--- a/src/testdir/test_visual.vim
+++ b/src/testdir/test_visual.vim
@@ -469,7 +469,7 @@ func Test_Visual_Block()
 	      \ "\t{",
 	      \ "\t}"], getline(1, '$'))
 
-  close!
+  bw!
 endfunc
 
 " Test for 'p'ut in visual block mode
@@ -1079,7 +1079,7 @@ func Test_star_register()
 
   delmarks < >
   call assert_fails('*yank', 'E20:')
-  close!
+  bw!
 endfunc
 
 " Test for changing text in visual mode with 'exclusive' selection
@@ -1095,7 +1095,7 @@ func Test_exclusive_selection()
   call assert_equal('l      one', getline(1))
   set virtualedit&
   set selection&
-  close!
+  bw!
 endfunc
 
 " Test for starting linewise visual with a count.
@@ -1148,11 +1148,11 @@ func Test_visual_inner_block()
   " try to select non-existing inner block
   call cursor(5, 1)
   call assert_beeps('normal ViBiBiB')
-  " try to select a unclosed inner block
+  " try to select an unclosed inner block
   8,9d
   call cursor(5, 1)
   call assert_beeps('normal ViBiB')
-  close!
+  bw!
 endfunc
 
 func Test_visual_put_in_block()
@@ -1622,4 +1622,23 @@ func Test_visual_drag_out_of_window()
   bwipe!
 endfunc
 
+" the following caused a Heap-Overflow, because Vim was accessing outside of a
+" line end
+func Test_visual_pos_buffer_heap_overflow()
+  set virtualedit=all
+  args Xa Xb
+  all
+  call setline(1, ['', '', ''])
+  call cursor(3, 1)
+  wincmd w
+  call setline(1, 'foobar')
+  normal! $lv0
+  all
+  call setreg('"', 'baz')
+  normal! [P
+  set virtualedit=
+  bw! Xa Xb
+endfunc
+
+
 " vim: shiftwidth=2 sts=2 expandtab
-- 
2.34.1

