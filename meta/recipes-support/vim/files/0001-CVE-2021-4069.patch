From a1b879d6d14c3623e994f97b4ab83629aba8a1e4 Mon Sep 17 00:00:00 2001
From: Hitendra Prajapati <hprajapati@mvista.com>
Date: Thu, 3 Feb 2022 09:50:26 +0530
Subject: [PATCH] CVE-2021-4069

Upstream-Status: Backport from https://github.com/vim/vim/commit/e031fe90cf2e375ce861ff5e5e281e4ad229ebb9

Signed-off-by: Hitendra Prajapati <hprajapati@mvista.com>
---
 src/ex_docmd.c               | 10 ++++--
 src/testdir/Make_all.mak     |  1 +
 src/testdir/test_alot.vim    |  1 +
 src/testdir/test_cmdline.vim | 47 +++++++++++++++++--------
 src/testdir/test_ex_mode.vim | 67 ++++++++++++++++++++++++++++++++++++
 src/version.c                |  2 ++
 6 files changed, 111 insertions(+), 17 deletions(-)
 create mode 100644 src/testdir/test_ex_mode.vim

diff --git a/src/ex_docmd.c b/src/ex_docmd.c
index 247d197e0..058366de3 100644
--- a/src/ex_docmd.c
+++ b/src/ex_docmd.c
@@ -6027,13 +6027,17 @@ ex_open(exarg_T *eap)
 	regmatch.regprog = vim_regcomp(eap->arg, p_magic ? RE_MAGIC : 0);
 	if (regmatch.regprog != NULL)
 	{
+	    // make a copy of the line, when searching for a mark it might be
+	    // flushed
+	    char_u *line = vim_strsave(ml_get_curline());
+
 	    regmatch.rm_ic = p_ic;
-	    p = ml_get_curline();
-	    if (vim_regexec(&regmatch, p, (colnr_T)0))
-		curwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);
+	    if (vim_regexec(&regmatch, line, (colnr_T)0))
+		curwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - line);
 	    else
 		emsg(_(e_nomatch));
 	    vim_regfree(regmatch.regprog);
+	    vim_free(line);
 	}
 	// Move to the NUL, ignore any other arguments.
 	eap->arg += STRLEN(eap->arg);
diff --git a/src/testdir/Make_all.mak b/src/testdir/Make_all.mak
index 665bcc776..05e7a2c80 100644
--- a/src/testdir/Make_all.mak
+++ b/src/testdir/Make_all.mak
@@ -102,6 +102,7 @@ NEW_TESTS = \
 	test_ex_equal \
 	test_ex_undo \
 	test_ex_z \
+	test_ex_mode \
 	test_excmd \
 	test_exec_while_if \
 	test_execute_func \
diff --git a/src/testdir/test_alot.vim b/src/testdir/test_alot.vim
index 894ec5848..25241b229 100644
--- a/src/testdir/test_alot.vim
+++ b/src/testdir/test_alot.vim
@@ -13,6 +13,7 @@ source test_delete.vim
 source test_ex_equal.vim
 source test_ex_undo.vim
 source test_ex_z.vim
+source test_ex_mode.vim
 source test_execute_func.vim
 source test_expand.vim
 source test_expand_dllpath.vim
diff --git a/src/testdir/test_cmdline.vim b/src/testdir/test_cmdline.vim
index 529795144..837ef63dd 100644
--- a/src/testdir/test_cmdline.vim
+++ b/src/testdir/test_cmdline.vim
@@ -419,7 +419,7 @@ func Test_expand_star_star()
   call delete('a', 'rf')
 endfunc
 
-func Test_paste_in_cmdline()
+func Test_cmdline_paste()
   let @a = "def"
   call feedkeys(":abc \<C-R>a ghi\<C-B>\"\<CR>", 'tx')
   call assert_equal('"abc def ghi', @:)
@@ -459,18 +459,37 @@ func Test_paste_in_cmdline()
   bwipe!
 endfunc
 
-func Test_remove_char_in_cmdline()
-  call feedkeys(":abc def\<S-Left>\<Del>\<C-B>\"\<CR>", 'tx')
-  call assert_equal('"abc ef', @:)
+func Test_cmdline_remove_char()
+  let encoding_save = &encoding
+
+  for e in ['utf8', 'latin1']
+    exe 'set encoding=' . e
+
+    call feedkeys(":abc def\<S-Left>\<Del>\<C-B>\"\<CR>", 'tx')
+    call assert_equal('"abc ef', @:, e)
+
+    call feedkeys(":abc def\<S-Left>\<BS>\<C-B>\"\<CR>", 'tx')
+    call assert_equal('"abcdef', @:)
+
+    call feedkeys(":abc def ghi\<S-Left>\<C-W>\<C-B>\"\<CR>", 'tx')
+    call assert_equal('"abc ghi', @:, e)
 
-  call feedkeys(":abc def\<S-Left>\<BS>\<C-B>\"\<CR>", 'tx')
-  call assert_equal('"abcdef', @:)
+    call feedkeys(":abc def\<S-Left>\<C-U>\<C-B>\"\<CR>", 'tx')
+    call assert_equal('"def', @:, e)
+  endfor
+
+  let &encoding = encoding_save
+endfunc
 
-  call feedkeys(":abc def ghi\<S-Left>\<C-W>\<C-B>\"\<CR>", 'tx')
-  call assert_equal('"abc ghi', @:)
+func Test_cmdline_keymap_ctrl_hat()
+  if !has('keymap')
+    return
+  endif
 
-  call feedkeys(":abc def\<S-Left>\<C-U>\<C-B>\"\<CR>", 'tx')
-  call assert_equal('"def', @:)
+  set keymap=esperanto
+  call feedkeys(":\"Jxauxdo \<C-^>Jxauxdo \<C-^>Jxauxdo\<CR>", 'tx')
+  call assert_equal('"Jxauxdo Ĵaŭdo Jxauxdo', @:)
+  set keymap=
 endfunc
 
 func Test_illegal_address1()
@@ -741,20 +760,20 @@ func Test_cmdline_overstrike()
 
     " Test overstrike in the middle of the command line.
     call feedkeys(":\"01234\<home>\<right>\<right>ab\<right>\<insert>cd\<enter>", 'xt')
-    call assert_equal('"0ab1cd4', @:)
+    call assert_equal('"0ab1cd4', @:, e)
 
     " Test overstrike going beyond end of command line.
     call feedkeys(":\"01234\<home>\<right>\<right>ab\<right>\<insert>cdefgh\<enter>", 'xt')
-    call assert_equal('"0ab1cdefgh', @:)
+    call assert_equal('"0ab1cdefgh', @:, e)
 
     " Test toggling insert/overstrike a few times.
     call feedkeys(":\"01234\<home>\<right>ab\<right>\<insert>cd\<right>\<insert>ef\<enter>", 'xt')
-    call assert_equal('"ab0cd3ef4', @:)
+    call assert_equal('"ab0cd3ef4', @:, e)
   endfor
 
   " Test overstrike with multi-byte characters.
   call feedkeys(":\"テキストエディタ\<home>\<right>\<right>ab\<right>\<insert>cd\<enter>", 'xt')
-  call assert_equal('"テabキcdエディタ', @:)
+  call assert_equal('"テabキcdエディタ', @:, e)
 
   let &encoding = encoding_save
 endfunc
diff --git a/src/testdir/test_ex_mode.vim b/src/testdir/test_ex_mode.vim
new file mode 100644
index 000000000..821a045f0
--- /dev/null
+++ b/src/testdir/test_ex_mode.vim
@@ -0,0 +1,67 @@
+" Test editing line in Ex mode (see :help Q and :help gQ).
+
+" Helper function to test editing line in Q Ex mode
+func Ex_Q(cmd)
+  " Is there a simpler way to test editing Ex line?
+  call feedkeys("Q"
+        \    .. "let s:test_ex =<< END\<CR>"
+        \    .. a:cmd .. "\<CR>"
+        \    .. "END\<CR>"
+        \    .. "visual\<CR>", 'tx')
+  return s:test_ex[0]
+endfunc
+
+" Helper function to test editing line in gQ Ex mode
+func Ex_gQ(cmd)
+  call feedkeys("gQ" .. a:cmd .. "\<C-b>\"\<CR>", 'tx')
+  let ret = @:[1:] " Remove leading quote.
+  call feedkeys("visual\<CR>", 'tx')
+  return ret
+endfunc
+
+" Helper function to test editing line with both Q and gQ Ex mode.
+func Ex(cmd)
+ return [Ex_Q(a:cmd), Ex_gQ(a:cmd)]
+endfunc
+
+" Test editing line in Ex mode (both Q and gQ)
+func Test_ex_mode()
+  let encoding_save = &encoding
+  set sw=2
+
+  for e in ['utf8', 'latin1']
+    exe 'set encoding=' . e
+
+    call assert_equal(['bar', 'bar'],             Ex("foo bar\<C-u>bar"), e)
+    call assert_equal(["1\<C-u>2", "1\<C-u>2"],   Ex("1\<C-v>\<C-u>2"), e)
+    call assert_equal(["1\<C-b>2\<C-e>3", '213'], Ex("1\<C-b>2\<C-e>3"), e)
+    call assert_equal(['0123', '2013'],           Ex("01\<Home>2\<End>3"), e)
+    call assert_equal(['0123', '0213'],           Ex("01\<Left>2\<Right>3"), e)
+    call assert_equal(['01234', '0342'],          Ex("012\<Left>\<Left>\<Insert>3\<Insert>4"), e)
+    call assert_equal(["foo bar\<C-w>", 'foo '],  Ex("foo bar\<C-w>"), e)
+    call assert_equal(['foo', 'foo'],             Ex("fooba\<Del>\<Del>"), e)
+    call assert_equal(["foo\tbar", 'foobar'],     Ex("foo\<Tab>bar"), e)
+    call assert_equal(["abbrev\t", 'abbreviate'], Ex("abbrev\<Tab>"), e)
+    call assert_equal(['    1', "1\<C-t>\<C-t>"], Ex("1\<C-t>\<C-t>"), e)
+    call assert_equal(['  1', "1\<C-t>\<C-t>"],   Ex("1\<C-t>\<C-t>\<C-d>"), e)
+    call assert_equal(['  foo', '    foo'],       Ex("    foo\<C-d>"), e)
+    call assert_equal(['foo', '    foo0'],        Ex("    foo0\<C-d>"), e)
+    call assert_equal(['foo', '    foo^'],        Ex("    foo^\<C-d>"), e)
+  endfor
+
+  set sw&
+  let &encoding = encoding_save
+endfunc
+
+func Test_open_command_flush_line()
+  " this was accessing freed memory: the regexp match uses a pointer to the
+  " current line which becomes invalid when searching for the ') mark.
+  new
+  call setline(1, ['one', 'two. three'])
+  s/one/ONE
+  try
+    open /\%')/
+  catch /E479/
+  endtry
+  bwipe!
+endfunc
diff --git a/src/version.c b/src/version.c
index c41956063..46a06a345 100644
--- a/src/version.c
+++ b/src/version.c
@@ -742,6 +742,8 @@ static char *(features[]) =
 
 static int included_patches[] =
 {   /* Add new patch number below this line */
+/**/
+    3411,
 /**/
     3410,
 /**/
-- 
2.25.1

