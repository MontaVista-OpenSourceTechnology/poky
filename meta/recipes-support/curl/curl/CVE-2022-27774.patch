From 48f126157d36962e458bf12f90b50cfcef26eee9 Mon Sep 17 00:00:00 2001
From: Daniel Stenberg <daniel@haxx.se>
Date: Mon, 25 Apr 2022 16:24:33 +0200
Subject: [PATCH 1/4] connect: store "conn_remote_port" in the info struct

To make it available after the connection ended.

Upstream-commit: 08b8ef4e726ba10f45081ecda5b3cea788d3c839
Signed-off-by: Kamil Dudka <kdudka@redhat.com>

Upstream-Status: Backport
CVE:  CVE-2022-27776
Signed-off-by: Armin Kuster <akuster@mvista.com>

---
 lib/connect.c | 1 +
 lib/urldata.h | 6 +++++-
 2 files changed, 6 insertions(+), 1 deletion(-)

Index: curl-7.61.0/lib/connect.c
===================================================================
--- curl-7.61.0.orig/lib/connect.c
+++ curl-7.61.0/lib/connect.c
@@ -614,6 +614,7 @@ void Curl_persistconninfo(struct connect
   conn->data->info.conn_scheme = conn->handler->scheme;
   conn->data->info.conn_protocol = conn->handler->protocol;
   conn->data->info.conn_primary_port = conn->primary_port;
+  conn->data->info.conn_remote_port = conn->remote_port;
   conn->data->info.conn_local_port = conn->local_port;
 }
 
Index: curl-7.61.0/lib/urldata.h
===================================================================
--- curl-7.61.0.orig/lib/urldata.h
+++ curl-7.61.0/lib/urldata.h
@@ -1052,7 +1052,11 @@ struct PureInfo {
      reused, in the connection cache. */
 
   char conn_primary_ip[MAX_IPADR_LEN];
-  long conn_primary_port;
+  long conn_primary_port;/* this is the destination port to the connection,
+                            which might have been a proxy */
+  int conn_remote_port;  /* this is the "remote port", which is the port
+                            number of the used URL, independent of proxy or
+                            not */
 
   char conn_local_ip[MAX_IPADR_LEN];
   long conn_local_port;
@@ -1232,6 +1236,7 @@ struct UrlState {
   curl_off_t current_speed;  /* the ProgressShow() function sets this,
                                 bytes / second */
   bool this_is_a_follow; /* this is a followed Location: request */
+  bool this_is_a_follow_without_auth;
   bool refused_stream; /* this was refused, try again */
 
   /* host name, port number and protocol of the first (not followed) request.
Index: curl-7.61.0/lib/transfer.c
===================================================================
--- curl-7.61.0.orig/lib/transfer.c
+++ curl-7.61.0/lib/transfer.c
@@ -1334,6 +1334,7 @@ CURLcode Curl_pretransfer(struct Curl_ea
   data->state.wildcardmatch = data->set.wildcard_enabled;
   data->set.followlocation = 0; /* reset the location-follow counter */
   data->state.this_is_a_follow = FALSE; /* reset this */
+  data->state.this_is_a_follow_without_auth = FALSE;
   data->state.errorbuf = FALSE; /* no error has occurred */
   data->state.httpversion = 0; /* don't assume any particular server version */
 
@@ -1518,6 +1519,68 @@ CURLcode Curl_follow(struct Curl_easy *d
 
   }
 
+  /* Clear auth if this redirects to a different port number or protocol,
+     unless permitted */
+  if(!data->set.allow_auth_to_other_hosts && (type != FOLLOW_FAKE)) {
+    int port;
+    bool clear = FALSE;
+
+    CURLU *u = curl_url();
+    if(!u)
+      return CURLE_OUT_OF_MEMORY;
+
+    uc = curl_url_set(u, CURLUPART_URL, newurl,
+        ((type == FOLLOW_REDIR) ? CURLU_URLENCODE : 0));
+    if(uc) {
+      infof(data, "Clear auth, curl_url_set() failed\n");
+      clear = TRUE;
+    }
+
+    if(!clear) {
+      if(data->set.use_port && data->state.allow_port)
+        /* a custom port is used */
+        port = (int)data->set.use_port;
+      else {
+        char *portnum;
+        uc = curl_url_get(u, CURLUPART_PORT, &portnum, CURLU_DEFAULT_PORT);
+        if(uc) {
+          infof(data, "Clear auth, failed to parse port number\n");
+          clear = TRUE;
+        }
+        else {
+          port = atoi(portnum);
+          free(portnum);
+        }
+      }
+    }
+    if(!clear && port != data->info.conn_remote_port) {
+      infof(data, "Clear auth, redirects to port from %u to %u\n",
+            data->info.conn_remote_port, port);
+      clear = TRUE;
+    }
+    if(!clear) {
+      char *scheme;
+      const struct Curl_handler *p;
+      uc = curl_url_get(u, CURLUPART_SCHEME, &scheme, 0);
+      if(uc) {
+        infof(data, "Clear auth, failed to parse scheme\n");
+        clear = TRUE;
+      }
+      else {
+        p = Curl_builtin_scheme(scheme);
+        if(p && (p->protocol != data->info.conn_protocol)) {
+          infof(data, "Clear auth, redirects scheme from %s to %s\n",
+                data->info.conn_scheme, scheme);
+          clear = TRUE;
+        }
+        free(scheme);
+      }
+    }
+    if(clear)
+      data->state.this_is_a_follow_without_auth = TRUE;
+    curl_url_cleanup(u);
+  }
+
   if(type == FOLLOW_FAKE) {
     /* we're only figuring out the new url if we would've followed locations
        but now we're done so we can get out! */
Index: curl-7.61.0/lib/url.c
===================================================================
--- curl-7.61.0.orig/lib/url.c
+++ curl-7.61.0/lib/url.c
@@ -3503,18 +3503,25 @@ static CURLcode override_login(struct Cu
                                struct connectdata *conn,
                                char **userp, char **passwdp, char **optionsp)
 {
-  if(data->set.str[STRING_USERNAME]) {
-    free(*userp);
-    *userp = strdup(data->set.str[STRING_USERNAME]);
-    if(!*userp)
-      return CURLE_OUT_OF_MEMORY;
+  if(data->state.this_is_a_follow
+      && data->state.this_is_a_follow_without_auth)
+  {
+    conn->bits.user_passwd = FALSE;
   }
+  else {
+    if(data->set.str[STRING_USERNAME]) {
+      free(*userp);
+      *userp = strdup(data->set.str[STRING_USERNAME]);
+      if(!*userp)
+        return CURLE_OUT_OF_MEMORY;
+    }
 
-  if(data->set.str[STRING_PASSWORD]) {
-    free(*passwdp);
-    *passwdp = strdup(data->set.str[STRING_PASSWORD]);
-    if(!*passwdp)
-      return CURLE_OUT_OF_MEMORY;
+    if(data->set.str[STRING_PASSWORD]) {
+      free(*passwdp);
+      *passwdp = strdup(data->set.str[STRING_PASSWORD]);
+      if(!*passwdp)
+        return CURLE_OUT_OF_MEMORY;
+    }
   }
 
   if(data->set.str[STRING_OPTIONS]) {
Index: curl-7.61.0/tests/data/Makefile.inc
===================================================================
--- curl-7.61.0.orig/tests/data/Makefile.inc
+++ curl-7.61.0/tests/data/Makefile.inc
@@ -108,6 +108,7 @@ test927 test928 test929 test930 test931
 test936 test937 test938 test939 test940 test941 test942 test943 test944 \
 test945 test946 test947 test948 test949 test950 test951 test952 \
 \
+test973 test974 test975 test976 \
 test980 test981 test982 test983 test984 test985 test986 \
 \
 test1000 test1001 test1002 test1003 test1004 test1005 test1006 test1007 \
Index: curl-7.61.0/tests/data/test973
===================================================================
--- /dev/null
+++ curl-7.61.0/tests/data/test973
@@ -0,0 +1,90 @@
+<testcase>
+<info>
+<keywords>
+HTTP
+FTP
+--location
+</keywords>
+</info>
+
+#
+# Server-side
+<reply>
+<data>
+HTTP/1.1 301 redirect
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 0
+Connection: close
+Content-Type: text/html
+Location: ftp://127.0.0.1:8992/a/path/9730002
+
+</data>
+<data2>
+data
+    to
+      see
+that FTP
+works
+  so does it?
+</data2>
+
+<datacheck>
+HTTP/1.1 301 redirect
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 0
+Connection: close
+Content-Type: text/html
+Location: ftp://127.0.0.1:8992/a/path/9730002
+
+data
+    to
+      see
+that FTP
+works
+  so does it?
+</datacheck>
+
+</reply>
+
+#
+# Client-side
+<client>
+<server>
+http
+ftp
+</server>
+ <name>
+HTTP with auth redirected to FTP w/o auth
+ </name>
+ <command>
+http://%HOSTIP:%HTTPPORT/973 -L -u joe:secret
+</command>
+</client>
+
+#
+# Verify data after the test has been "shot"
+<verify>
+<strip>
+^User-Agent:.*
+</strip>
+<protocol>
+GET /973 HTTP/1.1
+Host: %HOSTIP:%HTTPPORT
+Authorization: Basic am9lOnNlY3JldA==
+Accept: */*
+
+USER anonymous
+PASS ftp@example.com
+PWD
+CWD a
+CWD path
+EPSV
+TYPE I
+SIZE 9730002
+RETR 9730002
+QUIT
+</protocol>
+</verify>
+</testcase>
Index: curl-7.61.0/tests/data/test974
===================================================================
--- /dev/null
+++ curl-7.61.0/tests/data/test974
@@ -0,0 +1,88 @@
+<testcase>
+<info>
+<keywords>
+HTTP
+--location
+</keywords>
+</info>
+
+#
+# Server-side
+<reply>
+<data>
+HTTP/1.1 301 redirect
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 0
+Connection: close
+Content-Type: text/html
+Location: http://firsthost.com:9999/a/path/9740002
+
+</data>
+<data2>
+HTTP/1.1 200 OK
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 4
+Connection: close
+Content-Type: text/html
+
+hey
+</data2>
+
+<datacheck>
+HTTP/1.1 301 redirect
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 0
+Connection: close
+Content-Type: text/html
+Location: http://firsthost.com:9999/a/path/9740002
+
+HTTP/1.1 200 OK
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 4
+Connection: close
+Content-Type: text/html
+
+hey
+</datacheck>
+
+</reply>
+
+#
+# Client-side
+<client>
+<server>
+http
+</server>
+ <name>
+HTTP with auth redirected to HTTP on a diff port w/o auth
+ </name>
+ <command>
+-x http://%HOSTIP:%HTTPPORT http://firsthost.com -L -u joe:secret
+</command>
+</client>
+
+#
+# Verify data after the test has been "shot"
+<verify>
+<strip>
+^User-Agent:.*
+</strip>
+<protocol>
+GET http://firsthost.com/ HTTP/1.1
+Host: firsthost.com
+Authorization: Basic am9lOnNlY3JldA==
+Accept: */*
+Proxy-Connection: Keep-Alive
+
+GET http://firsthost.com:9999/a/path/9740002 HTTP/1.1
+Host: firsthost.com:9999
+Accept: */*
+Proxy-Connection: Keep-Alive
+
+</protocol>
+</verify>
+</testcase>
Index: curl-7.61.0/tests/data/test975
===================================================================
--- /dev/null
+++ curl-7.61.0/tests/data/test975
@@ -0,0 +1,90 @@
+<testcase>
+<info>
+<keywords>
+HTTP
+FTP
+--location-trusted
+</keywords>
+</info>
+
+#
+# Server-side
+<reply>
+<data>
+HTTP/1.1 301 redirect
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 0
+Connection: close
+Content-Type: text/html
+Location: ftp://127.0.0.1:8992/a/path/9750002
+
+</data>
+<data2>
+data
+    to
+      see
+that FTP
+works
+  so does it?
+</data2>
+
+<datacheck>
+HTTP/1.1 301 redirect
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 0
+Connection: close
+Content-Type: text/html
+Location: ftp://127.0.0.1:8992/a/path/9750002
+
+data
+    to
+      see
+that FTP
+works
+  so does it?
+</datacheck>
+
+</reply>
+
+#
+# Client-side
+<client>
+<server>
+http
+ftp
+</server>
+ <name>
+HTTP with auth redirected to FTP allowing auth to continue
+ </name>
+ <command>
+http://%HOSTIP:%HTTPPORT/975 --location-trusted -u joe:secret
+</command>
+</client>
+
+#
+# Verify data after the test has been "shot"
+<verify>
+<strip>
+^User-Agent:.*
+</strip>
+<protocol>
+GET /975 HTTP/1.1
+Host: %HOSTIP:%HTTPPORT
+Authorization: Basic am9lOnNlY3JldA==
+Accept: */*
+
+USER joe
+PASS secret
+PWD
+CWD a
+CWD path
+EPSV
+TYPE I
+SIZE 9750002
+RETR 9750002
+QUIT
+</protocol>
+</verify>
+</testcase>
Index: curl-7.61.0/tests/data/test976
===================================================================
--- /dev/null
+++ curl-7.61.0/tests/data/test976
@@ -0,0 +1,89 @@
+<testcase>
+<info>
+<keywords>
+HTTP
+--location-trusted
+</keywords>
+</info>
+
+#
+# Server-side
+<reply>
+<data>
+HTTP/1.1 301 redirect
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 0
+Connection: close
+Content-Type: text/html
+Location: http://firsthost.com:9999/a/path/9760002
+
+</data>
+<data2>
+HTTP/1.1 200 OK
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 4
+Connection: close
+Content-Type: text/html
+
+hey
+</data2>
+
+<datacheck>
+HTTP/1.1 301 redirect
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 0
+Connection: close
+Content-Type: text/html
+Location: http://firsthost.com:9999/a/path/9760002
+
+HTTP/1.1 200 OK
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 4
+Connection: close
+Content-Type: text/html
+
+hey
+</datacheck>
+
+</reply>
+
+#
+# Client-side
+<client>
+<server>
+http
+</server>
+ <name>
+HTTP with auth redirected to HTTP on a diff port --location-trusted
+ </name>
+ <command>
+-x http://%HOSTIP:%HTTPPORT http://firsthost.com --location-trusted -u joe:secret
+</command>
+</client>
+
+#
+# Verify data after the test has been "shot"
+<verify>
+<strip>
+^User-Agent:.*
+</strip>
+<protocol>
+GET http://firsthost.com/ HTTP/1.1
+Host: firsthost.com
+Authorization: Basic am9lOnNlY3JldA==
+Accept: */*
+Proxy-Connection: Keep-Alive
+
+GET http://firsthost.com:9999/a/path/9760002 HTTP/1.1
+Host: firsthost.com:9999
+Authorization: Basic am9lOnNlY3JldA==
+Accept: */*
+Proxy-Connection: Keep-Alive
+
+</protocol>
+</verify>
+</testcase>
Index: curl-7.61.0/lib/http.c
===================================================================
--- curl-7.61.0.orig/lib/http.c
+++ curl-7.61.0/lib/http.c
@@ -682,10 +682,10 @@ output_auth_headers(struct connectdata *
 }
 
 /*
- * allow_auth_to_host() tells if autentication, cookies or other "sensitive
- * data" can (still) be sent to this host.
+ * Curl_allow_auth_to_host() tells if authentication, cookies or other
+ * "sensitive data" can (still) be sent to this host.
  */
-static bool allow_auth_to_host(struct connectdata *conn)
+bool Curl_allow_auth_to_host(struct connectdata *conn)
 {
   struct Curl_easy *data = conn->data;
   return (!data->state.this_is_a_follow ||
@@ -766,7 +766,7 @@ Curl_http_output_auth(struct connectdata
 
   /* To prevent the user+password to get sent to other than the original host
      due to a location-follow */
-  if(allow_auth_to_host(conn)
+  if(Curl_allow_auth_to_host(conn)
      || conn->bits.netrc)
     result = output_auth_headers(conn, authhost, request, path, FALSE);
   else
@@ -1775,7 +1775,7 @@ CURLcode Curl_add_custom_headers(struct
                    checkprefix("Cookie:", headers->data)) &&
                   /* be careful of sending this potentially sensitive header to
                      other hosts */
-                  !allow_auth_to_host(conn))
+                  !Curl_allow_auth_to_host(conn))
             ;
           else {
             result = Curl_add_bufferf(req_buffer, "%s\r\n", headers->data);
Index: curl-7.61.0/lib/http.h
===================================================================
--- curl-7.61.0.orig/lib/http.h
+++ curl-7.61.0/lib/http.h
@@ -252,5 +252,11 @@ Curl_http_output_auth(struct connectdata
                       bool proxytunnel); /* TRUE if this is the request setting
                                             up the proxy tunnel */
 
+/*
+ * Curl_allow_auth_to_host() tells if authentication, cookies or other
+ * "sensitive data" can (still) be sent to this host.
+ */
+bool Curl_allow_auth_to_host(struct connectdata *conn);
+
 #endif /* HEADER_CURL_HTTP_H */
 
Index: curl-7.61.0/lib/vtls/openssl.c
===================================================================
--- curl-7.61.0.orig/lib/vtls/openssl.c
+++ curl-7.61.0/lib/vtls/openssl.c
@@ -2453,7 +2453,8 @@ static CURLcode ossl_connect_step1(struc
 #endif
 
 #ifdef USE_TLS_SRP
-  if(ssl_authtype == CURL_TLSAUTH_SRP) {
+  if((ssl_authtype == CURL_TLSAUTH_SRP) &&
+     Curl_allow_auth_to_host(conn)) {
     char * const ssl_username = SSL_SET_OPTION(username);
 
     infof(data, "Using TLS-SRP username: %s\n", ssl_username);
