Defensive code that tries to prevent a recurrence of problems like the one described in ticket [7a5279a25c57adf1] 

Upstream-Status: Backport
https://www.sqlite.org/src/info/572105de1d44bca4
CVE:  CVE-2020-13435
Signed-off-by: Armin Kuster <akuster@mvista.com>
Index: sqlite-autoconf-3230100/sqlite3.c
===================================================================
--- sqlite-autoconf-3230100.orig/sqlite3.c
+++ sqlite-autoconf-3230100/sqlite3.c
@@ -97556,7 +97556,9 @@ SQLITE_PRIVATE int sqlite3ExprCodeTarget
   switch( op ){
     case TK_AGG_COLUMN: {
       AggInfo *pAggInfo = pExpr->pAggInfo;
-      struct AggInfo_col *pCol = &pAggInfo->aCol[pExpr->iAgg];
+      struct AggInfo_col *pCol;
+      assert( pAggInfo!=0 );
+      assert( pExpr->iAgg>=0 && pExpr->iAgg<pAggInfo->nColumn );
       if( !pAggInfo->directMode ){
         assert( pCol->iMem>0 );
         return pCol->iMem;
@@ -97775,7 +97777,10 @@ SQLITE_PRIVATE int sqlite3ExprCodeTarget
     }
     case TK_AGG_FUNCTION: {
       AggInfo *pInfo = pExpr->pAggInfo;
-      if( pInfo==0 ){
+      if( pInfo==0 
+        || NEVER(pExpr->iAgg<0)
+        || NEVER(pExpr->iAgg>=pInfo->nFunc)
+        ){
         assert( !ExprHasProperty(pExpr, EP_IntValue) );
         sqlite3ErrorMsg(pParse, "misuse of aggregate: %s()", pExpr->u.zToken);
       }else{
