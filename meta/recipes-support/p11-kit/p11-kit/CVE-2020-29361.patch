From 5307a1d21a50cacd06f471a873a018d23ba4b963 Mon Sep 17 00:00:00 2001
From: David Cook <divergentdave@gmail.com>
Date: Sat, 7 Nov 2020 10:12:44 -0600
Subject: [PATCH] Check for arithmetic overflows before allocating

Upstream-Status: Backport
CVE: CVE-2020-29361 patch #1
Signed-off-by: Armin Kuster <akuster@mvisra.com>


---
 p11-kit/iter.c        |  4 ++--
 p11-kit/lists.c       |  2 ++
 p11-kit/proxy.c       |  2 +-
 p11-kit/rpc-message.c | 13 +++++++++++++
 p11-kit/rpc-message.h |  4 ++++
 p11-kit/rpc-server.c  |  8 ++++----
 trust/index.c         |  4 ++--
 7 files changed, 28 insertions(+), 9 deletions(-)

Index: git/p11-kit/lists.c
===================================================================
--- git.orig/p11-kit/lists.c
+++ git/p11-kit/lists.c
@@ -64,6 +64,8 @@ hex_encode (const unsigned char *data,
 	size_t i;
 	size_t o;
 
+	if ((SIZE_MAX - 1) / 3 < n_data)
+		return NULL;
 	result = malloc (n_data * 3 + 1);
 	if (result == NULL)
 		return NULL;
Index: git/p11-kit/rpc-message.c
===================================================================
--- git.orig/p11-kit/rpc-message.c
+++ git/p11-kit/rpc-message.c
@@ -43,6 +43,7 @@
 #include "rpc-message.h"
 
 #include <assert.h>
+#include <errno.h>
 #include <string.h>
 
 #define ELEMS(x) (sizeof (x) / sizeof (x[0]))
@@ -114,6 +115,18 @@ p11_rpc_message_alloc_extra (p11_rpc_mes
 	return (void *)(data + 1);
 }
 
+void *
+p11_rpc_message_alloc_extra_array (p11_rpc_message *msg,
+				   size_t nmemb,
+				   size_t size)
+{
+	if ((SIZE_MAX - sizeof (void *)) / nmemb < size) {
+		errno = ENOMEM;
+		return NULL;
+	}
+	return p11_rpc_message_alloc_extra (msg, nmemb * size);
+}
+
 bool
 p11_rpc_message_prep (p11_rpc_message *msg,
                       int call_id,
Index: git/p11-kit/rpc-message.h
===================================================================
--- git.orig/p11-kit/rpc-message.h
+++ git/p11-kit/rpc-message.h
@@ -255,6 +255,10 @@ void             p11_rpc_message_clear
 void *           p11_rpc_message_alloc_extra             (p11_rpc_message *msg,
                                                           size_t length);
 
+void *           p11_rpc_message_alloc_extra_array       (p11_rpc_message *msg,
+                                                          size_t nmemb,
+                                                          size_t size);
+
 bool             p11_rpc_message_prep                    (p11_rpc_message *msg,
                                                           int call_id,
                                                           p11_rpc_message_type type);
Index: git/p11-kit/rpc-server.c
===================================================================
--- git.orig/p11-kit/rpc-server.c
+++ git/p11-kit/rpc-server.c
@@ -88,7 +88,7 @@ proto_read_byte_buffer (p11_rpc_message
 	if (length == 0)
 		return CKR_OK;
 
-	*buffer = p11_rpc_message_alloc_extra (msg, length * sizeof (CK_BYTE));
+	*buffer = p11_rpc_message_alloc_extra_array (msg, length, sizeof (CK_BYTE));
 	if (*buffer == NULL)
 		return CKR_DEVICE_MEMORY;
 
@@ -186,7 +186,7 @@ proto_read_ulong_buffer (p11_rpc_message
 	if (length == 0)
 		return CKR_OK;
 
-	*buffer = p11_rpc_message_alloc_extra (msg, length * sizeof (CK_ULONG));
+	*buffer = p11_rpc_message_alloc_extra_array (msg, length, sizeof (CK_ULONG));
 	if (!*buffer)
 		return CKR_DEVICE_MEMORY;
 
@@ -246,7 +246,7 @@ proto_read_attribute_buffer (p11_rpc_mes
 		return PARSE_ERROR;
 
 	/* Allocate memory for the attribute structures */
-	attrs = p11_rpc_message_alloc_extra (msg, n_attrs * sizeof (CK_ATTRIBUTE));
+	attrs = p11_rpc_message_alloc_extra_array (msg, n_attrs, sizeof (CK_ATTRIBUTE));
 	if (attrs == NULL)
 		return CKR_DEVICE_MEMORY;
 
@@ -300,7 +300,7 @@ proto_read_attribute_array (p11_rpc_mess
 		return PARSE_ERROR;
 
 	/* Allocate memory for the attribute structures */
-	attrs = p11_rpc_message_alloc_extra (msg, n_attrs * sizeof (CK_ATTRIBUTE));
+	attrs = p11_rpc_message_alloc_extra_array (msg, n_attrs, sizeof (CK_ATTRIBUTE));
 	if (attrs == NULL)
 		return CKR_DEVICE_MEMORY;
 
Index: git/p11-kit/iter.c
===================================================================
--- git.orig/p11-kit/iter.c
+++ git/p11-kit/iter.c
@@ -542,7 +542,7 @@ move_next_session (P11KitIter *iter)
 			if (rv != CKR_OK)
 				return finish_iterating (iter, rv);
 
-			iter->slots = realloc (iter->slots, sizeof (CK_SLOT_ID) * (num_slots + 1));
+			iter->slots = reallocarray (iter->slots, num_slots + 1, sizeof (CK_SLOT_ID));
 			return_val_if_fail (iter->slots != NULL, CKR_HOST_MEMORY);
 
 			rv = (iter->module->C_GetSlotList) (CK_TRUE, iter->slots, &num_slots);
@@ -695,7 +695,7 @@ p11_kit_iter_next (P11KitIter *iter)
 		for (;;) {
 			if (iter->max_objects - iter->num_objects == 0) {
 				iter->max_objects = iter->max_objects ? iter->max_objects * 2 : 64;
-				iter->objects = realloc (iter->objects, iter->max_objects * sizeof (CK_ULONG));
+				iter->objects = reallocarray (iter->objects, iter->max_objects, sizeof (CK_ULONG));
 				return_val_if_fail (iter->objects != NULL, CKR_HOST_MEMORY);
 			}
 
Index: git/p11-kit/proxy.c
===================================================================
--- git.orig/p11-kit/proxy.c
+++ git/p11-kit/proxy.c
@@ -292,7 +292,7 @@ proxy_create (Proxy **res, CK_FUNCTION_L
 			return_val_if_fail (count == 0 || slots != NULL, CKR_GENERAL_ERROR);
 
 			if (count > 0) {
-				py->mappings = realloc (py->mappings, sizeof (Mapping) * (py->n_mappings + count));
+				py->mappings = reallocarray (py->mappings, (py->n_mappings + count), sizeof (Mapping));
 				return_val_if_fail (py->mappings != NULL, CKR_HOST_MEMORY);
 
 				/* And now add a mapping for each of those slots */
Index: git/trust/index.c
===================================================================
--- git.orig/trust/index.c
+++ git/trust/index.c
@@ -263,7 +263,7 @@ bucket_insert (index_bucket *bucket,
 	if (bucket->num + 1 > alloc) {
 		alloc = alloc ? alloc * 2 : 1;
 		return_if_fail (alloc != 0);
-		bucket->elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
+		bucket->elem = reallocarray (bucket->elem, alloc, sizeof (CK_OBJECT_HANDLE));
 	}
 
 	return_if_fail (bucket->elem != NULL);
