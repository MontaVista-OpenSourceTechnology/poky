Backport of:

From a46c111d9f3642f0ef3819e7298846ccc61869e0 Mon Sep 17 00:00:00 2001
From: DRC <information@libjpeg-turbo.org>
Date: Mon, 27 Jul 2020 14:21:23 -0500
Subject: [PATCH] Further jpeg_skip_scanlines() fixes

- Introduce a partial image decompression regression test script that
  validates the correctness of jpeg_skip_scanlines() and
  jpeg_crop_scanlines() for a variety of cropping regions and libjpeg
  settings.

  This regression test catches the following issues:
  #182, fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69
  #237, fixed in 6e95c08649794f5018608f37250026a45ead2db8
  #244, fixed in 398c1e9acc9b4531edceb3d77da0de5744675052
  #441, fully fixed in this commit

  It does not catch the following issues:
  #194, fixed in 773040f9d949d5f313caf7507abaf4bd5d7ffa12
  #244 (additional segfault), fixed in
       9120a247436e84c0b4eea828cb11e8f665fcde30

- Modify the libjpeg-turbo regression test suite (make test) so that it
  checks for the issue reported in #441 (segfault in
  jpeg_skip_scanlines() when used with 4:2:0 merged upsampling/color
  conversion.)

- Fix issues in jpeg_skip_scanlines() that caused incorrect output with
  h2v2 (4:2:0) merged upsampling/color conversion.  The previous commit
  fixed the segfault reported in #441, but that was a symptom of a
  larger problem.  Because merged 4:2:0 upsampling uses a "spare row"
  buffer, it is necessary to allow the upsampler to run when skipping
  rows (fancy 4:2:0 upsampling, which uses context rows, also requires
  this.)  Otherwise, if skipping starts at an odd-numbered row, the
  output image will be incorrect.

- Throw an error if jpeg_skip_scanlines() is called with two-pass color
  quantization enabled.  With two-pass color quantization, the first
  pass occurs within jpeg_start_decompress(), so subsequent calls to
  jpeg_skip_scanlines() interfere with the multipass state and prevent
  the second pass from occurring during subsequent calls to
  jpeg_read_scanlines().

Upstream-Status: Backport [https://launchpad.net/ubuntu/+archive/primary/+sourcefiles/libjpeg-turbo/1.5.2-0ubuntu5.18.04.6/libjpeg-turbo_1.5.2-0ubuntu5.18.04.6.debian.tar.xz
Upstream-Commit: https://github.com/libjpeg-turbo/libjpeg-turbo/commit/a46c111d9f3642f0ef3819e7298846ccc61869e0
CVE: CVE-2020-35538
Signed-off-by: Vijay Anusuri <vanusuri@mvista.com>
---
 CMakeLists.txt |  9 +++--
 ChangeLog.md   | 15 +++++---
 croptest.in    | 95 ++++++++++++++++++++++++++++++++++++++++++++++++++
 jdapistd.c     | 70 +++++++++++--------------------------
 libjpeg.txt    |  6 ++--
 5 files changed, 136 insertions(+), 59 deletions(-)
 create mode 100755 croptest.in

--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -437,7 +437,7 @@ else()
   endif()
   set(MD5_JPEG_420_ISLOW_ARI e986fb0a637a8d833d96e8a6d6d84ea1)
   set(MD5_JPEG_444_ISLOW_PROGARI 0a8f1c8f66e113c3cf635df0a475a617)
-  set(MD5_PPM_420M_IFAST_ARI 72b59a99bcf1de24c5b27d151bde2437)
+  set(MD5_PPM_420M_IFAST_ARI 57251da28a35b46eecb7177d82d10e0e)
   set(MD5_JPEG_420_ISLOW 9a68f56bc76e466aa7e52f415d0f4a5f)
   set(MD5_PPM_420M_ISLOW_2_1 9f9de8c0612f8d06869b960b05abf9c9)
   set(MD5_PPM_420M_ISLOW_15_8 b6875bc070720b899566cc06459b63b7)
@@ -699,7 +699,7 @@ foreach(libtype ${TEST_LIBTYPES})
   if(WITH_ARITH_DEC)
     # CC: RGB->YCC  SAMP: h2v2 merged  IDCT: ifast  ENT: arith
     add_test(djpeg${suffix}-420m-ifast-ari
-      ${dir}djpeg${suffix} -fast -ppm
+      ${dir}djpeg${suffix} -fast -skip 1,20 -ppm
         -outfile testout_420m_ifast_ari.ppm ${TESTIMAGES}/testimgari.jpg)
     add_test(djpeg${suffix}-420m-ifast-ari-cmp
       ${MD5CMP} ${MD5_PPM_420M_IFAST_ARI} testout_420m_ifast_ari.ppm)
@@ -915,6 +915,11 @@ add_custom_target(installer
     cjpeg djpeg jpegtran tjbench ${JAVA_DEPEND}
   SOURCES libjpeg-turbo.nsi)
 
+configure_file(croptest.in croptest @ONLY)
+add_custom_target(croptest
+  COMMAND echo croptest
+  COMMAND ${BASH} ${CMAKE_CURRENT_BINARY_DIR}/croptest)
+
 if(WITH_TURBOJPEG)
   if(ENABLE_SHARED)
     install(TARGETS turbojpeg tjbench
--- /dev/null
+++ b/croptest.in
@@ -0,0 +1,95 @@
+#!/bin/bash
+
+set -u
+set -e
+trap onexit INT
+trap onexit TERM
+trap onexit EXIT
+
+onexit()
+{
+	if [ -d $OUTDIR ]; then
+		rm -rf $OUTDIR
+	fi
+}
+
+runme()
+{
+	echo \*\*\* $*
+	$*
+}
+
+IMAGE=vgl_6548_0026a.bmp
+WIDTH=128
+HEIGHT=95
+IMGDIR=@CMAKE_CURRENT_SOURCE_DIR@/testimages
+OUTDIR=`mktemp -d /tmp/__croptest_output.XXXXXX`
+EXEDIR=@CMAKE_CURRENT_BINARY_DIR@
+
+if [ -d $OUTDIR ]; then
+	rm -rf $OUTDIR
+fi
+mkdir -p $OUTDIR
+
+exec >$EXEDIR/croptest.log
+
+echo "============================================================"
+echo "$IMAGE ($WIDTH x $HEIGHT)"
+echo "============================================================"
+echo
+
+for PROGARG in "" -progressive; do
+
+	cp $IMGDIR/$IMAGE $OUTDIR
+	basename=`basename $IMAGE .bmp`
+	echo "------------------------------------------------------------"
+	echo "Generating test images"
+	echo "------------------------------------------------------------"
+	echo
+	runme $EXEDIR/cjpeg $PROGARG -grayscale -outfile $OUTDIR/${basename}_GRAY.jpg $IMGDIR/${basename}.bmp
+	runme $EXEDIR/cjpeg $PROGARG -sample 2x2 -outfile $OUTDIR/${basename}_420.jpg $IMGDIR/${basename}.bmp
+	runme $EXEDIR/cjpeg $PROGARG -sample 2x1 -outfile $OUTDIR/${basename}_422.jpg $IMGDIR/${basename}.bmp
+	runme $EXEDIR/cjpeg $PROGARG -sample 1x2 -outfile $OUTDIR/${basename}_440.jpg $IMGDIR/${basename}.bmp
+	runme $EXEDIR/cjpeg $PROGARG -sample 1x1 -outfile $OUTDIR/${basename}_444.jpg $IMGDIR/${basename}.bmp
+	echo
+
+	for NSARG in "" -nosmooth; do
+
+		for COLORSARG in "" "-colors 256 -dither none -onepass"; do
+
+			for Y in {0..16}; do
+
+				for H in {1..16}; do
+
+					X=$(( (Y*16)%128 ))
+					W=$(( WIDTH-X-7 ))
+					if [ $Y -le 15 ]; then
+						CROPSPEC="${W}x${H}+${X}+${Y}"
+					else
+						Y2=$(( HEIGHT-H ));
+						CROPSPEC="${W}x${H}+${X}+${Y2}"
+					fi
+
+					echo "------------------------------------------------------------"
+					echo $PROGARG $NSARG $COLORSARG -crop $CROPSPEC
+					echo "------------------------------------------------------------"
+					echo
+					for samp in GRAY 420 422 440 444; do
+						$EXEDIR/djpeg $NSARG $COLORSARG -rgb -outfile $OUTDIR/${basename}_${samp}_full.ppm $OUTDIR/${basename}_${samp}.jpg
+						convert -crop $CROPSPEC $OUTDIR/${basename}_${samp}_full.ppm $OUTDIR/${basename}_${samp}_ref.ppm
+						runme $EXEDIR/djpeg $NSARG $COLORSARG -crop $CROPSPEC -rgb -outfile $OUTDIR/${basename}_${samp}.ppm $OUTDIR/${basename}_${samp}.jpg
+						runme cmp $OUTDIR/${basename}_${samp}.ppm $OUTDIR/${basename}_${samp}_ref.ppm
+					done
+					echo
+
+				done
+
+			done
+
+		done
+
+	done
+
+done
+
+echo SUCCESS!
--- a/jdapistd.c
+++ b/jdapistd.c
@@ -303,16 +303,6 @@ noop_quantize (j_decompress_ptr cinfo, J
 }
 
 
-/* Dummy postprocessing function used by jpeg_skip_scanlines() */
-LOCAL(void)
-noop_post_process (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
-                   JDIMENSION *in_row_group_ctr,
-                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,
-                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
-{
-}
-
-
 /*
  * In some cases, it is best to call jpeg_read_scanlines() and discard the
  * output, rather than skipping the scanlines, because this allows us to
@@ -326,16 +316,12 @@ read_and_discard_scanlines (j_decompress
 {
   JDIMENSION n;
   my_master_ptr master = (my_master_ptr)cinfo->master;
+  JSAMPARRAY scanlines = NULL;
   void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                          JDIMENSION input_row, JSAMPARRAY output_buf,
                          int num_rows) = NULL;
   void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
                           JSAMPARRAY output_buf, int num_rows) = NULL;
-  void (*post_process_data) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
-                             JDIMENSION *in_row_group_ctr,
-                             JDIMENSION in_row_groups_avail,
-                             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
-                             JDIMENSION out_rows_avail) = NULL;
 
   if (cinfo->cconvert && cinfo->cconvert->color_convert) {
     color_convert = cinfo->cconvert->color_convert;
@@ -347,23 +333,19 @@ read_and_discard_scanlines (j_decompress
     cinfo->cquantize->color_quantize = noop_quantize;
   }
 
-  if (master->using_merged_upsample && cinfo->post &&
-      cinfo->post->post_process_data) {
-    post_process_data = cinfo->post->post_process_data;
-    cinfo->post->post_process_data = noop_post_process;
+  if (master->using_merged_upsample && cinfo->max_v_samp_factor == 2) {
+    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
+    scanlines = &upsample->spare_row;
   }
 
   for (n = 0; n < num_lines; n++)
-    jpeg_read_scanlines(cinfo, NULL, 1);
+    jpeg_read_scanlines(cinfo, scanlines, 1);
 
   if (color_convert)
     cinfo->cconvert->color_convert = color_convert;
 
   if (color_quantize)
     cinfo->cquantize->color_quantize = color_quantize;
-
-  if (post_process_data)
-    cinfo->post->post_process_data = post_process_data;
 }
 
 
@@ -377,6 +359,12 @@ increment_simple_rowgroup_ctr (j_decompr
 {
   JDIMENSION rows_left;
   my_main_ptr main_ptr = (my_main_ptr) cinfo->main;
+  my_master_ptr master = (my_master_ptr)cinfo->master;
+
+  if (master->using_merged_upsample && cinfo->max_v_samp_factor == 2) {
+    read_and_discard_scanlines(cinfo, rows);
+    return;
+  }
 
   /* Increment the counter to the next row group after the skipped rows. */
   main_ptr->rowgroup_ctr += rows / cinfo->max_v_samp_factor;
@@ -407,11 +395,16 @@ jpeg_skip_scanlines (j_decompress_ptr ci
   my_main_ptr main_ptr = (my_main_ptr) cinfo->main;
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
   my_master_ptr master = (my_master_ptr)cinfo->master;
+  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
   JDIMENSION i, x;
   int y;
   JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;
   JDIMENSION lines_to_skip, lines_to_read;
 
+  /* Two-pass color quantization is not supported. */
+  if (cinfo->quantize_colors && cinfo->two_pass_quantize)
+    ERREXIT(cinfo, JERR_NOTIMPL);
+
   if (cinfo->global_state != DSTATE_SCANNING)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 
@@ -467,13 +460,7 @@ jpeg_skip_scanlines (j_decompress_ptr ci
     main_ptr->buffer_full = FALSE;
     main_ptr->rowgroup_ctr = 0;
     main_ptr->context_state = CTX_PREPARE_FOR_IMCU;
-    if (master->using_merged_upsample) {
-      my_merged_upsample_ptr upsample =
-        (my_merged_upsample_ptr)cinfo->upsample;
-      upsample->spare_full = FALSE;
-      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
-    } else {
-      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+    if (!master->using_merged_upsample) {
       upsample->next_row_out = cinfo->max_v_samp_factor;
       upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
     }
@@ -488,13 +475,7 @@ jpeg_skip_scanlines (j_decompress_ptr ci
       cinfo->output_scanline += lines_left_in_iMCU_row;
       main_ptr->buffer_full = FALSE;
       main_ptr->rowgroup_ctr = 0;
-      if (master->using_merged_upsample) {
-        my_merged_upsample_ptr upsample =
-          (my_merged_upsample_ptr)cinfo->upsample;
-        upsample->spare_full = FALSE;
-        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
-      } else {
-        my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+      if (!master->using_merged_upsample) {
         upsample->next_row_out = cinfo->max_v_samp_factor;
         upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
       }
@@ -532,14 +513,8 @@ jpeg_skip_scanlines (j_decompress_ptr ci
       cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;
       increment_simple_rowgroup_ctr(cinfo, lines_to_read);
     }
-    if (master->using_merged_upsample) {
-      my_merged_upsample_ptr upsample =
-        (my_merged_upsample_ptr)cinfo->upsample;
-      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
-    } else {
-      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+    if (!master->using_merged_upsample)
       upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
-    }
     return num_lines;
   }
 
@@ -580,13 +555,8 @@ jpeg_skip_scanlines (j_decompress_ptr ci
    * bit odd, since "rows_to_go" seems to be redundantly keeping track of
    * output_scanline.
    */
-  if (master->using_merged_upsample) {
-    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
+  if (!master->using_merged_upsample)
     upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
-  } else {
-    my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
-    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
-  }
 
   /* Always skip the requested number of lines. */
   return num_lines;
