From be4a213a6204058e96c25144769c1c5ef0187cf2 Mon Sep 17 00:00:00 2001
From: Vijay Anusuri <vanusuri@mvista.com>
Date: Fri, 16 Sep 2022 06:10:47 +0000
Subject: [PATCH] CVE-2021-31566-02

Do not follow symlinks when processing the fixup list

Use lchmod() instead of chmod() and tell the remaining functions that the
real file to be modified is a symbolic link.

Fixes #1566

Upstream-Status: Backport from https://github.com/libarchive/libarchive/commit/b41daecb5ccb4c8e3b2c53fd6147109fc12c3043
CVE: CVE-2021-31566
Signed-off-by: Vijay Anusuri <vanusuri@mvista.com>
---
 Makefile.am                             |  1 +
 libarchive/archive_write_disk_posix.c   | 39 ++++++++++++-
 libarchive/test/CMakeLists.txt          |  1 +
 libarchive/test/test_write_disk_fixup.c | 78 +++++++++++++++++++++++++
 4 files changed, 116 insertions(+), 3 deletions(-)
 create mode 100644 libarchive/test/test_write_disk_fixup.c

diff --git a/Makefile.am b/Makefile.am
index 63d7cc7..13bdf48 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -533,6 +533,7 @@ libarchive_test_SOURCES= \
 	libarchive/test/test_write_disk.c \
 	libarchive/test/test_write_disk_appledouble.c \
 	libarchive/test/test_write_disk_failures.c \
+        libarchive/test/test_write_disk_fixup.c \
 	libarchive/test/test_write_disk_hardlink.c \
 	libarchive/test/test_write_disk_hfs_compression.c \
 	libarchive/test/test_write_disk_lookup.c \
diff --git a/libarchive/archive_write_disk_posix.c b/libarchive/archive_write_disk_posix.c
index ee12401..73fb562 100644
--- a/libarchive/archive_write_disk_posix.c
+++ b/libarchive/archive_write_disk_posix.c
@@ -2315,7 +2315,8 @@ _archive_write_disk_close(struct archive *_a)
 {
 	struct archive_write_disk *a = (struct archive_write_disk *)_a;
 	struct fixup_entry *next, *p;
-	int ret;
+        struct stat st;
+	int fd, ret;
 
 	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
 	    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,
@@ -2327,6 +2328,25 @@ _archive_write_disk_close(struct archive *_a)
 
 	while (p != NULL) {
 		a->pst = NULL; /* Mark stat cache as out-of-date. */
+                if (p->fixup &
+                    (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {
+                        fd = open(p->name,
+                            O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);
+                        if (fd == -1) {
+                                /* If we cannot lstat, skip entry */
+                                if (lstat(p->name, &st) != 0)
+                                        goto skip_fixup_entry;
+                                /*
+                                 * If we deal with a symbolic link, mark
+                                 * it in the fixup mode to ensure no
+                                 * modifications are made to its target.
+                                 */
+                                if (S_ISLNK(st.st_mode)) {
+                                        p->mode &= ~S_IFMT;
+                                        p->mode |= S_IFLNK;
+                                }
+                        }
+                }
 		if (p->fixup & TODO_TIMES) {
 			set_times(a, -1, p->mode, p->name,
 			    p->atime, p->atime_nanos,
@@ -2334,8 +2354,19 @@ _archive_write_disk_close(struct archive *_a)
 			    p->mtime, p->mtime_nanos,
 			    p->ctime, p->ctime_nanos);
 		}
-		if (p->fixup & TODO_MODE_BASE)
-			chmod(p->name, p->mode);
+		if (p->fixup & TODO_MODE_BASE) {
+#ifdef HAVE_FCHMOD
+                        if (fd >= 0)
+                                fchmod(fd, p->mode);
+                        else
+#endif
+#ifdef HAVE_LCHMOD
+                        lchmod(p->name, p->mode);
+#else
+                        if (!S_ISLNK(p->mode))
+                                chmod(p->name, p->mode);
+#endif
+                }
 		if (p->fixup & TODO_ACLS)
 			archive_write_disk_set_acls(&a->archive, -1, p->name,
 			    &p->acl, p->mode);
@@ -2345,6 +2376,7 @@ _archive_write_disk_close(struct archive *_a)
 		if (p->fixup & TODO_MAC_METADATA)
 			set_mac_metadata(a, p->name, p->mac_metadata,
 					 p->mac_metadata_size);
+skip_fixup_entry:
 		next = p->next;
 		archive_acl_clear(&p->acl);
 		free(p->mac_metadata);
@@ -2483,6 +2515,7 @@ new_fixup(struct archive_write_disk *a, const char *pathname)
 	fe->next = a->fixup_list;
 	a->fixup_list = fe;
 	fe->fixup = 0;
+        fe->mode = 0;
 	fe->name = strdup(pathname);
 	return (fe);
 }
diff --git a/libarchive/test/CMakeLists.txt b/libarchive/test/CMakeLists.txt
index ee8686b..4814aef 100644
--- a/libarchive/test/CMakeLists.txt
+++ b/libarchive/test/CMakeLists.txt
@@ -200,6 +200,7 @@ IF(ENABLE_TEST)
     test_write_disk.c
     test_write_disk_appledouble.c
     test_write_disk_failures.c
+    test_write_disk_fixup.c
     test_write_disk_hardlink.c
     test_write_disk_hfs_compression.c
     test_write_disk_lookup.c
diff --git a/libarchive/test/test_write_disk_fixup.c b/libarchive/test/test_write_disk_fixup.c
new file mode 100644
index 0000000..cc977f0
--- /dev/null
+++ b/libarchive/test/test_write_disk_fixup.c
@@ -0,0 +1,78 @@
+/*-
+ * Copyright (c) 2021 Martin Matuska
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "test.h"
+
+/*
+ * Test fixup entries don't follow symlinks
+ */
+DEFINE_TEST(test_write_disk_fixup)
+{
+	struct archive *ad;
+	struct archive_entry *ae;
+	int r;
+
+	if (!canSymlink()) {
+		skipping("Symlinks not supported");
+		return;
+	}
+
+	/* Write entries to disk. */
+	assert((ad = archive_write_disk_new()) != NULL);
+
+	/*
+         * Create a file
+         */
+	assertMakeFile("victim", 0600, "a");
+
+	/*
+         * Create a directory and a symlink with the same name
+         */
+
+	/* Directory: dir */
+        assert((ae = archive_entry_new()) != NULL);
+        archive_entry_copy_pathname(ae, "dir");
+        archive_entry_set_mode(ae, AE_IFDIR | 0606);
+	assertEqualIntA(ad, 0, archive_write_header(ad, ae));
+	assertEqualIntA(ad, 0, archive_write_finish_entry(ad));
+        archive_entry_free(ae);
+
+	/* Symbolic Link: dir -> foo */
+	assert((ae = archive_entry_new()) != NULL);
+	archive_entry_copy_pathname(ae, "dir");
+	archive_entry_set_mode(ae, AE_IFLNK | 0777);
+	archive_entry_set_size(ae, 0);
+	archive_entry_copy_symlink(ae, "victim");
+	assertEqualIntA(ad, 0, r = archive_write_header(ad, ae));
+	if (r >= ARCHIVE_WARN)
+		assertEqualIntA(ad, 0, archive_write_finish_entry(ad));
+	archive_entry_free(ae);
+
+	assertEqualInt(ARCHIVE_OK, archive_write_free(ad));
+
+	/* Test the entries on disk. */
+	assertIsSymlink("dir", "victim", 0);
+	assertFileMode("victim", 0600);
+}
+
-- 
2.18.2

