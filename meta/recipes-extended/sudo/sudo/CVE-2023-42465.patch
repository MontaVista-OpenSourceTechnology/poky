From bdbcd3e94aaa91bb19e572f5675efc3f3593009a Mon Sep 17 00:00:00 2001
From: Rohini Sangam <rsangam@mvista.com>
Date: Mon, 28 Oct 2024 06:57:46 +0000
Subject: [PATCH] CVE-2023-42465: Try to make sudo less vulnerable to ROWHAMMER attacks.

Upstream-Status: Backport from https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f
CVE: CVE-2023-42465

Signed-off-by: Rohini Sangam <rsangam@mvista.com>
---
 plugins/sudoers/auth/passwd.c             |  27 +++--
 plugins/sudoers/auth/sudo_auth.c          |  51 ++++++---
 plugins/sudoers/auth/sudo_auth.h          |  10 +-
 plugins/sudoers/cvtsudoers.c              |   6 +-
 plugins/sudoers/match.c                   | 102 +++++++++++-------
 plugins/sudoers/parse.c                   |   4 +-
 plugins/sudoers/parse.h                   |  21 +++-
 7 files changed, 145 insertions(+), 76 deletions(-)

diff --git a/plugins/sudoers/auth/passwd.c b/plugins/sudoers/auth/passwd.c
index 3ba2dd9..392893c 100644
--- a/plugins/sudoers/auth/passwd.c
+++ b/plugins/sudoers/auth/passwd.c
@@ -67,7 +67,7 @@ sudo_passwd_verify(struct passwd *pw, char *pass, sudo_auth *auth, struct sudo_c
     char des_pass[9], *epass;
     char *pw_epasswd = auth->data;
     size_t pw_len;
-    int matched = 0;
+    int ret;
     debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH)
 
     /* An empty plain-text password must match an empty encrypted password. */
@@ -79,7 +79,7 @@ sudo_passwd_verify(struct passwd *pw, char *pass, sudo_auth *auth, struct sudo_c
      */
     pw_len = strlen(pw_epasswd);
     if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {
-	strlcpy(des_pass, pass, sizeof(des_pass));
+	(void)strlcpy(des_pass, pass, sizeof(des_pass));
 	pass = des_pass;
     }
 
@@ -89,27 +89,34 @@ sudo_passwd_verify(struct passwd *pw, char *pass, sudo_auth *auth, struct sudo_c
      * only compare the first DESLEN characters in that case.
      */
     epass = (char *) crypt(pass, pw_epasswd);
+    ret = AUTH_FAILURE;
     if (epass != NULL) {
-	if (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)
-	    matched = !strncmp(pw_epasswd, epass, DESLEN);
-	else
-	    matched = !strcmp(pw_epasswd, epass);
+	if (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN) {
+	    if (strncmp(pw_epasswd, epass, DESLEN) == 0)
+		ret = AUTH_SUCCESS;
+	} else {
+	    if (strcmp(pw_epasswd, epass) == 0)
+		ret = AUTH_SUCCESS;
+	}
     }
 
-    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);
+    debug_return_int(ret);
 }
 #else
 int
 sudo_passwd_verify(struct passwd *pw, char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)
 {
     char *pw_passwd = auth->data;
-    int matched;
+    int ret;
     debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);
 
     /* Dummy version for systems without crypt(). */
-    matched = !strcmp(pass, pw_passwd);
+    if (strcmp(pass, pw_passwd) == 0)
+	ret = AUTH_SUCCESS;
+    else
+	ret = AUTH_FAILURE;
 
-    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);
+    debug_return_int(ret);
 }
 #endif
 
diff --git a/plugins/sudoers/auth/sudo_auth.c b/plugins/sudoers/auth/sudo_auth.c
index bae41a2..abc898c 100644
--- a/plugins/sudoers/auth/sudo_auth.c
+++ b/plugins/sudoers/auth/sudo_auth.c
@@ -117,10 +117,16 @@ sudo_auth_init(struct passwd *pw)
 	if (auth->init && !IS_DISABLED(auth)) {
 	    /* Disable if it failed to init unless there was a fatal error. */
 	    status = (auth->init)(pw, auth);
-	    if (status == AUTH_FAILURE)
+	    switch (status) {
+	    case AUTH_SUCCESS:
+		break;
+	    case AUTH_FAILURE:
 		SET(auth->flags, FLAG_DISABLED);
-	    else if (status == AUTH_FATAL)
-		break;		/* assume error msg already printed */
+		break;
+	    default:
+		/* Assume error msg already printed. */
+		debug_return_int(-1);
+	    }
 	}
     }
 
@@ -167,7 +173,7 @@ sudo_auth_init(struct passwd *pw)
 	}
     }
 
-    debug_return_int(status == AUTH_FATAL ? -1 : 0);
+    debug_return_int(0);
 }
 
 /*
@@ -208,7 +214,7 @@ sudo_auth_cleanup(struct passwd *pw)
     for (auth = auth_switch; auth->name; auth++) {
 	if (auth->cleanup && !IS_DISABLED(auth)) {
 	    int status = (auth->cleanup)(pw, auth);
-	    if (status == AUTH_FATAL) {
+	    if (status != AUTH_SUCCESS) {
 		/* Assume error msg already printed. */
 		debug_return_int(-1);
 	    }
@@ -303,7 +309,7 @@ verify_user(struct passwd *pw, char *prompt, int validated,
 		status = (auth->setup)(pw, &prompt, auth);
 		if (status == AUTH_FAILURE)
 		    SET(auth->flags, FLAG_DISABLED);
-		else if (status == AUTH_FATAL || user_interrupted())
+		else if (status != AUTH_SUCCESS || user_interrupted())
 		    goto done;		/* assume error msg already printed */
 	    }
 	}
@@ -356,7 +362,6 @@ done:
 	    log_auth_failure(validated, ntries);
 	    ret = false;
 	    break;
-	case AUTH_FATAL:
 	default:
 	    log_auth_failure(validated, 0);
 	    ret = -1;
@@ -368,24 +373,32 @@ done:
 
 /*
  * Call authentication method begin session hooks.
- * Returns 1 on success and -1 on error.
+ * Returns true on success, false on failure and -1 on error.
  */
 int
 sudo_auth_begin_session(struct passwd *pw, char **user_env[])
 {
     sudo_auth *auth;
+    int ret = true;
     debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH)
 
     for (auth = auth_switch; auth->name; auth++) {
 	if (auth->begin_session && !IS_DISABLED(auth)) {
 	    int status = (auth->begin_session)(pw, user_env, auth);
-	    if (status != AUTH_SUCCESS) {
+	    switch (status) {
+	    case AUTH_SUCCESS:
+		break;
+	    case AUTH_FAILURE:
+		ret = false;
+		break;
+	    default:
 		/* Assume error msg already printed. */
-		debug_return_int(-1);
+		ret = -1;
+		break;
 	    }
 	}
     }
-    debug_return_int(1);
+    debug_return_int(ret);
 }
 
 bool
@@ -406,25 +419,33 @@ sudo_auth_needs_end_session(void)
 
 /*
  * Call authentication method end session hooks.
- * Returns 1 on success and -1 on error.
+ * Returns true on success, false on failure and -1 on error.
  */
 int
 sudo_auth_end_session(struct passwd *pw)
 {
     sudo_auth *auth;
+    int ret = true;
     int status;
     debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH)
 
     for (auth = auth_switch; auth->name; auth++) {
 	if (auth->end_session && !IS_DISABLED(auth)) {
 	    status = (auth->end_session)(pw, auth);
-	    if (status == AUTH_FATAL) {
+	    switch (status) {
+	    case AUTH_SUCCESS:
+		break;
+	    case AUTH_FAILURE:
+		ret = false;
+		break;
+	    default:
 		/* Assume error msg already printed. */
-		debug_return_int(-1);
+		ret = -1;
+		break;
 	    }
 	}
     }
-    debug_return_int(1);
+    debug_return_int(ret);
 }
 
 /*
diff --git a/plugins/sudoers/auth/sudo_auth.h b/plugins/sudoers/auth/sudo_auth.h
index e14d077..efe00c0 100644
--- a/plugins/sudoers/auth/sudo_auth.h
+++ b/plugins/sudoers/auth/sudo_auth.h
@@ -19,11 +19,11 @@
 #ifndef SUDO_AUTH_H
 #define SUDO_AUTH_H
 
-/* Auth function return values.  */
-#define AUTH_SUCCESS	0
-#define AUTH_FAILURE	1
-#define AUTH_INTR	2
-#define AUTH_FATAL	3
+/* Auth function return values (rowhammer resistent).  */
+#define AUTH_SUCCESS   0x52a2925       /* 0101001010100010100100100101 */
+#define AUTH_FAILURE   0xad5d6da       /* 1010110101011101011011011010 */
+#define AUTH_INTR      0x69d61fc8      /* 1101001110101100001111111001000 */
+#define AUTH_FATAL     0x1629e037      /* 0010110001010011110000000110111 */
 
 typedef struct sudo_auth {
     int flags;			/* various flags, see below */
diff --git a/plugins/sudoers/cvtsudoers.c b/plugins/sudoers/cvtsudoers.c
index 9dad677..51cb0a0 100644
--- a/plugins/sudoers/cvtsudoers.c
+++ b/plugins/sudoers/cvtsudoers.c
@@ -690,7 +690,7 @@ userlist_matches_filter(struct sudoers_parse_tree *parse_tree,
 	    pw.pw_uid = (uid_t)-1;
 	    pw.pw_gid = (gid_t)-1;
 
-	    if (user_matches(parse_tree, &pw, m) == true)
+	    if (user_matches(parse_tree, &pw, m) == ALLOW)
 		matched = true;
 	} else {
 	    STAILQ_FOREACH(s, &filters->users, entries) {
@@ -716,7 +716,7 @@ userlist_matches_filter(struct sudoers_parse_tree *parse_tree,
 		if (pw == NULL)
 		    continue;
 
-		if (user_matches(parse_tree, pw, m) == true)
+		if (user_matches(parse_tree, pw, m) == ALLOW)
 		    matched = true;
 		sudo_pw_delref(pw);
 
@@ -792,7 +792,7 @@ hostlist_matches_filter(struct sudoers_parse_tree *parse_tree,
 
 	    /* Only need one host in the filter to match. */
 	    /* XXX - can't use netgroup_tuple with NULL pw */
-	    if (host_matches(parse_tree, NULL, lhost, shost, m) == true) {
+	    if (host_matches(parse_tree, NULL, lhost, shost, m) == ALLOW) {
 		matched = true;
 		break;
 	    }
diff --git a/plugins/sudoers/match.c b/plugins/sudoers/match.c
index 20f9082..18ad205 100644
--- a/plugins/sudoers/match.c
+++ b/plugins/sudoers/match.c
@@ -74,37 +74,42 @@ user_matches(struct sudoers_parse_tree *parse_tree, const struct passwd *pw,
 {
     const char *lhost = parse_tree->lhost ? parse_tree->lhost : user_runhost;
     const char *shost = parse_tree->shost ? parse_tree->shost : user_srunhost;
-    int matched = UNSPEC;
+    int rc, matched = UNSPEC;
     struct alias *a;
     debug_decl(user_matches, SUDOERS_DEBUG_MATCH)
 
     switch (m->type) {
 	case ALL:
-	    matched = !m->negated;
+	    matched = m->negated ? DENY : ALLOW;
 	    break;
 	case NETGROUP:
 	    if (netgr_matches(m->name,
 		def_netgroup_tuple ? lhost : NULL,
 		def_netgroup_tuple ? shost : NULL, pw->pw_name))
-		matched = !m->negated;
+		matched = m->negated ? DENY : ALLOW;
 	    break;
 	case USERGROUP:
 	    if (usergr_matches(m->name, pw->pw_name, pw))
-		matched = !m->negated;
+		matched = m->negated ? DENY : ALLOW;
 	    break;
 	case ALIAS:
 	    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {
 		/* XXX */
-		int rc = userlist_matches(parse_tree, pw, &a->members);
-		if (rc != UNSPEC)
-		    matched = m->negated ? !rc : rc;
+		rc = userlist_matches(parse_tree, pw, &a->members);
+               if (SPECIFIED(rc)) {
+                   if (m->negated) {
+                       matched = rc == ALLOW ? DENY : ALLOW;
+                   } else {
+                       matched = rc;
+                   }
+               }
 		alias_put(a);
 		break;
 	    }
 	    /* FALLTHROUGH */
 	case WORD:
 	    if (userpw_matches(m->name, pw->pw_name, pw))
-		matched = !m->negated;
+		matched = m->negated ? DENY : ALLOW;
 	    break;
     }
     debug_return_int(matched);
@@ -123,7 +128,8 @@ userlist_matches(struct sudoers_parse_tree *parse_tree, const struct passwd *pw,
     debug_decl(userlist_matches, SUDOERS_DEBUG_MATCH)
 
     TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
-	if ((matched = user_matches(parse_tree, pw, m)) != UNSPEC)
+       matched = user_matches(parse_tree, pw, m);
+       if (SPECIFIED(matched))
 	    break;
     }
     debug_return_int(matched);
@@ -168,48 +174,52 @@ runaslist_matches(struct sudoers_parse_tree *parse_tree,
 	/* If no runas user or runas group listed in sudoers, use default. */
 	if (user_list == NULL && group_list == NULL) {
 	    debug_return_int(userpw_matches(def_runas_default,
-		runas_pw->pw_name, runas_pw));
+		runas_pw->pw_name, runas_pw) ? ALLOW : DENY);
 	}
 
 	if (user_list != NULL) {
 	    TAILQ_FOREACH_REVERSE(m, user_list, member_list, entries) {
 		switch (m->type) {
 		    case ALL:
-			user_matched = !m->negated;
+			user_matched = m->negated ? DENY : ALLOW;
 			break;
 		    case NETGROUP:
 			if (netgr_matches(m->name,
 			    def_netgroup_tuple ? lhost : NULL,
 			    def_netgroup_tuple ? shost : NULL,
 			    runas_pw->pw_name))
-			    user_matched = !m->negated;
+			    user_matched = m->negated ? DENY : ALLOW;
 			break;
 		    case USERGROUP:
 			if (usergr_matches(m->name, runas_pw->pw_name, runas_pw))
-			    user_matched = !m->negated;
+			    user_matched = m->negated ? DENY : ALLOW;
 			break;
 		    case ALIAS:
 			a = alias_get(parse_tree, m->name, RUNASALIAS);
 			if (a != NULL) {
 			    rc = runaslist_matches(parse_tree, &a->members,
 				&empty, matching_user, NULL);
-			    if (rc != UNSPEC)
-				user_matched = m->negated ? !rc : rc;
+			    if (m->negated) {
+                               user_matched = rc == ALLOW ? DENY : ALLOW;
+                           } else {
+                               user_matched = rc;
+                           }
+              
 			    alias_put(a);
 			    break;
 			}
 			/* FALLTHROUGH */
 		    case WORD:
 			if (userpw_matches(m->name, runas_pw->pw_name, runas_pw))
-			    user_matched = !m->negated;
+			    user_matched = m->negated ? DENY : ALLOW;
 			break;
 		    case MYSELF:
 			if (!ISSET(sudo_user.flags, RUNAS_USER_SPECIFIED) ||
 			    strcmp(user_name, runas_pw->pw_name) == 0)
-			    user_matched = !m->negated;
+			    user_matched = m->negated ? DENY : ALLOW;
 			break;
 		}
-		if (user_matched != UNSPEC) {
+		if (SPECIFIED(user_matched)) {
 		    if (matching_user != NULL && m->type != ALIAS)
 			*matching_user = m;
 		    break;
@@ -230,32 +240,37 @@ runaslist_matches(struct sudoers_parse_tree *parse_tree,
 	    TAILQ_FOREACH_REVERSE(m, group_list, member_list, entries) {
 		switch (m->type) {
 		    case ALL:
-			group_matched = !m->negated;
+			group_matched = m->negated ? DENY : ALLOW;
 			break;
 		    case ALIAS:
 			a = alias_get(parse_tree, m->name, RUNASALIAS);
 			if (a != NULL) {
 			    rc = runaslist_matches(parse_tree, &empty,
 				&a->members, NULL, matching_group);
-			    if (rc != UNSPEC)
-				group_matched = m->negated ? !rc : rc;
+			    if (SPECIFIED(rc)) {
+                               if (m->negated) {
+                                   group_matched = rc == ALLOW ? DENY : ALLOW;
+                               } else {
+                                   group_matched = rc;
+                               }
+                           }
 			    alias_put(a);
 			    break;
 			}
 			/* FALLTHROUGH */
 		    case WORD:
 			if (group_matches(m->name, runas_gr))
-			    group_matched = !m->negated;
+			    group_matched = m->negated ? DENY : ALLOW;
 			break;
 		}
-		if (group_matched != UNSPEC) {
+		if (SPECIFIED(group_matched)) {
 		    if (matching_group != NULL && m->type != ALIAS)
 			*matching_group = m;
 		    break;
 		}
 	    }
 	}
-	if (group_matched == UNSPEC) {
+	if (!SPECIFIED(group_matched)) {
 	    struct gid_list *runas_groups;
 	    /*
 	     * The runas group was not explicitly allowed by sudoers.
@@ -299,7 +314,7 @@ hostlist_matches_int(struct sudoers_parse_tree *parse_tree,
 
     TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
 	matched = host_matches(parse_tree, pw, lhost, shost, m);
-	if (matched != UNSPEC)
+	if (SPECIFIED(matched))
 	    break;
     }
     debug_return_int(matched);
@@ -328,37 +343,41 @@ host_matches(struct sudoers_parse_tree *parse_tree, const struct passwd *pw,
     const char *lhost, const char *shost, const struct member *m)
 {
     struct alias *a;
-    int matched = UNSPEC;
+    int rc, matched = UNSPEC;
     debug_decl(host_matches, SUDOERS_DEBUG_MATCH)
 
     switch (m->type) {
 	case ALL:
-	    matched = !m->negated;
+	    matched = m->negated ? DENY : ALLOW;
 	    break;
 	case NETGROUP:
 	    if (netgr_matches(m->name, lhost, shost,
 		def_netgroup_tuple ? pw->pw_name : NULL))
-		matched = !m->negated;
+		matched = m->negated ? DENY : ALLOW;
 	    break;
 	case NTWKADDR:
 	    if (addr_matches(m->name))
-		matched = !m->negated;
+		matched = m->negated ? DENY : ALLOW;
 	    break;
 	case ALIAS:
 	    a = alias_get(parse_tree, m->name, HOSTALIAS);
 	    if (a != NULL) {
 		/* XXX */
-		int rc = hostlist_matches_int(parse_tree, pw, lhost, shost,
-		    &a->members);
-		if (rc != UNSPEC)
-		    matched = m->negated ? !rc : rc;
+                rc = hostlist_matches_int(parse_tree, pw, lhost, shost, &a->members);
+                if (SPECIFIED(rc)) {
+                    if (m->negated) {
+                        matched = rc == ALLOW ? DENY : ALLOW;
+                    } else {
+                        matched = rc;
+                    }
+                }
 		alias_put(a);
 		break;
 	    }
 	    /* FALLTHROUGH */
 	case WORD:
 	    if (hostname_matches(shost, lhost, m->name))
-		matched = !m->negated;
+		matched = m->negated ? DENY : ALLOW;
 	    break;
     }
     debug_return_int(matched);
@@ -378,7 +397,7 @@ cmndlist_matches(struct sudoers_parse_tree *parse_tree,
 
     TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
 	matched = cmnd_matches(parse_tree, m);
-	if (matched != UNSPEC)
+	if (SPECIFIED(matched))
 	    break;
     }
     debug_return_int(matched);
@@ -398,21 +417,26 @@ cmnd_matches(struct sudoers_parse_tree *parse_tree, const struct member *m)
 
     switch (m->type) {
 	case ALL:
-	    matched = !m->negated;
+	    matched = m->negated ? DENY : ALLOW;
 	    break;
 	case ALIAS:
 	    a = alias_get(parse_tree, m->name, CMNDALIAS);
 	    if (a != NULL) {
 		rc = cmndlist_matches(parse_tree, &a->members);
-		if (rc != UNSPEC)
-		    matched = m->negated ? !rc : rc;
+		if (SPECIFIED(rc)) {
+                   if (m->negated) {
+                       matched = rc == ALLOW ? DENY : ALLOW;
+                   } else {
+                       matched = rc;
+                   }
+               }
 		alias_put(a);
 	    }
 	    break;
 	case COMMAND:
 	    c = (struct sudo_command *)m->name;
 	    if (command_matches(c->cmnd, c->args, c->digest))
-		matched = !m->negated;
+		matched = m->negated ? DENY : ALLOW;
 	    break;
     }
     debug_return_int(matched);
diff --git a/plugins/sudoers/parse.c b/plugins/sudoers/parse.c
index c44f5fe..c0dc4a1 100644
--- a/plugins/sudoers/parse.c
+++ b/plugins/sudoers/parse.c
@@ -155,7 +155,7 @@ sudoers_lookup_check(struct sudo_nss *nss, struct passwd *pw,
 		    NULL);
 		if (runas_match == ALLOW) {
 		    cmnd_match = cmnd_matches(nss->parse_tree, cs->cmnd);
-		    if (cmnd_match != UNSPEC) {
+		    if (SPECIFIED(cmnd_match)) {
 			/*
 			 * If user is running command as himself,
 			 * set runas_pw = sudo_user.pw.
@@ -819,7 +819,7 @@ display_cmnd_check(struct sudoers_parse_tree *parse_tree, struct passwd *pw,
 		    cs->runasgrouplist, NULL, NULL);
 		if (runas_match == ALLOW) {
 		    cmnd_match = cmnd_matches(parse_tree, cs->cmnd);
-		    if (cmnd_match != UNSPEC)
+		    if (SPECIFIED(cmnd_match))
 			debug_return_int(cmnd_match);
 		}
 	    }
diff --git a/plugins/sudoers/parse.h b/plugins/sudoers/parse.h
index 9192975..b9c8f2c 100644
--- a/plugins/sudoers/parse.h
+++ b/plugins/sudoers/parse.h
@@ -22,6 +22,11 @@
 
 #include "sudo_queue.h"
 
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <sys/stat.h>
+
 /* Characters that must be quoted in sudoers. */
 #define SUDOERS_QUOTED	":\\,=#\""
 
@@ -30,13 +35,25 @@
 
 #undef UNSPEC
 #define UNSPEC	-1
+
+/* Denied by policy (rowhammer resistent). */
 #undef DENY
-#define DENY	 0
+#define DENY    0xad5d6da      /* 1010110101011101011011011010 */
+
+/* Allowed by policy (rowhammer resistent). */
 #undef ALLOW
-#define ALLOW	 1
+#define ALLOW   0x52a2925      /* 0101001010100010100100100101 */
+
 #undef IMPLIED
 #define IMPLIED	 2
 
+/*
+ * We must explicitly check against ALLOW and DENY instead testing
+ * that the value is not UNSPEC to avoid potential ROWHAMMER issues.
+ */
+#define SPECIFIED(_v)  ((_v) == ALLOW || (_v) == DENY)
+
+
 /*
  * Initialize all tags to UNSPEC.
  */
-- 
2.24.4

