
# HG changeset patch
# User Todd C. Miller <Todd.Miller@sudo.ws>
# Date 1580354121 25200
# Node ID 84640592b0ff59ea6514d0632beb87e81d2c298f
# Parent  b5ba461a0c1ce438259bc155ba44bdb831e55f49
Fix a buffer overflow when pwfeedback is enabled and input is a not a tty.
In getln() if the user enters ^U (erase line) and the write(2) fails,
the remaining buffer size is reset but the current pointer is not.
While here, fix an incorrect break for erase when write(2) fails.
Also disable pwfeedback when input is not a tty as it cannot work.
CVE-2019-18634
Credit: Joe Vennix from Apple Information Security.

Upstream-Status: Backport
https://www.sudo.ws/repos/sudo/rev/84640592b0ff
CVE: CVE-2019-18634
Signed-off-by: Armin Kuster <akuster@mvista.com>

Index: sudo-1.8.23/src/tgetpass.c
===================================================================
--- sudo-1.8.23.orig/src/tgetpass.c
+++ sudo-1.8.23/src/tgetpass.c
@@ -48,7 +48,7 @@ static volatile sig_atomic_t signo[NSIG]
 
 static bool tty_present(void);
 static void tgetpass_handler(int);
-static char *getln(int, char *, size_t, int);
+static char *getln(int, char *, size_t, bool);
 static char *sudo_askpass(const char *, const char *);
 
 static int
@@ -90,6 +90,7 @@ tgetpass(const char *prompt, int timeout
     static const char *askpass;
     static char buf[SUDO_CONV_REPL_MAX + 1];
     int i, input, output, save_errno, neednl = 0, need_restart;
+    bool feedback = ISSET(flags, TGP_MASK);
     debug_decl(tgetpass, SUDO_DEBUG_CONV)
 
     (void) fflush(stdout);
@@ -136,7 +137,7 @@ restart:
      */
     if (!ISSET(flags, TGP_ECHO)) {
 	for (;;) {
-	    if (ISSET(flags, TGP_MASK))
+	    if (feedback)
 		neednl = sudo_term_cbreak(input);
 	    else
 		neednl = sudo_term_noecho(input);
@@ -150,6 +151,9 @@ restart:
 	    }
 	}
     }
+    /* Only use feedback mode when we can disable echo. */
+    if (!neednl)
+	feedback = false;
 
     /*
      * Catch signals that would otherwise cause the user to end
@@ -175,7 +179,7 @@ restart:
 
     if (timeout > 0)
 	alarm(timeout);
-    pass = getln(input, buf, sizeof(buf), ISSET(flags, TGP_MASK));
+    pass = getln(input, buf, sizeof(buf), feedback);
     alarm(0);
     save_errno = errno;
 
@@ -305,7 +309,7 @@ sudo_askpass(const char *askpass, const
 extern int sudo_term_erase, sudo_term_kill;
 
 static char *
-getln(int fd, char *buf, size_t bufsiz, int feedback)
+getln(int fd, char *buf, size_t bufsiz, bool feedback)
 {
     size_t left = bufsiz;
     ssize_t nr = -1;
@@ -327,15 +331,15 @@ getln(int fd, char *buf, size_t bufsiz,
 		while (cp > buf) {
 		    if (write(fd, "\b \b", 3) == -1)
 			break;
-		    --cp;
+		    cp--;
 		}
+		cp = buf;
 		left = bufsiz;
 		continue;
 	    } else if (c == sudo_term_erase) {
 		if (cp > buf) {
-		    if (write(fd, "\b \b", 3) == -1)
-			break;
-		    --cp;
+		    ignore_result(write(fd, "\b \b", 3));
+		    cp--;
 		    left++;
 		}
 		continue;
