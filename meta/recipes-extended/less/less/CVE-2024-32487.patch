From 41b7fd07c5c3e12149cf255486091da16d462a1d Mon Sep 17 00:00:00 2001
From: Vivek Kumbhar <vkumbhar@mvista.com>
Date: Mon, 20 May 2024 14:19:08 +0000
Subject: [PATCH] CVE-2024-32487

---
 filename.c | 77 +++++++++++++++++++++++++++++++++++-------------------
 funcs.h    |  2 +-
 lang.h     | 57 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 108 insertions(+), 28 deletions(-)
 create mode 100644 lang.h

diff --git a/filename.c b/filename.c
index 62cc6e5..f178851 100644
--- a/filename.c
+++ b/filename.c
@@ -15,6 +15,7 @@

 #include "less.h"
 #include "lglob.h"
+#include "lang.h"
 #if MSDOS_COMPILER
 #include <dos.h>
 #if MSDOS_COMPILER==WIN32C && !defined(_MSC_VER)
@@ -132,37 +133,43 @@ metachars()
 /*
  * Is this a shell metacharacter?
  */
-	static int
-metachar(c)
-	char c;
+        static lbool metachar(char c)
 {
	return (strchr(metachars(), c) != NULL);
 }

+/*
+ * Must use quotes rather than escape char for this metachar?
+ */
+static lbool must_quote(char c)
+{
+	/* {{ Maybe the set of must_quote chars should be configurable? }} */
+	return (c == '\n');
+}
+
 /*
  * Insert a backslash before each metacharacter in a string.
  */
-	public char *
-shell_quote(s)
-	char *s;
+public char * shell_quoten(constant char *s, size_t slen)
 {
-	char *p;
+	constant char *p;
+	char *np;
	char *newstr;
-	int len;
-	char *esc = get_meta_escape();
-	int esclen = (int) strlen(esc);
-	int use_quotes = 0;
-	int have_quotes = 0;
+	size_t len;
+	constant char *esc = get_meta_escape();
+	size_t esclen = strlen(esc);
+	lbool use_quotes = FALSE;
+	lbool have_quotes = FALSE;

	/*
	 * Determine how big a string we need to allocate.
	 */
	len = 1; /* Trailing null byte */
-	for (p = s;  *p != '\0';  p++)
+	for (p = s;  p < s + slen;  p++)
	{
		len++;
		if (*p == openquote || *p == closequote)
-			have_quotes = 1;
+			have_quotes = TRUE;
		if (metachar(*p))
		{
			if (esclen == 0)
@@ -171,7 +178,10 @@ shell_quote(s)
				 * We've got a metachar, but this shell
				 * doesn't support escape chars.  Use quotes.
				 */
-				use_quotes = 1;
+				use_quotes = TRUE;
+			} else if (must_quote(*p))
+			{
+				len += 3; /* open quote + char + close quote */
			} else
			{
				/*
@@ -188,34 +198,47 @@ shell_quote(s)
			 * We can't quote a string that contains quotes.
			 */
			return (NULL);
-		len = (int) strlen(s) + 3;
+		len = slen + 3;
	}
	/*
	 * Allocate and construct the new string.
	 */
-	newstr = p = (char *) ecalloc(len, sizeof(char));
+	newstr = np = (char *) ecalloc(len, sizeof(char));
	if (use_quotes)
	{
-		SNPRINTF3(newstr, len, "%c%s%c", openquote, s, closequote);
+		SNPRINTF4(newstr, len, "%c%.*s%c", openquote, (int) slen, s, closequote);
	} else
	{
-		while (*s != '\0')
+		constant char *es = s + slen;
+		while (s < es)
		{
-			if (metachar(*s))
+			if (!metachar(*s))
			{
-				/*
-				 * Add the escape char.
-				 */
-				strcpy(p, esc);
-				p += esclen;
+				*np++ = *s++;
+			} else if (must_quote(*s))
+			{
+				/* Surround the char with quotes. */
+				*np++ = openquote;
+				*np++ = *s++;
+				*np++ = closequote;
+			} else
+			{
+				/* Insert an escape char before the char. */
+				strcpy(np, esc);
+				np += esclen;
+				*np++ = *s++;
			}
-			*p++ = *s++;
		}
-		*p = '\0';
+		*np = '\0';
	}
	return (newstr);
 }

+public char * shell_quote(constant char *s)
+{
+	return shell_quoten(s, strlen(s));
+}
+
 /*
  * Return a pathname that points to a specified file in a specified directory.
  * Return NULL if the file does not exist in the directory.
diff --git a/funcs.h b/funcs.h
index ac63c37..86a51ab 100644
--- a/funcs.h
+++ b/funcs.h
@@ -118,7 +118,7 @@
	public void use_logfile ();
	public char * shell_unquote ();
	public char * get_meta_escape ();
-	public char * shell_quote ();
+	public char * shell_quote (constant char *s);
	public char * homefile ();
	public char * fexpand ();
	public char * fcomplete ();
diff --git a/lang.h b/lang.h
new file mode 100644
index 0000000..cf7b471
--- /dev/null
+++ b/lang.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 1984-2024  Mark Nudelman
+ *
+ * You may distribute under the terms of either the GNU General Public
+ * License or the Less License, as specified in the README file.
+ *
+ * For more information, see the README file.
+ */
+
+#ifndef LESS_LANG_H_
+#define LESS_LANG_H_ 1
+
+/*
+ * C language details.
+ */
+#if HAVE_CONST
+#define constant        const
+#else
+#define constant
+#endif
+
+/*
+ * mutable is the opposite of constant.
+ * It documents that a pointer parameter will be written through by the
+ * called function, more directly than by the mere absence of "constant".
+ */
+#define mutable
+
+#define public          /* PUBLIC FUNCTION */
+
+#undef  ptr_diff
+#define ptr_diff(p1,p2)  ((size_t) ((p1)-(p2)))
+#undef  countof
+#define countof(a)       ((int)(sizeof(a)/sizeof(*a)))
+
+#define size_t_null      ((size_t)-1)
+
+#ifndef NULL
+#define NULL    0
+#endif
+
+typedef enum lbool { LFALSE, LTRUE } lbool;
+
+#undef  TRUE
+#define TRUE  LTRUE
+#undef  FALSE
+#define FALSE LFALSE
+
+#ifdef _MSC_VER
+#if _WIN64
+typedef __int64 ssize_t;
+#else
+typedef __int32 ssize_t;
+#endif
+#endif
+
+#endif //  LESS_LANG_H_
--
2.18.2
