From 6ab4c101237ddb0ab643b031ad27c9e50920d978 Mon Sep 17 00:00:00 2001
From: Hitendra Prajapati <hprajapati@mvista.com>
Date: Thu, 31 Mar 2022 09:50:55 +0530
Subject: [PATCH] CVE-2022-23098

Upstream-Status: Backport from
https://git.kernel.org/pub/scm/network/connman/connman.git/commit/?id=d8708b85c1e8fe25af7803e8a20cf20e7201d8a4 && https://git.kernel.org/pub/scm/network/connman/connman.git/commit/?id=5c34313a196515c80fe78a2862ad78174b985be5

dnsproxy: Avoid 100 % busy loop in TCP server case
Once the TCP socket is connected and until the remote server is
responding (if ever) ConnMan executes a 100 % CPU loop, since
the connected socket will always be writable (G_IO_OUT).

To fix this, modify the watch after the connection is established to
remove the G_IO_OUT from the callback conditions.

Fixes: CVE-2022-23098

author		Matthias Gerstner <mgerstner@suse.de>	2022-01-25 10:00:25 +0100
committer	Daniel Wagner <wagi@monom.org>	2022-01-25 10:09:43 +0100

Signed-off-by: Hitendra Prajapati <hprajapati@mvista.com>
---
 src/dnsproxy.c | 17 ++++++++++++-----
 1 file changed, 12 insertions(+), 5 deletions(-)

diff --git a/src/dnsproxy.c b/src/dnsproxy.c
index 40b4f15..e63166e 100644
--- a/src/dnsproxy.c
+++ b/src/dnsproxy.c
@@ -2319,14 +2319,21 @@ hangup:
 			}
 		}
 
+		/*
+		 * Remove the G_IO_OUT flag from the watch, otherwise we end
+		 * up in a busy loop, because the socket is constantly writable.
+		 *
+		 * There seems to be no better way in g_io to do that than
+		 * re-adding the watch.
+		 */
+		g_source_remove(server->watch);
+		server->watch = g_io_add_watch(server->channel,
+			G_IO_IN | G_IO_HUP | G_IO_NVAL | G_IO_ERR,
+			tcp_server_event, server);
+
 		server->connected = true;
 		server_list = g_slist_append(server_list, server);
 
-		if (server->timeout > 0) {
-			g_source_remove(server->timeout);
-			server->timeout = 0;
-		}
-
 		for (list = request_list; list; ) {
 			struct request_data *req = list->data;
 			int status;
-- 
2.25.1

