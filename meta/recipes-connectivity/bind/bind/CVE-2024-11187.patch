From 89b256efae2d7ed61690fc241a661194481c815d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ond=C5=99ej=20Sur=C3=BD?= <ondrej@isc.org>
Date: Thu, 19 Dec 2024 16:40:52 +0100
Subject: [PATCH] Limit the additional processing for large RDATA sets

When answering queries, don't add data to the additional section if
the answer has more than 13 names in the RDATA.  This limits the
number of lookups into the database(s) during a single client query,
reducing query processing load.

Also, don't append any additional data to type=ANY queries. The
answer to ANY is already big enough.

(cherry picked from commit a1982cf1bb95c818aa7b58988b5611dec80f2408)

Upstream-Status: Backport [https://gitlab.isc.org/isc-projects/bind9/-/commit/89b256efae2d7ed61690fc241a661194481c815d]
CVE: CVE-2024-11187
Signed-off-by: Vijay Anusuri <vanusuri@mvista.com>
---
 bin/named/query.c              |  8 +++++---
 lib/dns/include/dns/rdataset.h | 10 +++++++++-
 lib/dns/rdataset.c             |  8 +++++++-
 lib/dns/resolver.c             | 16 ++++++++++------
 4 files changed, 31 insertions(+), 11 deletions(-)

diff --git a/bin/named/query.c b/bin/named/query.c
index f109805..44480c5 100644
--- a/bin/named/query.c
+++ b/bin/named/query.c
@@ -1827,7 +1827,8 @@ query_addadditional(void *arg, dns_name_t *name, dns_rdatatype_t qtype) {
 		 */
 		eresult = dns_rdataset_additionaldata(trdataset,
 						      query_addadditional,
-						      client);
+						      client,
+						      DNS_RDATASET_MAXADDITIONAL);
 	}
 
  cleanup:
@@ -2422,7 +2423,7 @@ query_addrdataset(ns_client_t *client, dns_name_t *fname,
 						       rdataset->rdclass);
 	rdataset->attributes |= DNS_RDATASETATTR_LOADORDER;
 
-	if (NOADDITIONAL(client))
+	if (NOADDITIONAL(client) || client->query.qtype == dns_rdatatype_any)
 		return;
 
 	/*
@@ -2433,7 +2434,8 @@ query_addrdataset(ns_client_t *client, dns_name_t *fname,
 	additionalctx.client = client;
 	additionalctx.rdataset = rdataset;
 	(void)dns_rdataset_additionaldata(rdataset, query_addadditional2,
-					  &additionalctx);
+					  &additionalctx,
+					  DNS_RDATASET_MAXADDITIONAL);
 	CTRACE(ISC_LOG_DEBUG(3), "query_addrdataset: done");
 }
 
diff --git a/lib/dns/include/dns/rdataset.h b/lib/dns/include/dns/rdataset.h
index ed9119a..cd9b014 100644
--- a/lib/dns/include/dns/rdataset.h
+++ b/lib/dns/include/dns/rdataset.h
@@ -53,6 +53,8 @@
 #include <dns/types.h>
 #include <dns/rdatastruct.h>
 
+#define DNS_RDATASET_MAXADDITIONAL 13
+
 ISC_LANG_BEGINDECLS
 
 typedef enum {
@@ -471,7 +473,8 @@ dns_rdataset_towirepartial(dns_rdataset_t *rdataset,
 
 isc_result_t
 dns_rdataset_additionaldata(dns_rdataset_t *rdataset,
-			    dns_additionaldatafunc_t add, void *arg);
+			    dns_additionaldatafunc_t add, void *arg,
+			    size_t limit);
 /*%<
  * For each rdata in rdataset, call 'add' for each name and type in the
  * rdata which is subject to additional section processing.
@@ -490,10 +493,15 @@ dns_rdataset_additionaldata(dns_rdataset_t *rdataset,
  *\li	If a call to dns_rdata_additionaldata() is not successful, the
  *	result returned will be the result of dns_rdataset_additionaldata().
  *
+ *\li	If 'limit' is non-zero and the number of the rdatasets is larger
+ *	than 'limit', no additional data will be processed.
+ *
  * Returns:
  *
  *\li	#ISC_R_SUCCESS
  *
+ *\li	#DNS_R_TOOMANYRECORDS in case rdataset count is larger than 'limit'
+ *
  *\li	Any error that dns_rdata_additionaldata() can return.
  */
 
diff --git a/lib/dns/rdataset.c b/lib/dns/rdataset.c
index b42dea5..75f07c9 100644
--- a/lib/dns/rdataset.c
+++ b/lib/dns/rdataset.c
@@ -28,6 +28,7 @@
 #include <dns/ncache.h>
 #include <dns/rdata.h>
 #include <dns/rdataset.h>
+#include <dns/result.h>
 
 static const char *trustnames[] = {
 	"none",
@@ -607,7 +608,8 @@ dns_rdataset_towire(dns_rdataset_t *rdataset,
 
 isc_result_t
 dns_rdataset_additionaldata(dns_rdataset_t *rdataset,
-			    dns_additionaldatafunc_t add, void *arg)
+			    dns_additionaldatafunc_t add, void *arg,
+			    size_t limit)
 {
 	dns_rdata_t rdata = DNS_RDATA_INIT;
 	isc_result_t result;
@@ -620,6 +622,10 @@ dns_rdataset_additionaldata(dns_rdataset_t *rdataset,
 	REQUIRE(DNS_RDATASET_VALID(rdataset));
 	REQUIRE((rdataset->attributes & DNS_RDATASETATTR_QUESTION) == 0);
 
+	if (limit != 0 && dns_rdataset_count(rdataset) > limit) {
+		return (DNS_R_TOOMANYRECORDS);
+	}
+
 	result = dns_rdataset_first(rdataset);
 	if (result != ISC_R_SUCCESS)
 		return (result);
diff --git a/lib/dns/resolver.c b/lib/dns/resolver.c
index ac9a9ef..ea425af 100644
--- a/lib/dns/resolver.c
+++ b/lib/dns/resolver.c
@@ -6461,7 +6461,7 @@ chase_additional(fetchctx_t *fctx, dns_message_t *rmessage) {
 				rdataset->attributes &= ~DNS_RDATASETATTR_CHASE;
 				(void)dns_rdataset_additionaldata(rdataset,
 								  check_related,
-								  &chkarg);
+								  &chkarg, 0);
 				rescan = true;
 			}
 		}
@@ -7095,8 +7095,12 @@ noanswer_response(fetchctx_t *fctx, dns_message_t *message,
 		FCTX_ATTR_SET(fctx, FCTX_ATTR_GLUING);
 		chkarg.fctx = fctx;
 		chkarg.rmessage = message;
+
+		/*
+		 * Mark the glue records in the additional section to be cached.
+		 */
 		(void)dns_rdataset_additionaldata(ns_rdataset, check_related,
-						  &chkarg);
+						  &chkarg, 0);
 #if CHECK_FOR_GLUE_IN_ANSWER
 		/*
 		 * Look in the answer section for "glue" that is incorrectly
@@ -7112,7 +7116,7 @@ noanswer_response(fetchctx_t *fctx, dns_message_t *message,
 			chkarg.fcx = fctx;
 			chkarg.rmessage = message;
 			(void)dns_rdataset_additionaldata(ns_rdataset,
-							  check_answer, &chkarg);
+							  check_answer, &chkarg, 0);
 		}
 #endif
 		FCTX_ATTR_CLR(fctx, FCTX_ATTR_GLUING);
@@ -7354,7 +7358,7 @@ answer_response(fetchctx_t *fctx, dns_message_t *message) {
 			chkarg.rmessage = message;
 			(void)dns_rdataset_additionaldata(rdataset,
 							  check_related,
-							  &chkarg);
+							  &chkarg, 0);
 		}
 	} else if (aname != NULL) {
 		dns_chkarg_t chkarg;
@@ -7382,7 +7386,7 @@ answer_response(fetchctx_t *fctx, dns_message_t *message) {
 		chkarg.fctx = fctx;
 		chkarg.rmessage = message;
 		(void)dns_rdataset_additionaldata(ardataset, check_related,
-						  &chkarg);
+						  &chkarg, 0);
 		for (sigrdataset = ISC_LIST_HEAD(aname->list);
 		     sigrdataset != NULL;
 		     sigrdataset = ISC_LIST_NEXT(sigrdataset, link)) {
@@ -7545,7 +7549,7 @@ answer_response(fetchctx_t *fctx, dns_message_t *message) {
 					(void)dns_rdataset_additionaldata(
 							rdataset,
 							check_related,
-							&chkarg);
+							&chkarg, 0);
 					done = true;
 				}
 			}
-- 
2.18.1

