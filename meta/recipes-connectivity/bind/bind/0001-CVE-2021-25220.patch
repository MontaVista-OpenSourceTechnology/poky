From 125b1e85ac35233bfd80675aac49c8afb338f584 Mon Sep 17 00:00:00 2001
From: Vijay Anusuri <vanusuri@mvista.com>
Date: Fri, 5 Aug 2022 10:50:11 +0000
Subject: [PATCH] CVE-2021-25220

prevent cache poisoning from forwarder responses

Upstream-Status: Backport from https://gitlab.isc.org/isc-projects/bind9/-/commit/fc9cb6cf91c1a36b797ffef0a277dbb3989d43dc
CVE: CVE-2021-25220
Signed-off-by: Vijay Anusuri <vanusuri@mvista.com>
---
 CHANGES            |   5 ++
 lib/dns/resolver.c | 128 +++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 128 insertions(+), 5 deletions(-)

diff --git a/CHANGES b/CHANGES
index 10c44ab..9123e14 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,3 +1,8 @@
+5817.  [security]     The rules for acceptance of records into the cache
+                      have been tightened to prevent the possibility of
+                      poisoning if forwarders send records outside
+                      the configured bailiwick. (CVE-2021-25220) [GL #2950]
+
 4997.	[security]	named could crash during recursive processing
 			of DNAME records when "deny-answer-aliases" was
 			in use. (CVE-2018-5740) [GL #387]
diff --git a/lib/dns/resolver.c b/lib/dns/resolver.c
index c6b6690..a1483b5 100644
--- a/lib/dns/resolver.c
+++ b/lib/dns/resolver.c
@@ -68,6 +68,7 @@
 #include <dns/stats.h>
 #include <dns/tsig.h>
 #include <dns/validator.h>
+#include <dns/zone.h>
 
 #ifdef WANT_QUERYTRACE
 #define RTRACE(m)       isc_log_write(dns_lctx, \
@@ -310,6 +311,8 @@ struct fetchctx {
 	isc_boolean_t			ns_ttl_ok;
 	isc_uint32_t			ns_ttl;
 	isc_counter_t *			qc;
+        dns_fixedname_t                 fwdfname;
+        dns_name_t                      *fwdname;
 
 	/*%
 	 * The number of events we're waiting for.
@@ -3207,6 +3210,7 @@ fctx_getaddresses(fetchctx_t *fctx, isc_boolean_t badcache) {
 		if (result == ISC_R_SUCCESS) {
 			fwd = ISC_LIST_HEAD(forwarders->fwdrs);
 			fctx->fwdpolicy = forwarders->fwdpolicy;
+                        dns_name_copy(domain, fctx->fwdname, NULL);
 			if (fctx->fwdpolicy == dns_fwdpolicy_only &&
 			    isstrictsubdomain(domain, &fctx->domain)) {
 #ifdef ENABLE_FETCHLIMIT
@@ -4251,6 +4255,10 @@ fctx_create(dns_resolver_t *res, dns_name_t *name, dns_rdatatype_t type,
 	fctx->restarts = 0;
 	fctx->querysent = 0;
 	fctx->referrals = 0;
+
+        dns_fixedname_init(&fctx->fwdfname);
+        fctx->fwdname = dns_fixedname_name(&fctx->fwdfname);
+
 	TIME_NOW(&fctx->start);
 	fctx->timeouts = 0;
 	fctx->lamecount = 0;
@@ -4304,8 +4312,10 @@ fctx_create(dns_resolver_t *res, dns_name_t *name, dns_rdatatype_t type,
 		domain = dns_fixedname_name(&fixed);
 		result = dns_fwdtable_find2(fctx->res->view->fwdtable, fwdname,
 					    domain, &forwarders);
-		if (result == ISC_R_SUCCESS)
+		if (result == ISC_R_SUCCESS) {
 			fctx->fwdpolicy = forwarders->fwdpolicy;
+                        dns_name_copy(domain, fctx->fwdname, NULL);
+                }
 
 		if (fctx->fwdpolicy != dns_fwdpolicy_only) {
 			/*
@@ -5986,6 +5996,109 @@ mark_related(dns_name_t *name, dns_rdataset_t *rdataset,
 		rdataset->attributes |= DNS_RDATASETATTR_EXTERNAL;
 }
 
+/*
+ * Returns true if 'name' is external to the namespace for which
+ * the server being queried can answer, either because it's not a
+ * subdomain or because it's below a forward declaration or a
+ * locally served zone.
+ */
+static inline isc_boolean_t
+name_external(dns_name_t *name, dns_rdatatype_t type, fetchctx_t *fctx) {
+        isc_result_t result;
+        dns_forwarders_t *forwarders = NULL;
+        dns_fixedname_t fixed, zfixed;
+        dns_fixedname_init(&fixed);
+        dns_fixedname_init(&zfixed);
+        dns_name_t *fname = dns_fixedname_name(&fixed);
+        dns_name_t *zfname = dns_fixedname_name(&zfixed);
+        dns_name_t *apex = NULL;
+        dns_name_t suffix;
+        dns_zone_t *zone = NULL;
+        unsigned int labels;
+        dns_namereln_t rel;
+
+        apex = ISFORWARDER(fctx->addrinfo) ? fctx->fwdname : &fctx->domain;
+
+        /*
+         * The name is outside the queried namespace.
+         */
+        rel = dns_name_fullcompare(name, apex, &(int){ 0 },
+                                   &(unsigned int){ 0U });
+        if (rel != dns_namereln_subdomain && rel != dns_namereln_equal) {
+                return (ISC_TRUE);
+        }
+
+        /*
+         * If the record lives in the parent zone, adjust the name so we
+         * look for the correct zone or forward clause.
+         */
+        labels = dns_name_countlabels(name);
+        if (dns_rdatatype_atparent(type) && labels > 1U) {
+                dns_name_init(&suffix, NULL);
+                dns_name_getlabelsequence(name, 1, labels - 1, &suffix);
+                name = &suffix;
+        } else if (rel == dns_namereln_equal) {
+                /* If 'name' is 'apex', no further checking is needed. */
+                return (ISC_FALSE);
+        }
+
+        /*
+         * If there is a locally served zone between 'apex' and 'name'
+         * then don't cache.
+         */
+        LOCK(&fctx->res->view->lock);
+        if (fctx->res->view->zonetable != NULL) {
+                unsigned int options = DNS_ZTFIND_NOEXACT;
+                result = dns_zt_find(fctx->res->view->zonetable, name, options,
+                                     zfname, &zone);
+                if (zone != NULL) {
+                        dns_zone_detach(&zone);
+                }
+                if (result == ISC_R_SUCCESS || result == DNS_R_PARTIALMATCH) {
+                        if (dns_name_fullcompare(zfname, apex, &(int){ 0 },
+                                                 &(unsigned int){ 0U }) ==
+                            dns_namereln_subdomain)
+                        {
+                                UNLOCK(&fctx->res->view->lock);
+                                return (ISC_TRUE);
+                        }
+                }
+        }
+        UNLOCK(&fctx->res->view->lock);
+
+        /*
+         * Look for a forward declaration below 'name'.
+         */
+        result = dns_fwdtable_find2(fctx->res->view->fwdtable, name, fname,
+                                    &forwarders);
+
+        if (ISFORWARDER(fctx->addrinfo)) {
+                /*
+                 * See if the forwarder declaration is better.
+                 */
+                if (result == ISC_R_SUCCESS) {
+                        return (!dns_name_equal(fname, fctx->fwdname));
+                }
+
+                /*
+                 * If the lookup failed, the configuration must have
+                 * changed: play it safe and don't cache.
+                 */
+                return (ISC_TRUE);
+        } else if (result == ISC_R_SUCCESS &&
+                   forwarders->fwdpolicy == dns_fwdpolicy_only &&
+                   !ISC_LIST_EMPTY(forwarders->fwdrs))
+        {
+               /*
+                * If 'name' is covered by a 'forward only' clause then we
+                * can't cache this repsonse.
+                */
+               return (ISC_TRUE);
+        }
+
+        return (ISC_FALSE);
+}
+
 static isc_result_t
 check_section(void *arg, dns_name_t *addname, dns_rdatatype_t type,
 	      dns_section_t section)
@@ -6014,7 +6127,7 @@ check_section(void *arg, dns_name_t *addname, dns_rdatatype_t type,
 	result = dns_message_findname(fctx->rmessage, section, addname,
 				      dns_rdatatype_any, 0, &name, NULL);
 	if (result == ISC_R_SUCCESS) {
-		external = ISC_TF(!dns_name_issubdomain(name, &fctx->domain));
+                external = ISC_TF(name_external(name, type, fctx));
 		if (type == dns_rdatatype_a) {
 			for (rdataset = ISC_LIST_HEAD(name->list);
 			     rdataset != NULL;
@@ -6871,6 +6984,13 @@ answer_response(fetchctx_t *fctx) {
 			break;
 
 		case dns_namereln_subdomain:
+                        /*
+                         * Don't accept DNAME from parent namespace.
+                         */
+                        if (name_external(name, dns_rdatatype_dname, fctx)) {
+                                continue;
+                        }
+
 			/*
 			 * In-scope DNAME records must have at least
 			 * as many labels as the domain being queried.
@@ -7099,11 +7219,9 @@ answer_response(fetchctx_t *fctx) {
 	 */
 	result = dns_message_firstname(message, DNS_SECTION_AUTHORITY);
 	while (!done && result == ISC_R_SUCCESS) {
-		isc_boolean_t external;
 		name = NULL;
 		dns_message_currentname(message, DNS_SECTION_AUTHORITY, &name);
-		external = ISC_TF(!dns_name_issubdomain(name, &fctx->domain));
-		if (!external) {
+                if (ISC_TF(!name_external(name, dns_rdatatype_ns, fctx))) {
 			/*
 			 * We expect to find NS or SIG NS rdatasets, and
 			 * nothing else.
-- 
2.18.2

