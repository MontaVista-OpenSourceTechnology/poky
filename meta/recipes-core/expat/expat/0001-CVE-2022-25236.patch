From f0b129c2c8259cfc8350691901f9b41023ff1ae4 Mon Sep 17 00:00:00 2001
From: Hitendra Prajapati <hprajapati@mvista.com>
Date: Thu, 14 Apr 2022 09:21:32 +0530
Subject: [PATCH] CVE-2022-25236

Upstream-Status: Backport from https://github.com/libexpat/libexpat/pull/561/commits

Signed-off-by: Steve Sakoman <steve@sakoman.com>
Signed-off-by: Hitendra Prajapati <hprajapati@mvista.com>
---
 lib/xmlparse.c   | 17 +++++++++++++----
 tests/runtests.c | 30 ++++++++++++++++++++++++++++++
 2 files changed, 43 insertions(+), 4 deletions(-)

diff --git a/lib/xmlparse.c b/lib/xmlparse.c
index 56abf98..dbb7957 100644
--- a/lib/xmlparse.c
+++ b/lib/xmlparse.c
@@ -738,8 +738,7 @@ XML_ParserCreate(const XML_Char *encodingName)
 XML_Parser XMLCALL
 XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep)
 {
-  XML_Char tmp[2];
-  *tmp = nsSep;
+  XML_Char tmp[2] = {nsSep, 0};
   return XML_ParserCreate_MM(encodingName, NULL, tmp);
 }
 
@@ -1358,8 +1357,7 @@ XML_ExternalEntityParserCreate(XML_Parser oldParser,
      would be otherwise.
   */
   if (ns) {
-    XML_Char tmp[2];
-    *tmp = namespaceSeparator;
+    XML_Char tmp[2] = {parser->m_namespaceSeparator, 0};
     parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);
   }
   else {
@@ -3710,6 +3708,17 @@ addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,
     if (!mustBeXML && isXMLNS
         && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))
       isXMLNS = XML_FALSE;
+
+    // NOTE: While Expat does not validate namespace URIs against RFC 3986,
+    //       we have to at least make sure that the XML processor on top of
+    //       Expat (that is splitting tag names by namespace separator into
+    //       2- or 3-tuples (uri-local or uri-local-prefix)) cannot be confused
+    //       by an attacker putting additional namespace separator characters
+    //       into namespace declarations.  That would be ambiguous and not to
+    //       be expected.
+    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)) {
+      return XML_ERROR_SYNTAX;
+    }
   }
   isXML = isXML && len == xmlLen;
   isXMLNS = isXMLNS && len == xmlnsLen;
diff --git a/tests/runtests.c b/tests/runtests.c
index 4be6d80..751ae1f 100644
--- a/tests/runtests.c
+++ b/tests/runtests.c
@@ -7685,6 +7685,35 @@ START_TEST(test_ns_double_colon_doctype)
 }
 END_TEST
 
+START_TEST(test_ns_separator_in_uri) {
+  struct test_case {
+    enum XML_Status expectedStatus;
+    const char *doc;
+  };
+  struct test_case cases[] = {
+      {XML_STATUS_OK, "<doc xmlns='one_two' />"},
+      {XML_STATUS_ERROR, "<doc xmlns='one&#x0A;two' />"},
+  };
+
+  size_t i = 0;
+  size_t failCount = 0;
+  for (; i < sizeof(cases) / sizeof(cases[0]); i++) {
+    XML_Parser parser = XML_ParserCreateNS(NULL, '\n');
+    XML_SetElementHandler(parser, dummy_start_element, dummy_end_element);
+    if (XML_Parse(parser, cases[i].doc, (int)strlen(cases[i].doc),
+                  /*isFinal*/ XML_TRUE)
+        != cases[i].expectedStatus) {
+      failCount++;
+    }
+    XML_ParserFree(parser);
+  }
+
+  if (failCount) {
+    fail("Namespace separator handling is broken");
+  }
+}
+END_TEST
+
 /* Control variable; the number of times duff_allocator() will successfully allocate */
 #define ALLOC_ALWAYS_SUCCEED (-1)
 #define REALLOC_ALWAYS_SUCCEED (-1)
@@ -12010,6 +12039,7 @@ make_suite(void)
     tcase_add_test(tc_namespace, test_ns_utf16_doctype);
     tcase_add_test(tc_namespace, test_ns_invalid_doctype);
     tcase_add_test(tc_namespace, test_ns_double_colon_doctype);
+    tcase_add_test(tc_namespace, test_ns_separator_in_uri);
 
     suite_add_tcase(s, tc_misc);
     tcase_add_checked_fixture(tc_misc, NULL, basic_teardown);
-- 
2.25.1

