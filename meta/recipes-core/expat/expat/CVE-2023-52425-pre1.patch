From 2cfd6d02313b453ac4a57d37e9f74592c0869719 Mon Sep 17 00:00:00 2001
From: Vijay Anusuri <vanusuri@mvista.com>
Date: Fri, 4 Apr 2025 11:02:35 +0000
Subject: [PATCH] CVE-2023-52425-pre1

several prerequisite changes to test suite.

Upstream-Status: Backport [import from debian https://salsa.debian.org/lts-team/packages/expat/-/commit/9cbef6817eaccf0875263102810887571f257e8f]
CVE: CVE-2023-52425 #Dependency Patch
Signed-off-by: Vijay Anusuri <vanusuri@mvista.com>
---
 tests/runtests.c | 436 ++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 333 insertions(+), 103 deletions(-)

diff --git a/tests/runtests.c b/tests/runtests.c
index d30f5b1..9c00ad9 100644
--- a/tests/runtests.c
+++ b/tests/runtests.c
@@ -108,6 +108,9 @@ typedef unsigned __int64 uint64_t;
 
 static XML_Parser g_parser = NULL;
 
+/* Used to control _XML_Parse_SINGLE_BYTES() chunk size */
+int g_chunkSize = 1;
+
 static void
 basic_setup(void) {
   g_parser = XML_ParserCreate(NULL);
@@ -142,22 +145,22 @@ _xml_failure(XML_Parser parser, const char *file, int line) {
 static enum XML_Status
 _XML_Parse_SINGLE_BYTES(XML_Parser parser, const char *s, int len,
                         int isFinal) {
-  enum XML_Status res = XML_STATUS_ERROR;
-  int offset = 0;
-
-  if (len == 0) {
-    return XML_Parse(parser, s, len, isFinal);
-  }
-
-  for (; offset < len; offset++) {
-    const int innerIsFinal = (offset == len - 1) && isFinal;
-    const char c = s[offset]; /* to help out-of-bounds detection */
-    res = XML_Parse(parser, &c, sizeof(char), innerIsFinal);
-    if (res != XML_STATUS_OK) {
-      return res;
+  // This ensures that tests have to run pathological parse cases
+  // (e.g. when `s` is NULL) against plain XML_Parse rather than
+  // chunking _XML_Parse_SINGLE_BYTES.
+  assert((parser != NULL) && (s != NULL) && (len >= 0));
+  const int chunksize = g_chunkSize;
+  if (chunksize > 0) {
+    // parse in chunks of `chunksize` bytes as long as not exhausting
+    for (; len > chunksize; len -= chunksize, s += chunksize) {
+      enum XML_Status res = XML_Parse(parser, s, chunksize, XML_FALSE);
+      if (res != XML_STATUS_OK) {
+        return res;
+      }
     }
   }
-  return res;
+  // parse the final chunk, the size of which will be <= chunksize
+  return XML_Parse(parser, s, len, isFinal);
 }
 
 #define xml_failure(parser) _xml_failure((parser), __FILE__, __LINE__)
@@ -1054,7 +1057,7 @@ START_TEST(test_line_number_after_parse) {
                      "\n</tag>";
   XML_Size lineno;
 
-  if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_FALSE)
+  if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_TRUE)
       == XML_STATUS_ERROR)
     xml_failure(g_parser);
   lineno = XML_GetCurrentLineNumber(g_parser);
@@ -1071,7 +1074,7 @@ START_TEST(test_column_number_after_parse) {
   const char *text = "<tag></tag>";
   XML_Size colno;
 
-  if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_FALSE)
+  if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_TRUE)
       == XML_STATUS_ERROR)
     xml_failure(g_parser);
   colno = XML_GetCurrentColumnNumber(g_parser);
@@ -1139,7 +1142,7 @@ START_TEST(test_line_number_after_error) {
                      "  <b>\n"
                      "  </a>"; /* missing </b> */
   XML_Size lineno;
-  if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_FALSE)
+  if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_TRUE)
       != XML_STATUS_ERROR)
     fail("Expected a parse error");
 
@@ -1158,7 +1161,7 @@ START_TEST(test_column_number_after_error) {
                      "  <b>\n"
                      "  </a>"; /* missing </b> */
   XML_Size colno;
-  if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_FALSE)
+  if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_TRUE)
       != XML_STATUS_ERROR)
     fail("Expected a parse error");
 
@@ -2044,6 +2047,11 @@ parser_stop_character_handler(void *userData, const XML_Char *s, int len) {
   UNUSED_P(userData);
   UNUSED_P(s);
   UNUSED_P(len);
+  XML_ParsingStatus status;
+  XML_GetParsingStatus(g_parser, &status);
+  if (status.parsing == XML_FINISHED) {
+    return; // the parser was stopped by a previous call to this handler.
+  }
   XML_StopParser(g_parser, resumable);
   XML_SetCharacterDataHandler(g_parser, NULL);
   if (! resumable) {
@@ -2536,34 +2544,71 @@ START_TEST(test_memory_allocation) {
 }
 END_TEST
 
+struct handler_record_entry {
+  const char *name;
+  int arg;
+};
+struct handler_record_list {
+  int count;
+  struct handler_record_entry entries[50]; // arbitrary big-enough max count
+};
+
+#define handler_record_get(storage, index)                                     \
+  _handler_record_get((storage), (index), __FILE__, __LINE__)
+
+#define assert_record_handler_called(storage, index, expected_name,            \
+                                     expected_arg)                             \
+  do {                                                                         \
+    const struct handler_record_entry *e                                       \
+        = handler_record_get(storage, index);                                  \
+    assert_true(strcmp(e->name, expected_name) == 0);                          \
+    assert_true(e->arg == (expected_arg));                                     \
+  } while (0)
+
+static const struct handler_record_entry *
+_handler_record_get(const struct handler_record_list *storage, const int index,
+                    const char *file, const int line) {
+  if (storage->count <= index) {
+    _fail(file, line, "too few handler calls");
+  }
+  return &storage->entries[index];
+}
+
+static void
+record_call(struct handler_record_list *const rec, const char *funcname,
+            const int arg) {
+  const int max_entries = sizeof(rec->entries) / sizeof(rec->entries[0]);
+  assert_true(rec->count < max_entries);
+  struct handler_record_entry *const e = &rec->entries[rec->count++];
+  e->name = funcname;
+  e->arg = arg;
+}
+
 static void XMLCALL
 record_default_handler(void *userData, const XML_Char *s, int len) {
   UNUSED_P(s);
-  UNUSED_P(len);
-  CharData_AppendXMLChars((CharData *)userData, XCS("D"), 1);
+  record_call((struct handler_record_list *)userData, __func__, len);
 }
 
 static void XMLCALL
 record_cdata_handler(void *userData, const XML_Char *s, int len) {
   UNUSED_P(s);
-  UNUSED_P(len);
-  CharData_AppendXMLChars((CharData *)userData, XCS("C"), 1);
+  record_call((struct handler_record_list *)userData, __func__, len);
   XML_DefaultCurrent(g_parser);
 }
 
 static void XMLCALL
 record_cdata_nodefault_handler(void *userData, const XML_Char *s, int len) {
   UNUSED_P(s);
-  UNUSED_P(len);
-  CharData_AppendXMLChars((CharData *)userData, XCS("c"), 1);
+  record_call((struct handler_record_list *)userData, __func__, len);
 }
 
 static void XMLCALL
 record_skip_handler(void *userData, const XML_Char *entityName,
                     int is_parameter_entity) {
   UNUSED_P(entityName);
-  CharData_AppendXMLChars((CharData *)userData,
-                          is_parameter_entity ? XCS("E") : XCS("e"), 1);
+  record_call((struct handler_record_list *)userData, __func__,
+              is_parameter_entity);
 }
 
 /* Test XML_DefaultCurrent() passes handling on correctly */
@@ -2573,78 +2618,202 @@ START_TEST(test_default_current) {
                             "<!ENTITY entity '&#37;'>\n"
                             "]>\n"
                             "<doc>&entity;</doc>";
-  CharData storage;
 
-  XML_SetDefaultHandler(g_parser, record_default_handler);
-  XML_SetCharacterDataHandler(g_parser, record_cdata_handler);
-  CharData_Init(&storage);
-  XML_SetUserData(g_parser, &storage);
-  if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_TRUE)
-      == XML_STATUS_ERROR)
-    xml_failure(g_parser);
-  CharData_CheckXMLChars(&storage, XCS("DCDCDCDCDCDD"));
+  {
+    struct handler_record_list storage;
+    storage.count = 0;
+    XML_SetDefaultHandler(g_parser, record_default_handler);
+    XML_SetCharacterDataHandler(g_parser, record_cdata_handler);
+    XML_SetUserData(g_parser, &storage);
+    if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_TRUE)
+        == XML_STATUS_ERROR)
+      xml_failure(g_parser);
+    int i = 0;
+    assert_record_handler_called(&storage, i++, "record_default_handler", 5);
+    // we should have gotten one or more cdata callbacks, totaling 5 chars
+    int cdata_len_remaining = 5;
+    while (cdata_len_remaining > 0) {
+      const struct handler_record_entry *c_entry
+          = handler_record_get(&storage, i++);
+      assert_true(strcmp(c_entry->name, "record_cdata_handler") == 0);
+      assert_true(c_entry->arg > 0);
+      assert_true(c_entry->arg <= cdata_len_remaining);
+      cdata_len_remaining -= c_entry->arg;
+      // default handler must follow, with the exact same len argument.
+      assert_record_handler_called(&storage, i++, "record_default_handler",
+                                   c_entry->arg);
+    }
+    assert_record_handler_called(&storage, i++, "record_default_handler", 6);
+    assert_true(storage.count == i);
+  }
 
   /* Again, without the defaulting */
-  XML_ParserReset(g_parser, NULL);
-  XML_SetDefaultHandler(g_parser, record_default_handler);
-  XML_SetCharacterDataHandler(g_parser, record_cdata_nodefault_handler);
-  CharData_Init(&storage);
-  XML_SetUserData(g_parser, &storage);
-  if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_TRUE)
-      == XML_STATUS_ERROR)
-    xml_failure(g_parser);
-  CharData_CheckXMLChars(&storage, XCS("DcccccD"));
+  {
+    struct handler_record_list storage;
+    storage.count = 0;
+    XML_ParserReset(g_parser, NULL);
+    XML_SetDefaultHandler(g_parser, record_default_handler);
+    XML_SetCharacterDataHandler(g_parser, record_cdata_nodefault_handler);
+    XML_SetUserData(g_parser, &storage);
+    if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_TRUE)
+        == XML_STATUS_ERROR)
+      xml_failure(g_parser);
+    int i = 0;
+    assert_record_handler_called(&storage, i++, "record_default_handler", 5);
+    // we should have gotten one or more cdata callbacks, totaling 5 chars
+    int cdata_len_remaining = 5;
+    while (cdata_len_remaining > 0) {
+      const struct handler_record_entry *c_entry
+          = handler_record_get(&storage, i++);
+      assert_true(strcmp(c_entry->name, "record_cdata_nodefault_handler") == 0);
+      assert_true(c_entry->arg > 0);
+      assert_true(c_entry->arg <= cdata_len_remaining);
+      cdata_len_remaining -= c_entry->arg;
+    }
+    assert_record_handler_called(&storage, i++, "record_default_handler", 6);
+    assert_true(storage.count == i);
+  }
 
   /* Now with an internal entity to complicate matters */
-  XML_ParserReset(g_parser, NULL);
-  XML_SetDefaultHandler(g_parser, record_default_handler);
-  XML_SetCharacterDataHandler(g_parser, record_cdata_handler);
-  CharData_Init(&storage);
-  XML_SetUserData(g_parser, &storage);
-  if (_XML_Parse_SINGLE_BYTES(g_parser, entity_text, (int)strlen(entity_text),
-                              XML_TRUE)
-      == XML_STATUS_ERROR)
-    xml_failure(g_parser);
-  /* The default handler suppresses the entity */
-  CharData_CheckXMLChars(&storage, XCS("DDDDDDDDDDDDDDDDDDD"));
+  {
+    struct handler_record_list storage;
+    storage.count = 0;
+    XML_ParserReset(g_parser, NULL);
+    XML_SetDefaultHandler(g_parser, record_default_handler);
+    XML_SetCharacterDataHandler(g_parser, record_cdata_handler);
+    XML_SetUserData(g_parser, &storage);
+    if (_XML_Parse_SINGLE_BYTES(g_parser, entity_text, (int)strlen(entity_text),
+                                XML_TRUE)
+        == XML_STATUS_ERROR)
+      xml_failure(g_parser);
+    /* The default handler suppresses the entity */
+    assert_record_handler_called(&storage, 0, "record_default_handler", 9);
+    assert_record_handler_called(&storage, 1, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 2, "record_default_handler", 3);
+    assert_record_handler_called(&storage, 3, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 4, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 5, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 6, "record_default_handler", 8);
+    assert_record_handler_called(&storage, 7, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 8, "record_default_handler", 6);
+    assert_record_handler_called(&storage, 9, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 10, "record_default_handler", 7);
+    assert_record_handler_called(&storage, 11, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 12, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 13, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 14, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 15, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 16, "record_default_handler", 5);
+    assert_record_handler_called(&storage, 17, "record_default_handler", 8);
+    assert_record_handler_called(&storage, 18, "record_default_handler", 6);
+    assert_true(storage.count == 19);
+  }
 
   /* Again, with a skip handler */
-  XML_ParserReset(g_parser, NULL);
-  XML_SetDefaultHandler(g_parser, record_default_handler);
-  XML_SetCharacterDataHandler(g_parser, record_cdata_handler);
-  XML_SetSkippedEntityHandler(g_parser, record_skip_handler);
-  CharData_Init(&storage);
-  XML_SetUserData(g_parser, &storage);
-  if (_XML_Parse_SINGLE_BYTES(g_parser, entity_text, (int)strlen(entity_text),
-                              XML_TRUE)
-      == XML_STATUS_ERROR)
-    xml_failure(g_parser);
-  /* The default handler suppresses the entity */
-  CharData_CheckXMLChars(&storage, XCS("DDDDDDDDDDDDDDDDDeD"));
+  {
+    struct handler_record_list storage;
+    storage.count = 0;
+    XML_ParserReset(g_parser, NULL);
+    XML_SetDefaultHandler(g_parser, record_default_handler);
+    XML_SetCharacterDataHandler(g_parser, record_cdata_handler);
+    XML_SetSkippedEntityHandler(g_parser, record_skip_handler);
+    XML_SetUserData(g_parser, &storage);
+    if (_XML_Parse_SINGLE_BYTES(g_parser, entity_text, (int)strlen(entity_text),
+                                XML_TRUE)
+        == XML_STATUS_ERROR)
+      xml_failure(g_parser);
+    /* The default handler suppresses the entity */
+    assert_record_handler_called(&storage, 0, "record_default_handler", 9);
+    assert_record_handler_called(&storage, 1, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 2, "record_default_handler", 3);
+    assert_record_handler_called(&storage, 3, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 4, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 5, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 6, "record_default_handler", 8);
+    assert_record_handler_called(&storage, 7, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 8, "record_default_handler", 6);
+    assert_record_handler_called(&storage, 9, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 10, "record_default_handler", 7);
+    assert_record_handler_called(&storage, 11, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 12, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 13, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 14, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 15, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 16, "record_default_handler", 5);
+    assert_record_handler_called(&storage, 17, "record_skip_handler", 0);
+    assert_record_handler_called(&storage, 18, "record_default_handler", 6);
+    assert_true(storage.count == 19);
+  }
 
   /* This time, allow the entity through */
-  XML_ParserReset(g_parser, NULL);
-  XML_SetDefaultHandlerExpand(g_parser, record_default_handler);
-  XML_SetCharacterDataHandler(g_parser, record_cdata_handler);
-  CharData_Init(&storage);
-  XML_SetUserData(g_parser, &storage);
-  if (_XML_Parse_SINGLE_BYTES(g_parser, entity_text, (int)strlen(entity_text),
-                              XML_TRUE)
-      == XML_STATUS_ERROR)
-    xml_failure(g_parser);
-  CharData_CheckXMLChars(&storage, XCS("DDDDDDDDDDDDDDDDDCDD"));
+  {
+    struct handler_record_list storage;
+    storage.count = 0;
+    XML_ParserReset(g_parser, NULL);
+    XML_SetDefaultHandlerExpand(g_parser, record_default_handler);
+    XML_SetCharacterDataHandler(g_parser, record_cdata_handler);
+    XML_SetUserData(g_parser, &storage);
+    if (_XML_Parse_SINGLE_BYTES(g_parser, entity_text, (int)strlen(entity_text),
+                                XML_TRUE)
+        == XML_STATUS_ERROR)
+      xml_failure(g_parser);
+    assert_record_handler_called(&storage, 0, "record_default_handler", 9);
+    assert_record_handler_called(&storage, 1, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 2, "record_default_handler", 3);
+    assert_record_handler_called(&storage, 3, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 4, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 5, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 6, "record_default_handler", 8);
+    assert_record_handler_called(&storage, 7, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 8, "record_default_handler", 6);
+    assert_record_handler_called(&storage, 9, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 10, "record_default_handler", 7);
+    assert_record_handler_called(&storage, 11, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 12, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 13, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 14, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 15, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 16, "record_default_handler", 5);
+    assert_record_handler_called(&storage, 17, "record_cdata_handler", 1);
+    assert_record_handler_called(&storage, 18, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 19, "record_default_handler", 6);
+    assert_true(storage.count == 20);
+  }
 
   /* Finally, without passing the cdata to the default handler */
-  XML_ParserReset(g_parser, NULL);
-  XML_SetDefaultHandlerExpand(g_parser, record_default_handler);
-  XML_SetCharacterDataHandler(g_parser, record_cdata_nodefault_handler);
-  CharData_Init(&storage);
-  XML_SetUserData(g_parser, &storage);
-  if (_XML_Parse_SINGLE_BYTES(g_parser, entity_text, (int)strlen(entity_text),
-                              XML_TRUE)
-      == XML_STATUS_ERROR)
-    xml_failure(g_parser);
-  CharData_CheckXMLChars(&storage, XCS("DDDDDDDDDDDDDDDDDcD"));
+  {
+    struct handler_record_list storage;
+    storage.count = 0;
+    XML_ParserReset(g_parser, NULL);
+    XML_SetDefaultHandlerExpand(g_parser, record_default_handler);
+    XML_SetCharacterDataHandler(g_parser, record_cdata_nodefault_handler);
+    XML_SetUserData(g_parser, &storage);
+    if (_XML_Parse_SINGLE_BYTES(g_parser, entity_text, (int)strlen(entity_text),
+                                XML_TRUE)
+        == XML_STATUS_ERROR)
+      xml_failure(g_parser);
+    assert_record_handler_called(&storage, 0, "record_default_handler", 9);
+    assert_record_handler_called(&storage, 1, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 2, "record_default_handler", 3);
+    assert_record_handler_called(&storage, 3, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 4, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 5, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 6, "record_default_handler", 8);
+    assert_record_handler_called(&storage, 7, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 8, "record_default_handler", 6);
+    assert_record_handler_called(&storage, 9, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 10, "record_default_handler", 7);
+    assert_record_handler_called(&storage, 11, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 12, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 13, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 14, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 15, "record_default_handler", 1);
+    assert_record_handler_called(&storage, 16, "record_default_handler", 5);
+    assert_record_handler_called(&storage, 17, "record_cdata_nodefault_handler",
+                                 1);
+    assert_record_handler_called(&storage, 18, "record_default_handler", 6);
+    assert_true(storage.count == 19);
+  }
 }
 END_TEST
 
@@ -2933,7 +3102,7 @@ START_TEST(test_reset_in_entity) {
 
   resumable = XML_TRUE;
   XML_SetCharacterDataHandler(g_parser, clearing_aborting_character_handler);
-  if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_FALSE)
+  if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_TRUE)
       == XML_STATUS_ERROR)
     xml_failure(g_parser);
   XML_GetParsingStatus(g_parser, &status);
@@ -3626,8 +3795,6 @@ START_TEST(test_user_parameters) {
   if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_FALSE)
       == XML_STATUS_ERROR)
     xml_failure(g_parser);
-  if (comment_count != 2)
-    fail("Comment handler not invoked enough times");
   /* Ensure we can't change policy mid-parse */
   if (XML_SetParamEntityParsing(g_parser, XML_PARAM_ENTITY_PARSING_NEVER))
     fail("Changed param entity parsing policy while parsing");
@@ -4725,10 +4892,17 @@ END_TEST
 /* Test aborting the parse in an epilog works */
 static void XMLCALL
 selective_aborting_default_handler(void *userData, const XML_Char *s, int len) {
-  const XML_Char *match = (const XML_Char *)userData;
+  const XML_Char trigger_char = *(const XML_Char *)userData;
 
-  if (match == NULL
-      || (xcstrlen(match) == (unsigned)len && ! xcstrncmp(match, s, len))) {
+  int found = 0;
+  for (int i = 0; i < len; ++i) {
+    if (s[i] == trigger_char) {
+      found = 1;
+      break;
+    }
+  }
+
+  if (found) {
     XML_StopParser(g_parser, resumable);
     XML_SetDefaultHandler(g_parser, NULL);
   }
@@ -4736,10 +4910,10 @@ selective_aborting_default_handler(void *userData, const XML_Char *s, int len) {
 
 START_TEST(test_abort_epilog) {
   const char *text = "<doc></doc>\n\r\n";
-  XML_Char match[] = XCS("\r");
+  XML_Char trigger_char = XCS('\r');
 
   XML_SetDefaultHandler(g_parser, selective_aborting_default_handler);
-  XML_SetUserData(g_parser, match);
+  XML_SetUserData(g_parser, &trigger_char);
   resumable = XML_FALSE;
   if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_TRUE)
       != XML_STATUS_ERROR)
@@ -4752,10 +4926,10 @@ END_TEST
 /* Test a different code path for abort in the epilog */
 START_TEST(test_abort_epilog_2) {
   const char *text = "<doc></doc>\n";
-  XML_Char match[] = XCS("\n");
+  XML_Char trigger_char = XCS('\n');
 
   XML_SetDefaultHandler(g_parser, selective_aborting_default_handler);
-  XML_SetUserData(g_parser, match);
+  XML_SetUserData(g_parser, &trigger_char);
   resumable = XML_FALSE;
   expect_failure(text, XML_ERROR_ABORTED, "Abort not triggered");
 }
@@ -4764,10 +4938,10 @@ END_TEST
 /* Test suspension from the epilog */
 START_TEST(test_suspend_epilog) {
   const char *text = "<doc></doc>\n";
-  XML_Char match[] = XCS("\n");
+  XML_Char trigger_char = XCS('\n');
 
   XML_SetDefaultHandler(g_parser, selective_aborting_default_handler);
-  XML_SetUserData(g_parser, match);
+  XML_SetUserData(g_parser, &trigger_char);
   resumable = XML_TRUE;
   if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_TRUE)
       != XML_STATUS_SUSPENDED)
@@ -6634,13 +6808,13 @@ START_TEST(test_return_ns_triplet) {
   if (_XML_Parse_SINGLE_BYTES(g_parser, text, (int)strlen(text), XML_FALSE)
       == XML_STATUS_ERROR)
     xml_failure(g_parser);
-  if (! triplet_start_flag)
-    fail("triplet_start_checker not invoked");
   /* Check that unsetting "return triplets" fails while still parsing */
   XML_SetReturnNSTriplet(g_parser, XML_FALSE);
   if (_XML_Parse_SINGLE_BYTES(g_parser, epilog, (int)strlen(epilog), XML_TRUE)
       == XML_STATUS_ERROR)
     xml_failure(g_parser);
+  if (! triplet_start_flag)
+    fail("triplet_start_checker not invoked");
   if (! triplet_end_flag)
     fail("triplet_end_checker not invoked");
   if (dummy_handler_flags
@@ -9501,7 +9675,7 @@ START_TEST(test_alloc_nested_entities) {
          "ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"
          "'>\n"
          "<!ENTITY % pe2 '%pe1;'>\n"
-         "%pe2;",
+         "<!ENTITY % pe3 '%pe2;'>",
          "Memory Fail not faulted", NULL, XML_ERROR_NO_MEMORY};
 
   /* Causes an allocation error in a nested storeEntityValue() */
@@ -9896,6 +10070,53 @@ START_TEST(test_alloc_long_notation) {
 }
 END_TEST
 
+static int XMLCALL
+external_entity_parser_create_alloc_fail_handler(XML_Parser parser,
+                                                 const XML_Char *context,
+                                                 const XML_Char *base,
+                                                 const XML_Char *systemId,
+                                                 const XML_Char *publicId) {
+  UNUSED_P(base);
+  UNUSED_P(systemId);
+  UNUSED_P(publicId);
+
+  if (context != NULL)
+    fail("Unexpected non-NULL context");
+
+  // The following number intends to fail the upcoming allocation in line
+  // "parser->m_protocolEncodingName = copyString(encodingName,
+  // &(parser->m_mem));" in function parserInit.
+  allocation_count = 3;
+
+  const XML_Char *const encodingName = XCS("UTF-8"); // needs something non-NULL
+  const XML_Parser ext_parser
+      = XML_ExternalEntityParserCreate(parser, context, encodingName);
+  if (ext_parser != NULL)
+    fail(
+        "Call to XML_ExternalEntityParserCreate was expected to fail out-of-memory");
+
+  allocation_count = ALLOC_ALWAYS_SUCCEED;
+  return XML_STATUS_ERROR;
+}
+
+START_TEST(test_alloc_reset_after_external_entity_parser_create_fail) {
+  const char *const text = "<!DOCTYPE doc SYSTEM 'foo'><doc/>";
+
+  XML_SetExternalEntityRefHandler(
+      g_parser, external_entity_parser_create_alloc_fail_handler);
+  XML_SetParamEntityParsing(g_parser, XML_PARAM_ENTITY_PARSING_ALWAYS);
+
+  if (XML_Parse(g_parser, text, (int)strlen(text), XML_TRUE)
+      != XML_STATUS_ERROR)
+    fail("Call to parse was expected to fail");
+
+  if (XML_GetErrorCode(g_parser) != XML_ERROR_EXTERNAL_ENTITY_HANDLING)
+    fail("Call to parse was expected to fail from the external entity handler");
+
+  XML_ParserReset(g_parser, NULL);
+}
+END_TEST
+
 static void
 nsalloc_setup(void) {
   XML_Memory_Handling_Suite memsuite = {duff_allocator, duff_reallocator, free};
@@ -11672,6 +11893,8 @@ make_suite(void) {
   tcase_add_test(tc_alloc, test_alloc_long_public_id);
   tcase_add_test(tc_alloc, test_alloc_long_entity_value);
   tcase_add_test(tc_alloc, test_alloc_long_notation);
+  tcase_add_test__ifdef_xml_dtd(
+      tc_alloc, test_alloc_reset_after_external_entity_parser_create_fail);
 
   suite_add_tcase(s, tc_nsalloc);
   tcase_add_checked_fixture(tc_nsalloc, nsalloc_setup, nsalloc_teardown);
@@ -11728,7 +11951,14 @@ main(int argc, char *argv[]) {
   }
   if (verbosity != CK_SILENT)
     printf("Expat version: %" XML_FMT_STR "\n", XML_ExpatVersion());
-  srunner_run_all(sr, verbosity);
+
+  for (g_chunkSize = 0; g_chunkSize <= 5; g_chunkSize++) {
+    char context[100];
+    snprintf(context, sizeof(context), "chunksize=%d", g_chunkSize);
+    context[sizeof(context) - 1] = '\0';
+    fprintf(stderr, "Running context %s\n", context);
+    srunner_run_all(sr, verbosity);
+  }
   nf = srunner_ntests_failed(sr);
   srunner_free(sr);
 
-- 
2.18.2

