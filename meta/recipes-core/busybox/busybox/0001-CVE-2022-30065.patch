From 161cf958cb772ccb9b3cd28d3003d69cbe300e90 Mon Sep 17 00:00:00 2001
From: Denys Vlasenko <vda.linux@googlemail.com>
Date: Thu, 1 Jul 2021 16:02:16 +0200
Subject: [PATCH 1/2] awk: rename temp variables, no code changes

Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>

Upstream-Status: Backport [https://git.busybox.net/busybox/commit/?id=1573487e2100892d06e3628828690692313a48d5]
CVE: CVE-2022-30065
Signed-off-by: E V Ravi <reluri@mvista.com>
---
 editors/awk.c | 62 +++++++++++++++++++++++++++++++++++++----------------------
 1 file changed, 39 insertions(+), 23 deletions(-)

diff --git a/editors/awk.c b/editors/awk.c
index afde81a..94fc1d3 100644
--- a/editors/awk.c
+++ b/editors/awk.c
@@ -1685,14 +1685,14 @@ static node *mk_splitter(const char *s, tsplitter *spl)
 static regex_t *as_regex(node *op, regex_t *preg)
 {
 	int cflags;
-	var *v;
+	var *tmpvar;
 	const char *s;
 
 	if ((op->info & OPCLSMASK) == OC_REGEXP) {
 		return icase ? op->r.ire : op->l.re;
 	}
-	v = nvalloc(1);
-	s = getvar_s(evaluate(op, v));
+	tmpvar = nvalloc(1);
+	s = getvar_s(evaluate(op, tmpvar));
 
 	cflags = icase ? REG_EXTENDED | REG_ICASE : REG_EXTENDED;
 	/* Testcase where REG_EXTENDED fails (unpaired '{'):
@@ -1704,7 +1704,7 @@ static regex_t *as_regex(node *op, regex_t *preg)
 		cflags &= ~REG_EXTENDED;
 		xregcomp(preg, s, cflags);
 	}
-	nvfree(v);
+	nvfree(tmpvar);
 	return preg;
 }
 
@@ -2139,10 +2139,10 @@ static char *awk_printf(node *n)
 	const char *s1;
 	int i, j, incr, bsize;
 	char c, c1;
-	var *v, *arg;
+	var *tmpvar, *arg;
 
-	v = nvalloc(1);
-	fmt = f = xstrdup(getvar_s(evaluate(nextarg(&n), v)));
+	tmpvar = nvalloc(1);
+	fmt = f = xstrdup(getvar_s(evaluate(nextarg(&n), tmpvar)));
 
 	i = 0;
 	while (*f) {
@@ -2162,7 +2162,7 @@ static char *awk_printf(node *n)
 			f++;
 		c1 = *f;
 		*f = '\0';
-		arg = evaluate(nextarg(&n), v);
+		arg = evaluate(nextarg(&n), tmpvar);
 
 		j = i;
 		if (c == 'c' || !c) {
@@ -2183,7 +2183,7 @@ static char *awk_printf(node *n)
 	}
 
 	free(fmt);
-	nvfree(v);
+	nvfree(tmpvar);
 	b = xrealloc(b, i + 1);
 	b[i] = '\0';
 	return b;
@@ -2319,7 +2319,7 @@ static NOINLINE var *exec_builtin(node *op, var *res)
 {
 #define tspl (G.exec_builtin__tspl)
 
-	var *tv;
+	var *tmpvars;
 	node *an[4];
 	var *av[4];
 	const char *as[4];
@@ -2331,7 +2331,12 @@ static NOINLINE var *exec_builtin(node *op, var *res)
 	time_t tt;
 	int i, l, ll, n;
 
-	tv = nvalloc(4);
+	tmpvars = nvalloc(4);
+#define TMPVAR0 (tmpvars)
+#define TMPVAR1 (tmpvars + 1)
+#define TMPVAR2 (tmpvars + 2)
+#define TMPVAR3 (tmpvars + 3)
+#define TMPVAR(i) (tmpvars + (i))
 	isr = info = op->info;
 	op = op->l.n;
 
@@ -2339,7 +2344,7 @@ static NOINLINE var *exec_builtin(node *op, var *res)
 	for (i = 0; i < 4 && op; i++) {
 		an[i] = nextarg(&op);
 		if (isr & 0x09000000)
-			av[i] = evaluate(an[i], &tv[i]);
+			av[i] = evaluate(an[i], TMPVAR(i));
 		if (isr & 0x08000000)
 			as[i] = getvar_s(av[i]);
 		isr >>= 1;
@@ -2364,7 +2369,7 @@ static NOINLINE var *exec_builtin(node *op, var *res)
 
 		if (nargs > 2) {
 			spl = (an[2]->info & OPCLSMASK) == OC_REGEXP ?
-				an[2] : mk_splitter(getvar_s(evaluate(an[2], &tv[2])), &tspl);
+				an[2] : mk_splitter(getvar_s(evaluate(an[2], TMPVAR2)), &tspl);
 		} else {
 			spl = &fsplitter.n;
 		}
@@ -2507,7 +2512,13 @@ static NOINLINE var *exec_builtin(node *op, var *res)
 		break;
 	}
 
-	nvfree(tv);
+	nvfree(tmpvars);
+#undef TMPVAR0
+#undef TMPVAR1
+#undef TMPVAR2
+#undef TMPVAR3
+#undef TMPVAR
+
 	return res;
 #undef tspl
 }
@@ -2526,14 +2537,16 @@ static var *evaluate(node *op, var *res)
 #define seed   (G.evaluate__seed)
 #define sreg   (G.evaluate__sreg)
 
-	var *v1;
+	var *tmpvars;
+#define TMPVAR0 (tmpvars)
+#define TMPVAR1 (tmpvars + 1)
 
 	if (!op)
 		return setvar_s(res, NULL);
 
 	debug_printf_eval("entered %s()\n", __func__);
 
-	v1 = nvalloc(2);
+	tmpvars = nvalloc(2);
 
 	while (op) {
 		struct {
@@ -2573,7 +2586,7 @@ static var *evaluate(node *op, var *res)
 			}
 			if (op1->r.n) { /* array ref? */
 				const char *s;
-				s = getvar_s(evaluate(op1->r.n, v1));
+				s = getvar_s(evaluate(op1->r.n, TMPVAR0));
 				hash_remove(iamarray(v), s);
 			} else {
 				clear_array(iamarray(v));
@@ -2583,9 +2596,9 @@ static var *evaluate(node *op, var *res)
 
 		/* execute inevitable things */
 		if (opinfo & OF_RES1)
-			L.v = evaluate(op1, v1);
+			L.v = evaluate(op1, TMPVAR0);
 		if (opinfo & OF_RES2)
-			R.v = evaluate(op->r.n, v1+1);
+			R.v = evaluate(op->r.n, TMPVAR1);
 		if (opinfo & OF_STR1) {
 			L.s = getvar_s(L.v);
 			debug_printf_eval("L.s:'%s'\n", L.s);
@@ -2664,7 +2677,7 @@ static var *evaluate(node *op, var *res)
 					fputs(getvar_s(intvar[F0]), F);
 				} else {
 					while (op1) {
-						var *v = evaluate(nextarg(&op1), v1);
+						var *v = evaluate(nextarg(&op1), TMPVAR0);
 						if (v->type & VF_NUMBER) {
 							fmt_num(g_buf, MAXVARFMT, getvar_s(intvar[OFMT]),
 									getvar_i(v), TRUE);
@@ -2751,7 +2764,7 @@ static var *evaluate(node *op, var *res)
 			/* if source is a temporary string, jusk relink it to dest */
 //Disabled: if R.v is numeric but happens to have cached R.v->string,
 //then L.v ends up being a string, which is wrong
-//			if (R.v == v1+1 && R.v->string) {
+//			if (R.v == TMPVAR1 && R.v->string) {
 //				res = setvar_p(L.v, R.v->string);
 //				R.v->string = NULL;
 //			} else {
@@ -2775,7 +2788,7 @@ static var *evaluate(node *op, var *res)
 
 			vbeg = v = nvalloc(op->r.f->nargs + 1);
 			while (op1) {
-				var *arg = evaluate(nextarg(&op1), v1);
+				var *arg = evaluate(nextarg(&op1), TMPVAR0);
 				copyvar(v, arg);
 				v->type |= VF_CHILD;
 				v->x.parent = arg;
@@ -3095,7 +3108,10 @@ static var *evaluate(node *op, var *res)
 			break;
 	} /* while (op) */
 
-	nvfree(v1);
+	nvfree(tmpvars);
+#undef TMPVAR0
+#undef TMPVAR1
+
 	debug_printf_eval("returning from %s(): %p\n", __func__, res);
 	return res;
 #undef fnargs
-- 
2.7.4

